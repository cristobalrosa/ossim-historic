Binary files snort-2.7.0/doc/faq.pdf and snort-2.7.0.mod/doc/faq.pdf differ
diff -rNu snort-2.7.0/doc/README.Spade snort-2.7.0.mod/doc/README.Spade
--- snort-2.7.0/doc/README.Spade	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/doc/README.Spade	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,238 @@
+README file for the Spade v021031.1
+-----------------------------------
+
+Greetings,
+
+Welcome to release version 021031.1 of the Spade sensor for Snort. Spade
+stands for Statistical Packet Anomaly Detection Engine and is produced by
+Silicon Defense (http://www.silicondefense.com/).  It reports on report
+unusual, possibly suspicious, packets.  Spade is available via a Snort
+preprocessor plugin.
+
+This document gives an overview of Spade.  The "Getting Started" section
+towards the end of the file will help you get going quickly.  See the Usage
+file for information about installing and using Spade.  See the COPYING file
+for the GNU GPL license.
+
+SPICE is the Stealthy Probing and Intrusion Correlation Engine.  It is part
+of Silicon Defense's work an (unclassified) project funded by the US DARPA
+under different programs.  It consists of two parts, an anomaly sensor
+(Spade) and an event correlator.  The basic operation of this will be that
+Spade will monitor the network and report anomalous events to the
+correlator.  The correlator will then group these events together and send
+out reports of unusual activity (e.g., portscans), even those that have been
+crafted to be difficult to detect (e.g., they probe slowly, from different
+sources, or they randomize the scan).  This distribution is the sensor
+component of Spice.  Stay tuned for the availability of the correlator.
+
+We release this in the hopes that it will be useful.  To us, it has been,
+but of course your mileage may vary.
+
+We would really like your comments on Spade.  One of the reasons we have
+released this is so that we will have different people's feedback so that we
+can improve it.  In particular, we know that your experience with this will
+depend on the characteristics of your network.  E-mail the contact author,
+Jim Hoagland (hoagland@SiliconDefense.com) with any comments or suggestions.
+
+This is released under GNU GPL, which among other things, means that we
+express no warranty for the program.
+
+The web page for Spade and Spice is
+http://www.silicondefense.com/software/spice/.  You can download the latest
+releases of it there.  Also there you can access the Journal of Computer
+Security paper describing the theory behind Spice and learn about some of
+novel data structures and algorithms it uses.
+
+
+----==== What does it do? ====---- 
+
+Spade will review the packets received by Snort, find those of interest and
+report those packets that it believes are anomalous along with an anomaly
+score.
+
+The anomaly score that is assigned is based on the observed history of the
+network.  The fewer times that a particular kind of packet has occurred in
+the past, the higher its anomaly score will be.  Packets are classified by
+their joint occurrence of packet field values.  For example, packets with
+destination IP of 10.10.10.10 and destination port of 8080 might be one kind
+of packet.
+
+To do this, probability tables are maintained that reflect the occurrences
+of different kinds of packets in history, with higher weight on more recent
+events.  We would know, for example, that P(dip=10.10.10.10,dport=8080) is
+10% but that P(dip=10.10.10.10,dport=8079) is 0.1%.  The raw anomaly score
+is calculated directly from the probability.  For a packet X, A(X)=
+-log2(P(X)). So the anomaly score for a 10.10.10.10, 8080 packet is 3.32
+(not very anomalous) and the score for a 10.10.10.10, 8079 packet is 9.97
+(fairly anomalous (?)).  The raw anomaly score is what Spade has
+traditionally had.  Starting with Spade v021007.1, we introduce a relative
+anomaly score, which is the raw anomaly score divided by the highest
+possible raw anomaly score.  This produces a result which is always between
+0 and 1 and thus means the degree of anomalousness in the score is easier to
+interpret.
+
+At any given time, a reporting threshold is defined for the sensor.  For
+each event that exceeds this threshold, an alert is sent.  It is sent to the
+same place(s) that a rule-based alert would be sent to (e.g., Snort alert
+file, syslog, a Snort database, etc.).
+
+In addition to reporting anomalous events, Spade can also be configured to
+generate reports about the network on which it is run.  For example, it can
+tell you the amount of entropy in your destination ports and in your source
+ports given your destination ports or produce periodic reports of the number
+of packets seen and order statistics such as median of the anomaly scores
+produced.
+
+
+----==== What doesn't it do? ====---- 
+
+Spade cannot tell you if a particular reported packet is bad or hostile.  
+It merely knows that certain packets are relatively unusual and has an idea
+how unusual.  You should expect to see alerts about benign activity.
+
+It also cannot report things like attempts to exploit CGI vulnerabilities on
+a popular web server.  This would depend on looking at the packet contents
+and Spade just looks at certain parts of the header.
+
+Spade will not group related anomalous events together.  That is the job of
+the Spice correlator and in any case is best handled outside on an IDS
+sensor.  You might consider using SnortSnarf
+(http://www.silicondefense.com/software/snortsnarf/) to help with this task;
+version 090700.1 and above generate a special section to browse anomaly
+reports.
+
+
+----==== Spade Output ====---- 
+
+Spade produces two types of messages, which, depending on how Spade is
+configured, are sent to Snort's configured alert or log facilities (e.g.,
+alert file, database, etc.).  Brief descriptions are presented here with
+more details in the Usage file.
+
+The more common one has a message in the form "Spade: <activity
+description>: <scope>: <anomaly score>", where <activity description>
+describes what Spade is reporting on, <scope> explains the type of packet
+that was being examined, and <anomaly score> is the raw or relative anomaly
+score that Spade has assessed for the packet.  (Sorry this line is so
+cramped; Snort has no facility to pass along these extra bits of information
+to the output plugins other than through the message field.)
+
+Spade may also periodically produce messages of the form: "Spade: id=<id>:
+Threshold adjusted to T after X alerts (of N)".  This indicates that the
+alerting threshold for detector <id> was changed to T.  This happens when
+you are using one of the threshold adapting mechanisms (see the Usage file).
+ The message also gives information about the number of alerts (X) sent
+since the last time the threshold was adjusted and the total number of
+packets (N) accepted by Spade during that time.
+
+
+----==== Detectors and Detector Types ====---- 
+
+A Spade detector is a component within Spade that is looking for a
+particular type of anomaly over a certain set of packets.  You can configure
+Spade can to employ any number of detectors simultaneously.  These can be of
+different types (where the detection approach is different) or of the same
+type but applied to a different set of packets.  There are five detector
+types included in this release of Spade:
+
++ closed-dport:  This is the traditional Spade detector type.  This detector
+type is looking for packets that are going to closed ports, or at least
+ports that are infrequently used.  This can be used to find portscans
+because legitimate traffic tends to go to open ports.
+
++ dead-dest:  This detector type looks for packets that are going to an IP
+address that is not in use.  This can be used to find portscans because
+legitimate traffic tends to go to live IP addresses.
+
++ odd-dport:  This detector type looks for sources that are using unusual
+destination ports.  This might indicate a compromised host or host misuse
+because destination ports roughly correspond to applications and hosts tend
+to be habitual in application use.
+
++ odd-port-dest:  This detector type looks for sources that make a
+connection to an unusual destination relative to what is normal for the
+destination port.  Since this is only applied to cases where the destination
+is fairly predictable (e.g., as is often the case for port 110 (POP3) and
+port 53 (DNS) on client hosts), this might indicate a compromised host or
+host misuse.
+
++ odd-typecode:  The detector type looks for packets with unusual ICMP type
+and code values.  This may be interesting to know about even when it is not
+suspicious.
+
+We anticipate adding other detector types in future releases.
+
+
+----==== Waiting for a response ====---- 
+
+Depending on detector type, what a detector is being applied to, and user
+configuration, Spade might wait for a follow-up packet for a short amount of
+time before sending off an alert.  It does this in the interest of reducing
+false positives.  In this time, it is looking for a follow-up packet.  Such
+a packet might discount the fact a packet is anomalous or might further
+suggest the fact that it is.  You might view this as another filter applied
+to the packet stream (where having a high anomaly score was the another
+one).
+
+If Spade is put on a point in your network where it will not see the
+responses, this waiting adds no value.  And the subset of Spade's
+functionality that requires responses will not be available to you at that
+tap point.
+
+
+----==== Performance ====---- 
+
+Efficiency will depend on many factors including configuration (especially
+the set of detectors enabled) and will vary from network to network.  We've
+seen performance on the order of 15 microseconds per packet with the
+distributed detector configuration on an 800 MHz P3 (exclusive of Snort's
+reporting but including all other overhead).  Your memory usage will also
+vary but will probably be less than 10 MB or so.  odd-port-dest is known to
+be slower and to use alot of memory.  If your network sees more traffic,
+especially different kinds of traffic, we would expect that your memory
+usage will increase proportionally and your CPU use to increase a little
+(per packet).
+
+Although Spade 020107.1 included a significant restructuring and expansion
+of its capabilities, most of the core functionality was only cosmetically
+changed.  So, we expect this new Spade to be nearly as stable as the
+previous version, which we had no complaints about.
+
+
+----==== Getting Started ====---- 
+
+First you will need to install Spade into Snort as described in the
+"Installation" file.
+
+spade.conf is an example configuration file; use it as your Snort config
+file or include it in your current Snort config file.  It is a good starting
+point for most people as distributed.  If you want to get going quickly, you
+might just want to edit the SPADEDIR variable and the spade-homenet list and
+try it out.  Otherwise, you can browse through the Spade.Usage file to see
+what all your options are and to understand your reports.  If you want to use more of Spade's capabilities (albeit ones that tend to be noisier), you might want to start off with spade.more.conf.
+
+
+----==== Mailing lists ====---- 
+
+You are invited to sign up for the mailing list about Spade.
+
+Spade-users:  A list for users to talk about Spade
+  http://www.silicondefense.com/mailman/listinfo/spade-users
+  spade-users@list.silicondefense.com
+
+You can share your questions and ideas regarding Spade on this list.
+
+
+----==== Contributions ====---- 
+
+We welcome your complaints, kudos, and especially improvements and bugfixes.
+We wish for this to be a useful as possible, so your feedback and assistance
+is important.  You may reach us at hoagland@SiliconDefense.com.
+
+Thank you and happy Spading!
+
+-- Jim Hoagland (hoagland@SiliconDefense.com)
+   Stuart Staniford (stuart@SiliconDefense.com)
+
+P.S.  Incidentally, Spade can be fairly easily ported to other network-based
+IDSs.  Let us know if you are interested.
Binary files snort-2.7.0/doc/snort_manual.pdf and snort-2.7.0.mod/doc/snort_manual.pdf differ
diff -rNu snort-2.7.0/doc/Usage.Spade snort-2.7.0.mod/doc/Usage.Spade
--- snort-2.7.0/doc/Usage.Spade	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/doc/Usage.Spade	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,989 @@
+Usage file for the Spade v021031.1
+----------------------------------
+
+Author: Jim Hoagland (hoagland@SiliconDefense.com)
+
+This file contains information about how to use and configure the
+Statistical Packet Anomaly Detection Engine (Spade).  This assumes you have
+read the README.Spade file.  Note that while configuration backwards
+compatibility is provided with Spade 011801.1 and earlier, only the new
+preferred style is documented here.
+
+
+----==== The main configuration line ====----
+
+To enable Spade, the main Spade line must appear in your Snort configuration
+file.  Furthermore, it must appear before any Spade configuration lines. 
+This is the form of this line:
+
+preprocessor spade: {<optionname>=<value>}
+
+That is, there is any number of option assignments.  The available options
+are: logfile, statefile, cpfreq, dest, and adjdest.  The meaning of these
+options are described in the following three sections and the sections
+beyond that describe additional configuration options.  (In this manual, a
+reference to "the <optionname> option" or to <optionname> as a value should
+be interpreted as a reference to the <value> portion of the option
+<optionname>.)
+
+
+----==== Log file ====----
+
+The "logfile" option specifies the logging file for Spade.  This is
+regenerated on every SIGHUP, SIGQUIT, SIGINT and SIGUSR1 and on Snort exit.
+At a minimum, the total number of packets received by Spade is listed as is
+a section for each detector.  This section contains statistics useful in
+tuning the detector. Some optional parts of Spade write to this log file as
+well and may cause it to be regenerated at other times.
+
+If this option is '-', then standard output (stdout) is used.  '-' is the
+default.
+
+
+----==== Checkpointing and recovery ====----
+
+Since Spade maintains history-based probability tables, it is important to
+have persistent storage for these table, especially since some sites restart
+their snort processes regularly.
+
+Towards this end, Spade has a checkpoint and recovery feature.  (At present,
+this just covers the probability tables.)  The state file can be specified
+by the "statefile" option and defaults to "spade.rcv".  If this file is
+present when starting up, the initial state of Spade is taken from this. 
+(Otherwise it starts up with a clean slate.)  Periodically this state file
+is updated with the current state.  This is done with a frequency of every
+"cpfreq" updates to the state (default 50000), on SIGHUP, SIGINT, SIGQUIT,
+and SIGUSR1, and on Snort exit.
+
+To disable checkpointing and recovering (not generally recommended), give
+"/dev/null" or "0" as the "statefile" option.
+
+Note that the size of the of file is roughly the size of Spade in memory.
+Also note that it may take a few seconds to checkpoint during which time
+snort will not otherwise run.
+
+Also note that the checkpointing and recovery process is designed to be
+transparent to the user.  However, there are a few situations in which you
+need to pay attention to it.  One of these is when you are experimenting
+with Spade, subjecting it to unusual traffic.  Another is if you start to
+apply Spade to a different network.  In these cases, be sure delete this
+file before starting Spade.
+
+
+----==== Where the alerts go ====----
+
+As indicated in the README file, there are two main types of messages that
+Spade produces.  You can control where these go with the "dest" and
+"adjdest" options on the main Spade configuration line.
+
+The "dest" option can be set to either "alert", "log", or "both".  "alert"
+(the default) means the alerts will go to the Snort alert facility(ies) that
+you have configured, "log" means it go to your configured Snort log
+facility(ies), and "both" means it will go to both locations.
+
+Unless you provide the "adjdest" option, the above applies both the anomaly
+reports and to the threshold adjusted messages.  "adjdest" will override
+this for the threshold adjusted messages.  It accepts the three options
+above plus "none" which will cause these messages to go nowhere.
+
+
+----==== Home networks ====----
+
+Spade will work best if you tell it what network(s) are "inside" of its
+location on the network.  That is, the networks that are being connected to
+a larger network.  (If this concept is a bit fuzzy for your location, just
+set this to your best advantage.)  This is mostly used by Spade to indicate
+which hosts we are expected to get good knowledge about by watching the
+traffic going past Spade.
+
+The spade-homenet line in your snort configuration file specifies these.  It
+takes one of two forms:
+
+    preprocessor spade-homenet: <network> <network> ...
+
+or 
+
+    preprocessor spade-homenet: [<network>,<network>,...]
+
+For both of these, <network> is either CIDR notation for a network (e.g.,
+123.123.128.0/17), an IP address (e.g. 123.123.123.123), or "any" (denoting
+0.0.0.0/0).  If a spade-homenet line is not provided, "any" is your homenet.
+
+Note that this home network specification is independent of the -h option of
+snort and the HOMENET variable in the rules file.
+
+
+----==== Spade detectors ====----
+
+You start up a Spade detector by a line of the form:
+
+    preprocessor spade-detect: {<optionname>=<value>}
+    
+The options that are available will vary with the type of detection you are
+enabling.  The options that are available in more than one detector type are
+described below with all the options available for a given type are
+described in the subsection devoted to that type.
+
+You can enable any number of detectors in Spade by repeatedly providing this
+line; each indicates a separate detector to start up.  (Unless you provide
+at least one spade-detect line or if the main Spade configuration line
+contains deprecated elements, backwards compatibility mode is engaged.  In
+this mode, just one detector is active with a specific type of detection as
+well (type=closed-dport to=home probmode=3 proto=tcp tcpflags=synonly
+relscore=off corrscore=0, unless modified by the deprecated elements). 
+However, you are encouraged to explicitly provide spade-detect lines.)
+
+---=== Common configuration options ===---
+
+These options are available with more than one detector type.
+
+type:  The "type" option indicates the detector type.  Available in this
+    release are "closed-dport", "dead-dest", "odd-dport", "odd-typecode".
+    "closed-dport" is the default.
+
+to:  The "to" scope-defining option lets you chose what direction of traffic
+    to apply the detector to.  If "to" is "home" (the default), the traffic
+    with destinations in your homenet will be examined for anomalies.  If it
+    is "nothome", then outbound traffic will be examined.  If it is "any",
+    then both will be examined.
+
+from:  The "from" scope-defining option lets you choose what sources you
+    want monitored by the detector.  If "from" is "home" (the default), the
+    traffic with a source in your homenet will be examined for anomalies. 
+    If it is "nothome", then externally-sourced traffic will be examined. 
+    If it is "any", then both will be examined.
+
+proto:  This scope-defining option indicates what protocol the detector is
+    being applied to.  "tcp", "udp", and "icmp" are the possible choices
+    and "tcp" is the default.
+
+tcpflags:  When the detector is looking at TCP packets, this scope-defining
+    option indicates which set of TCP flag combinations to look at for
+    anomalous packets.  These are the possibilities (each of which ignore
+    the reserved bits):
+
+    + synonly: only the SYN flag is present
+    + synack: just the SYN and ACK flags are present
+    + setup: the flags make the packet look like the connection setup to a
+        TCP session (i.e., it is synonly or synack)
+    + established: the flags make the packet look like the data-transfer
+        portion of a TCP session
+    + teardown: the flags make the packet look like the (normal or abrupt)
+        closing portion of a TCP session
+    + weird: the flags are nothing that would be found in a TCP session
+        (note that these last 4 tcpflags values are disjoint but cover all
+        possible flags)
+
+    Which exactly of these is available varies with the detector type. 
+    However, "synonly" is the default everywhere where "tcpflags" is
+    accepted.
+
+icmptype:  When the detector is looking at ICMP packets, this scope-defining
+    option indicates which set of ICMP types to look for.  "all" means every
+    value of ICMP type, "err" means those types that indicate an error
+    response (types 3, 4, 5, 11, 12), and "noterr" means the types not
+    indicating an error response.  The default varies with the detection
+    type.
+
+thresh:  This is the (initial) threshold at which packets are reported. If a
+    packet has an anomaly score at least as big as this threshold, it can be
+    sent as an alert.  The detector will produce no reports if this is a
+    negative number.  The default varies with the detector type.
+
+minobs:  This is the minimum number of observations that must be present
+    before the anomaly score is considered reliable.  This is useful because
+    when a detector is first starting up, it does not initially have a good
+    reading of the network.  The specific thing that is being counted and
+    the default varies with detector type.  In any case, if there are not
+    the specified number of observations, a report will not be sent.
+
+wait:  The precise meaning on the "wait" option will vary with detection
+    type and detector scope, but in all cases it is the number of seconds a
+    report that is held on the waiting queue will wait before timing out.
+    This is an integer.  If a response is found sooner, it will be removed
+    at that point.  Note that this wait time is only approximate.  This is
+    because evictions from the waiting queue only happen periodically (once
+    a second).  Also note that evictions will not occur in the absence of
+    Spade getting a packet from Snort because Spade bases its notion of time
+    on the time of packet and not on the real time clock.
+
+Xdips:  Suppress (eXclude) reports from this detector about certain
+    destination IP or destination networks. The presently accepted format is
+    a simple comma separated list of IP addresses and CIDR-denoted networks.
+     Default is to exclude no destination IPs.  You will see no reports from
+    this detector of packets to this host.
+
+Xdports:  Suppress reports from this detector about certain destination port
+    numbers. The value must be a comma-separated list of port numbers
+    presently accepted format is a simple comma separated list of.  Default
+    is to exclude no destination ports.  You will see no reports from this
+    detector of packets to this port number.
+
+Xsips:  Suppress reports from this detector about certain source IP or source
+    networks. The presently accepted format is a simple comma separated list
+    of IP addresses and CIDR-denoted networks.  Default is to exclude no
+    source IPs.  Be aware that you a creating a blind spot for this source's
+    packets with respect to this detector.
+
+Xsports:  Suppress reports from this detector about certain source port
+    numbers. The value must be a comma-separated list of port numbers
+    presently accepted format is a simple comma separated list of.  Default
+    is to exclude no source ports.  Be aware that if a source chooses to use
+    this source, this detector will not report this packet.
+
+id:  The id option provides a label to the detector that the user can refer
+    to.  This must start with a letter and can contain letters, numbers, '-'
+    and '_'.  This option is only needed when using some of configuration
+    lines described later that refer to a particular detector.
+
+Advanced options:
+
+revwaitrpt:  If response waiting is in effect for the detector, this option
+    will cause the report to be generated in the opposite response case. 
+    That is, this will change open waiting into closed waiting and vis
+    versa.  This can be used for example with detector type closed-dport to
+    report only on SYNs going to open but rarely used ports.  The default is
+    not to do this.  This has no effect if response waiting in not in use in
+    the detector.
+
+These four options deal with how long a network observation will be
+retained and how much weight is given to it over that time.
+
+scalefreq:  This option is how often (in whole minutes) the existing set of
+    observations are scaled down in weight (decayed) in favor of new
+    observations.  Note that scaling is a generally brief but fairly CPU
+    intensive operation.
+
+scalefactor:  This option is the relative weight to give to traffic observed
+    before scaling as compared to the traffic after.  So, the probabilities
+    you had before the scale is only "scalefactor" as important as those in
+    the later period.  This option and "scalefreq" imply a certain half life
+    for observations.  For example, 240 minutes and 0.96409 together imply a
+    half life of a little over 3 days.
+    
+scalehalflife:  This option is provided as an aid in adjusting the scaling
+    factor to achieve a certain half life.  The value of this argument is
+    the desired half life in hours.  If specified, the scaling factor
+    above will overrode in favor of required value to have observations
+    have the given half life given the scaling frequency.
+
+scalecutoff:  At some point, the occurrence of something a long time ago
+    (relative to the number of times it occurred) makes little difference in
+    the anomaly scores produces, so it might as well be discarded to save
+    memory and time.  "scalecutoff" is the size of an occurrence count at
+    which the record of something has occurred is discarded.  This and the
+    half life indicate how long N occurrences of something at one point in
+    time will remain remembered.  For example, a cutoff of 0.18 and a half
+    life of 3 days implies that a single occurrence of something will be
+    forgotten after a little over a week.
+
+
+---=== The closed-dport detector type ===---
+
+The idea behind the closed-dport detector type is that one can distinguish
+probable portscan packets from normal traffic by looking at what IP and port
+it is headed for.  This is because servers run on well known and often
+well-used ports.  However, a portscanner would not know what is normal and
+would hit ports that are rarely used.  This would also apply to other
+phenomena that exhibit scanning-type behavior such as some worms.  This
+technique can also be more focussed on ports that actually are closed
+(rather than including open but rarely used ports).
+
+This detector type is available for all kinds of TCP and UDP packets, even
+those not known to be presently used by port-scanners.  (In traditional
+Spade, this functionality was only available for internally destined TCP SYN
+traffic.)  For TCP SYN packets, there is an option to wait for a response to
+see if the port was actually open (this will essentially eliminate reports
+about passive FTP).  For non-SYN TCP packets with legal flag combinations,
+this wait is mandatory and a RST is needed to cause an alert (this because
+most TCP packets provide no indication which side of the connection is the
+server and hence should be listening on a well known port).  For UDP
+packets, there is an option to wait for an ICMP unreachable message before
+sending a report.
+
+Anomaly reports from a detector with this detector type contain one of three
+activity descriptions.  If response waiting is not enabled, the text is
+"Rare dest port used".  If response waiting is enabled, and revwaitrpt is
+not in effect, the text is "Closed dest port used".  If response waiting is
+enabled and revwaitrpt is in effect, the text is "Rare but open dest port
+used".
+
+--== Options ==--
+
+to,id:  See "Common configuration options".
+
+protocol:  See "Common configuration options".  "tcp" and "udp" are available.
+
+tcpflags:  See "Common configuration options".  synonly, synack, established,
+    teardown, and weird are available.
+
+relscore:  This indicate whether to use relative scores rather than raw
+    scores.  The default is to do this, but if you set this option to "off",
+    "false", "no", or 0, raw scores will be used.
+
+thresh:  The (initial) reporting threshold.  The default is 0.85 for relative
+    scores and -1 (off) for raw scores.
+
+minobs:  This is the minimum number an observations about a given
+    destination IP address that we need make before we produce any reports
+    about traffic to that address.  The default is 400 for relative scores
+    and 0 for raw scores.
+
+wait:  This is how long to wait for a response packet.  The default is 0
+    except for TCP synack, established, and teardown cases in which case the
+    default is 5 and it cannot be set to 0.
+
+Advanced options:
+
+scalefreq/scalefactor/scalecutoff:  See "Common configuration options".  The
+    defaults are: 240/0.96409/0.18 (observations have a half life of 3 days
+    and single observations will be forgotten after a week).
+
+scalehalflife: See "Common configuration options".
+
+Obscure options:
+
+corrscore:  Provided for backwards compatibility when raw scores are being
+    used, if this option is "off", "false", "no", or 0, the raw score is
+    calculated in a slightly incorrect way.  However, the incorrectness is
+    usually unimportant.
+
+probmode:  There are four probability modes available in closed-dport. 
+    These modes configure how Spade determines the likelihood of a
+    particular packet.  We think that the default (#3) is the best but it is
+    possible that network will disagree.  This describes the options:
+
+    + 0:  a Bayes network approximation of P(sip,sport,dip,dport)
+    + 1:  P(sip,sport,dip,dport)
+    + 2:  P(sip,dip,dport)
+    + 3:  P(dip,dport)
+
+    If probmode is set to 0, then "relscore" is forced off and "minobs" and
+    "corrscore" do not apply.
+
+--== What traffic is recorded ==--
+
+For detectors applied to TCP, only SYN packets have observations recorded
+about them.  (This should be pretty representative.)  For detectors applied
+to UDP, all UDP packets are recorded.
+
+--== Waiting behavior ==--
+
+This describes the detectors behavior when response waiting is enabled.
+
+When response waiting is enabled for TCP SYN packets, a SYN-ACK packet going
+in the reverse direction with the same set of IPs and ports is considered to
+indicate that the port is open and thus the waiting report is dropped.  If
+there is no response observed within the waiting time, the report will be
+sent.
+
+For other types of TCP packets, a negative response is required.  This
+negative response is embodied by RST packet going in the reverse direction
+with the same set of IPs and ports.  If this is seen, then the report will
+be sent, but it if times out, the report will be dropped.  The situation is
+similar for UDP packets, except that the contents of an ICMP unreachable
+message must list the same set of IPs and ports going in the same direction
+to be considered a negative response.
+
+--== Notes ==--
+
+Outbound traffic:  Detection in this direction is expected to be less
+reliable since you don't know the destinations as well.  But using a hearty
+"minobs" should help.
+
+TCP SYN-only: Unless waiting is enabled, you will see passive FTP traffic
+reported.  This is because passive FTP is unusual in that the server
+temporarily opens a non-well known port that is legitimate to connect to. 
+On the other hand, by enabling waiting, you will not see connection attempts
+to rarely used servers.
+
+Non-SYN and non-weird TCP: You will not get reports about probes to
+non-responsive hosts, to filtered ports and to open ports unless the open
+port is on a Windows machine.  You can use the dead-dest detector type to
+catch traffic to unused IP addresses.
+
+TCP SYN-ACK and RST to local destinations:  Reports from this detector type
+about these kinds of packets may be back-scatter from a SYN packet with a
+source IP that was forged to be an IP address in your network range (this is
+not unusual in DOS attacks).  The original probe would have been in the
+reverse direction.  You can note the pattern of traffic and the destination
+IPs to try to distinguish this from a scan.
+
+TCP established and teardown:  There seem to be several situations in which
+IPs will send a RST at the end of a legitamite connection.  This detector
+may preceive this to be a sign of an unwanted packet and report on it.
+
+UDP: There is no way to distinguish server from client at a packet level, so
+you get some reports on responses to some previous communication to a
+server.  Enabling waiting should help.
+
+
+---=== The dead-dest detector type ===---
+
+The idea behind the dead-dest detector type is that legitimate traffic does
+not typically go to inactive IP addresses.  On the other hand, those
+performing horizontal scanning (including some worms) would not know what IP
+addresses are active and which are inactive.  So, we watch the network to
+see what IP addresses are currently in use and if an packet is headed
+towards a totally quiet IP address, we report on it (perhaps after waiting a
+few seconds for a response).
+
+This detector type is available for all kinds of inbound TCP, UDP and ICMP
+packets, even those not known to be presently used by port-scanners.  For
+all scopes except weird TCP flags, false positive elimination through
+waiting for a response is available.
+
+Anomaly reports from a detector with this detector type contain the activity
+description "Non-live dest used".  The score will always be 1 since our
+threshold is fixed at that level.
+
+--== Options ==--
+
+protocol,id:  See "Common configuration options".
+
+tcpflags:  See "Common configuration options".  synonly, synack, setup,
+    established, teardown, and weird are available.
+
+icmptype:  See "Common configuration options".  noterr is the default.
+
+minobs:  This is the minimum number an observations about your homenet that
+    we need make before we produce any reports.  The default is 2000.
+
+wait:  This is how long to wait for a response packet.  The default is 0.
+
+Advanced options:
+
+scalefreq/scalefactor/scalecutoff:  See "Common configuration options".  The
+    defaults are: 60/0.94387/0.25 (observations have a half life of 12 hours
+    and single observations will be forgotten after 24 hours).
+
+scalehalflife: See "Common configuration options".
+
+--== What traffic is recorded ==--
+
+All detectors of this type record the source IPs of the same representative
+packets from the network.  Specifically, UDP, TCP setup and teardown
+flagged packets, and ICMP packets.
+
+--== Waiting behavior ==--
+
+This describes the detector's behavior when response waiting is enabled.
+
+When response waiting is enabled, likely response packets going in the
+reverse direction with the same set of IPs and ports are monitored.  What is
+watched for depends on the scope:
+    + UDP: all UDP
+    + TCP synonly: SYN-ACKs and RSTs
+    + TCP setup: SYN-ACKs, established, and teardown flagged packets
+    + TCP synack and established: established and teardown flagged packets
+    + TCP teardown: teardown flagged packets
+    + ICMP: same type of ICMP as is being monitored for
+In addition, ICMP unreachable messages with a matching protocol are
+monitored.
+
+If we see a response to a report in the waiting queue, we take that to
+indicate that the IP address is live and thus the waiting report is dropped.
+If there is no response observed withing the waiting time, the report will
+be sent.
+
+--== Notes ==--
+
+The detector type will not work well on asymmetric networks, where it
+cannot see both the inbound and outbound traffic to your homenet.  This is
+because we'd either not be seeing the responses or not seeing traffic being
+monitored.
+
+You might find that some hosts have an obsession with the dead (dead IP
+addresses, that is).  They'll keep retrying to connect.  Each one will
+produce a report if the destination never replies.  Each one is a legitimate
+report, but diminishing returns kicks in at some point.
+
+You might also see alot of ongoing probes from Nimda, CodeRed and the like.
+
+If, when Spade starts up for the first time, a server is temporarily down,
+Spade will produce reports about the access attempts because it has never
+seen a reply.
+
+TCP SYN-ACK and RST and ICMP unreachable:  See the note in dead-dest about
+backscatter, it applies to this detector type as well.
+
+Packets that bear TCP established flags might well be the majority of your
+network traffic.  If you are concerned about Spade performance, keep in mind
+that Spade must look at all traffic in the scope of your detection and all
+possible responses to this traffic.  So you might want to drop response
+waiting for those scopes whose watched-for responses include established
+flag packets.  Then again, Spade was designed to be pretty efficient when
+handling possible responses, so it might not matter much.
+
+
+---=== The odd-dport detector type ===---
+
+The idea behind this detector type is the observation that a given host has
+a set of applications that it normally uses to access the network.  So, if
+we observe it using a different application, that might well be suspicious. 
+Perhaps the host has been compromised or someone is misusing it.
+
+In Spade detectors based on this detector type, we map the above notion of a
+host to an IP address and map the notion of an applications network use to
+the destination port number on a packet it sends.  (Both approximations have
+some rough spots that we hope to address in the future.)
+
+This detector type can be applied to local or remote sources and to TCP's
+connection-initiating packets (i.e., SYNs) or UDP.  Naturally, this is most
+reliably applied to local sources since you'd expect to have the best
+information about their behavior.
+
+Anomaly reports from a detector with this detector type contain the activity
+description "Source used odd dest port".  The scores reported are always
+relative and relate to the source IP.
+
+--== Options ==--
+
+from,id:  See "Common configuration options".
+
+protocol:  See "Common configuration options".  "tcp" and "udp" are available.
+
+thresh:  The (initial) reporting threshold.  The default is 0.8.
+
+minobs:  This is the minimum number an observations about an IP address
+    before we produce any reports regarding it.  The default is 600.
+
+wait:  This is how long to wait for a response packet.  The default is 0.
+
+Advanced options:
+
+scalefreq/scalefactor/scalecutoff:  See "Common configuration options".  The
+    defaults are: 240/0.98363/0.18 (observations have a half life of one
+    week and single observations will be forgotten after about 17.3 days).
+
+scalehalflife: See "Common configuration options".
+
+--== What traffic is recorded ==--
+
+For detectors applied to TCP, SYN-only packets have observations recorded
+about them.  For detectors applied to UDP, all UDP packets are recorded.
+
+--== Waiting behavior ==--
+
+This describes the detectors behavior when response waiting is enabled. 
+Note that while this option is made available to help narrow the reports to
+those going to closed ports, closed port usage detection was not the main
+point of this detector type.  This would essentially limit detection to
+portscanning.
+
+When response waiting is enabled on TCP packets, any SYN-ACK packet going in
+the reverse direction with the same set of IPs and ports is considered to
+indicate that the port is open and the waiting report is dropped.  If there
+is no response observed within the waiting time, the report will be sent.
+
+UDP on the other hand, looks for a negative response (when response waiting
+is enabled).  If there is an ICMP unreachable message containing a packet
+matching the original (in terms of protocol, IPs, and ports), then a report
+is sent.  If the report times out, the report is dropped.
+
+--== Notes ==--
+
+TCP: Unless you enable response waiting, you will see passive FTP traffic. 
+This is an example of the imperfect match between application network use
+and dest port number use.
+
+UDP: There is no way to distinguish a UDP session beginning at a packet
+level, so you'll get some (perhaps many) reports on responses to some
+previous communication to a server.  Enabling waiting may help.
+
+The match between host and IP address is not perfect, especially in the case
+of DHCP.  So, the new host assigned an IP address would inherit the profile
+of the previous users of that IP address (if any).  So, you may get some
+false reports until the profile is updated enough.  This may not be that bad
+because the set of hosts in a DHCP pool may have similar network profiles.
+
+Sometimes applications use a range of destination port numbers (e.g.,
+RealPlayer).  Ideally these would be considered together.  But, presently
+each destination port number will have to be learned separately.
+
+If a destination port is only infrequently used by a host relative to the
+amount of traffic from that host, the minimum observation may be met before
+any traffic to a given port number.  So, the first few packets will be
+reported.  The detector adapts pretty quickly to new ports.  A side effect
+of this is that if a host is beginning a scan, you will only see the first
+few packets.
+
+
+---=== The odd-port-dest detector type ===---
+
+As used by a particular source IP, certain destination port numbers have the
+property that the source connects to only a small number (perhaps 1) of
+destination IPs using it.  This is especially true of client hosts which
+often use configured servers for DNS, POP, SMTP, and the like.  The
+observation behind the odd-port-dest detector type is that if we see a
+connection to an unusual destination in a case like this (where the
+destination is fairly predictable), that might be suspicious.  Perhaps the
+host has been compromised or someone is misusing it.
+
+Spade detectors based on this type observe the traffic on the network and
+automatically determines which set of destination port numbers are
+predictable for an IP.  (This set is continually maintained, with the
+decision about whether a particular port should be in that set or not
+rechecked on occasion.)  If some traffic within the detector's scope is
+observed going to a port number that is in the source IP's set, then the
+destination IP is checked.  If that destination IP is anomalous, it is
+reported.
+
+This detector type can be applied to local or remote sources and to TCP's
+connection-initiating packets (i.e., SYNs) or UDP.  Naturally, this is most
+reliably applied to local sources since you'd expect to have the best
+information about their behavior.
+
+Anomaly reports from a detector of this type contain the activity
+description "Source used odd dest for port".  The scores reported are always
+relative and relate to a given source IP and destination port.
+
+--== Options ==--
+
+from,id:  See "Common configuration options".
+
+protocol:  See "Common configuration options".  "tcp" and "udp" are available.
+
+thresh:  The (initial) reporting threshold.  The default is 0.9.
+
+maxentropy:  The highest entropy observed that may be observed by an port
+    (for a source) that is considered predictable and in the set of watched
+    destination ports.  (Entropy is a measure of how much variation
+    (randomness) is found in a set of observations.  0 entropy means that
+    there is only one observed value.  A high number indicates there was
+    alot of variation.  Entropy is measured on a log 2 based scale.)  The
+    default is 2.5.  You can lower it to increase the confidence of reports
+    (but you will not keep as many ports under observation).
+
+minobs:  This is the minimum number an observations about destination port
+    for a source IP we need to have before making any reports regarding it.
+    This is important because if there are too few observations about a
+    port, the entropy will necessarily be low and a port may not have
+    demonstrated its full variance, so you may get reports about an port
+    that will eventually be considered not predictable enough.  The default
+    is 100 times 2 to the power of the maxentropy setting (566 with the
+    default maxentropy) for TCP and double this for UDP.
+
+wait:  This is how long to wait for a response packet.  The default is 0.
+
+Advanced options:
+
+scalefreq/scalefactor/scalecutoff:  See "Common configuration options".  The
+    defaults are: 90/0.97957/0.35 (observations have a half life of 2 days
+    and single observations will be forgotten after about 3 days).
+
+scalehalflife: See "Common configuration options".
+
+--== What traffic is recorded ==--
+
+For detectors applied to TCP, SYN-only packets have observations recorded
+about them.  For detectors applied to UDP, all UDP packets are recorded.
+
+--== Waiting behavior ==--
+
+This describes the detectors behavior when response waiting is enabled. 
+Note that while this option is made available to help narrow the reports to
+those going to closed ports, closed port usage detection was not the main
+point of this detector type.  This would essentially limit detection to
+portscanning.
+
+The waiting behavior for odd-port-dest is identical to that of odd-dport above.
+
+--== Notes ==--
+
+This detector type is a little slower than the other types mainly due to
+needing to calculate the entropy periodically.  It also has significantly
+higher memory use due to the 3-dimensional table of observations that needs
+to be maintained.
+
+Sometimes a destination port will take quite a few observed packets before
+it demonstrates that the destination IP address is difficult to predict in
+general.  This is especially true for UDP (in which every packet is
+considered an observation) and for cases where there are many observations
+in a session (such as with RealPlayer).  You will get a couple reports about
+each new destination between minobs and when enough entropy is demonstrated.
+
+If minobs is too high, you may never have enough observations at a time
+about a particular destination port number of interest to cause it to join
+the watched set of ports.
+
+The match between host and IP address is not perfect, especially in the case
+of DHCP.  So, the new host assigned an IP address would inherit the profile
+of the previous users of that IP address (if any).  So, you may get some
+false reports until the profile is updated enough.  This may not be that bad
+because the set of hosts in a DHCP pool may have the same or similar server
+use.
+
+
+---=== The odd-typecode detector type ===---
+
+This detector type will report on any ICMP packets on your network bearing
+unusual type and code fields.  For example, if your network normally never
+gets any network redirect messages, one would be reported if it occurred. 
+Even a report about this type of activity is not security related, it is
+probably interesting.
+
+This detector type can be applied to traffic heading to your homenet and/or
+traffic not to your homenet and to different types of ICMP.
+
+Anomaly reports from a detector with this detector type contain the activity
+description "Odd ICMP type/code found".  The scores reported are always
+relative and relate to the whole class of traffic indicated by the scope.
+
+--== Options ==--
+
+to,id:  See "Common configuration options".
+
+icmptype:  See "Common configuration options".  any is the default.
+
+thresh:  The (initial) reporting threshold.  The default is 0.9.
+
+minobs:  This is the minimum number an observations about the network needed
+    before we produce any reports regarding it.  The default is 2000 unless
+    icmptype is "any" in which it is 4000.
+
+wait:  This is how long to wait for a response packet.  The default is 0.
+
+Advanced options:
+
+scalefreq/scalefactor/scalecutoff:  See "Common configuration options".  The
+    defaults are: 240/0.96409/0.18 (observations have a half life of 3 days
+    and single observations will be forgotten after a week).
+
+scalehalflife: See "Common configuration options".
+
+--== What traffic is recorded ==--
+
+The same packets that are evaluated are also recorded.
+
+--== Waiting behavior ==--
+
+This describes the detectors behavior when response waiting is enabled. Note
+that while this option is made available to help cut down on reports, you
+probably won't want or need this.
+
+When response waiting is enabled, any ICMP non-error packet going in the
+reverse direction with the same pair of IPs is considered to indicate that
+the initial ICMP traffic was desired and the waiting report is dropped.  If
+there is no response observed within the waiting time, the report will be
+sent.
+
+--== Notes ==--
+
+When detectors based on this type are starting up, you are more likely to
+receive reports about less interesting activity.  As time goes along, the
+reports from this should be more interesting.
+
+
+----==== Finding a good threshold ====----
+
+There are 4 facilities for helping you find and maintain an appropriate
+reporting threshold for your detector, so that you do not get flooded with
+alerts about normal packets by having too low of a threshold and so that you
+do not miss packets of interest by having too high a threshold.  One is
+threshold learning and the other three are different means of automatically
+adapting the threshold to meet observed conditions.
+
+We expect these facilities to be less needed when using relative anomaly
+scores (which is the default now) since we think it will be less hard to
+guess at a decent fixed threshold.  So, you can either use one of the 4
+facilities described in the next two subsections or do it yourself by trying
+out different threshold values.
+
+The premise for these is that you want to aim for a certain rate of alerts,
+a rate just high enough to catch interesting events.  Each of these
+facilities observes the network for a certain interval of time, keeping
+record of the anomaly scores for the packets observed.  Based on this, an
+"ideal" threshold can be derived that would have produced exactly the number
+of alerts wanted. At least, during that time interval.  We have observed
+that this is a pretty noisy process and this will vary from interval to
+interval.
+
+Note that regardless of the way your threshold is set, your rate of alerts
+will not be steady.  This is since the rate of anomalous events is not
+steady. For example, if someone runs a noisy Nmap across your network, you
+will get more alerts than normal (unless, of course, this is normal).  So,
+for whatever target rate you aim for, consider that to be your target for
+most of the time intervals.
+
+Each of these facilities requires you to refer to the specific detector
+which you are trying find a threshold for.  In order to do that, you must
+set the "id" option on the detector to a unique value.  Moreover, the line
+establishing the detector must appear earlier in Snort configuration file
+than these facilities.
+
+---=== Threshold adapting ===---
+
+There are three modes of adapting.  None of these are on by default, but if
+one were, then method #3 would be the default since we think it should work
+the best.  Your network may disagree though :).
+
+Method #1 is the simplest approach.  It periodically takes a weighted
+average of the current threshold and the recently observed ideal.  You
+activate this by adding a line of this form to the Snort configuration file:
+
+    preprocessor spade-adapt:  {<optionname>=<value>}
+    
+where <optionname> is "id", "target", "obsper", "newweight", or "bycount".
+
+The required "id" field refers to the id of the detector whose threshold you
+are adapting.
+
+The target packet count is given by the "target" argument (default 20). The
+length of time (in hours) during which that count is aimed for and the
+refresh rate for the threshold is given by "obsper" (default 2). 
+"newweight" is the weight given to the new component of the weighted average
+(default 0.5). Higher values (up to 1.0) give more weight to recent
+observations.
+
+An option with method #1 is to measure the adapt period by packet count
+rather than by time.  That is, the adapt time specification is converted
+into a count of packets, based on the current best estimate of a rate of
+packets.  The advantage here is that observed ideal values between periods
+is more likely to be similar since about the same number of packets were
+considered for each, so the transitions will be steadier.  This is on by
+default.  To disable, set the "bycount" argument to 0 (rather than 1).
+
+Method #2 is more involved.  A new threshold is based the average of short,
+medium and long term components.  This is the line to add to the
+configuration file:
+
+    preprocessor spade-adapt2: {<optionname>=<value>}
+    
+where <optionname> is "id", "target", "obsper", "NS", "NM", or "NL".
+
+The required "id" field refers to the id of the detector whose threshold you
+are adapting.
+
+"target" is the specification of the number of alerts wanted.  If it is >=
+1, it is an hourly alert rate.  If it is < 1, then it is a fraction of
+considered packets to report, based on the best estimate of your packet
+rate. The later form of specification might be preferred if your network
+might experience a shift in packet rates.  The default is 0.01 (1%).
+
+"obsper" is the number of minutes in an observation window (default 15). The
+is the frequency with which the reporting threshold is updated and is
+actually converted to a packet count.  "NS" times "obsper" is how long the
+short term is.  The default for "NS" is 4, so the combined default is 1
+hour. "NM" is the number of short term periods in the medium term (default
+24) and "NL" is the number of medium term periods in the long term (default
+7).
+
+For a more complete description of how this mode works, see the comments in
+the source code.
+
+Method #3 is fairly simple.  The reporting threshold is based on an average
+of the ideal threshold values from the last N observation periods.  (If
+there haven't been N observation periods yet, it just takes the average of
+the ones seen so far).  This mode is invoked with a line of the form:
+
+    preprocessor spade-adapt3: {<optionname>=<value>}
+    
+where <optionname> is "id", "target", "obsper", or "numper".
+
+The required "id" field refers to the id of the detector whose threshold you
+are adapting.
+
+"target" is the specification of the target alert rate and takes the same
+form as that in method #2 (default 0.01).  "obsper" is the number of minutes
+in a period of observation (default 60); this is converted to count of
+packets.  "numper" is the number of observations to average over (default
+168, which is the number of hours in a week).
+
+You may have multiple adaptings engaged at the same time, but each must
+apply to different detectors.
+
+
+---=== Threshold advising (formerly known as threshold learning) ===---
+
+To start up threshold advising mode when Snort starts up, provide a line of
+this form in the Snort configuration file:
+
+    preprocessor spade-threshadvise: {<optionname>=<value>}
+    
+where <optionname> is "id", "target", or "obsper".
+
+The required "id" field refers to the id of the detector that you are
+enabling advising regarding.  This mode is enabled for "obsper" hours
+(default 24), after which it reports on the threshold that would have been
+needed to produce "target" scores (default 200) during that time.  At the
+end of the time period, a report about this is generated to the log file
+specified on the main Spade configuration line.  An (perhaps intermediate)
+report is also produced on every SIGHUP, SIGINT, SIGQUIT, and SIGUSR1 and on
+Snort exit.
+
+You may have multiple advisings engaged at the same time, but each must
+apply to different detectors.
+
+
+----==== Survey mode ====----
+
+Survey mode periodically reports information about the anomaly scores
+produced by a detector in the last time interval.  It is activated with the
+following line:
+
+    preprocessor spade-survey: {<optionname>=<value>}
+
+where <optionname> is "id", "surveyfile" or "interval".
+
+The required "id" field refers to the id of the detector (this must be set)
+that you are surveying.  "surveyfile" is the file to write the output to
+(default is standard output) and "interval" is the frequency of the
+observation period, in minutes (default 60).  This mode is active for as
+long as Snort is running.
+
+The file produced is in a table form suitable for importing into
+spreadsheets and databases.  A line of column headers is on the first line
+and the following are tab-separated on the following lines:
+
+    + interval #
+    + number of accepted packets in the interval
+    + median (50th percentile) anomaly score in the interval
+    + 90th percentile anomaly score
+    + 99th percentile anomaly score
+
+Linear interpolation is used for the percentile results if there is no exact
+score in the indicated position.
+
+Note that at present a O(n*n) algorithm is used for storing the anomaly
+scores, so that when number of accepted packets in the interval becomes
+large, this mode runs slowly.  If this mode becomes used seriously, we
+should use an order statistics tree or some other O(n*log(n)) algorithm.
+
+
+----==== Statistics mode ====----
+
+When the statistics mode is activated certain information about the network
+traffic is reported.  This makes use of the any already available
+probabilities from the calculation of the anomaly scores for different
+detectors.  It is enabled with the following line in the configuration file:
+
+    preprocessor spade-stats: <stat-option> <stat-option> ...
+
+where <stat-option> is one of:
+
+    + "entropy" (to display the known entropies and conditional entropies)
+    + "uncondprob" (to display the known non-0 simple (joint) probabilities)
+    + "condprob" (to display the known non-0 conditional (joint)
+    probabilities)
+
+These are written to the log file on SIGHUP, SIGINT, SIGQUIT, and SIGUSR1
+and on Snort exit.  Be aware that it might take a while to write the
+"uncondprob" and "condprob" results as there is generally alot of those.  In
+the present implementation, writing out the "entropy" can take an excessive
+amount of memory.
+
+
+
+----==== Source code parameters ====----
+
+There are a few tunable parameters that you will need to change some numbers
+in the source code in order to adjust.  Fortunately most people probably
+won't want to change these anyway.
+
+A set of parameters are used to control how much memory can be used in
+maintaining the probability state.  A description of exactly what these do
+requires a discussion beyond the scope of this document.  For now, if you
+get a message of the form "exhausted all X blocks of Y <whatever>", try
+increasing the corresponding DEFAULT_MAX_*_SIZE parameter in
+spp_spade.h/params.h.
diff -rNu snort-2.7.0/etc/snort.conf snort-2.7.0.mod/etc/snort.conf
--- snort-2.7.0/etc/snort.conf	2007-07-18 22:16:39.000000000 +0200
+++ snort-2.7.0.mod/etc/snort.conf	2007-09-06 20:15:11.000000000 +0200
@@ -224,6 +224,17 @@
 # the form
 # preprocessor <name_of_processor>: <configuration_options>
 
+# spade: Statistical Packet Anomaly Detection Engine
+# --------------------------------------------------
+# This preprocessor looks over your network and reports on packets that stand
+# out from the others.  For example, they are heading to an unused IP address
+# or are going to a port that is rarely used.  This can be a sign of scanning
+# or some other bad activity.
+ 
+# see spade.conf for more details and to configure Spade
+include spade.ossim.conf
+
+
 # Configure Flow tracking module
 # -------------------------------
 #
diff -rNu snort-2.7.0/etc/snort.conf.orig snort-2.7.0.mod/etc/snort.conf.orig
--- snort-2.7.0/etc/snort.conf.orig	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/etc/snort.conf.orig	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,1011 @@
+#--------------------------------------------------
+#   http://www.snort.org     Snort 2.6.1.3 Ruleset
+#     Contact: snort-sigs@lists.sourceforge.net
+#--------------------------------------------------
+# $Id: snort-spade-2.7.0.diff,v 1.3 2007/11/05 11:12:39 dvgil Exp $
+#
+###################################################
+# This file contains a sample snort configuration. 
+# You can take the following steps to create your own custom configuration:
+#
+#  1) Set the variables for your network
+#  2) Configure dynamic loaded libraries
+#  3) Configure preprocessors
+#  4) Configure output plugins
+#  5) Add any runtime config directives
+#  6) Customize your rule set
+#
+###################################################
+# Step #1: Set the network variables:
+#
+# You must change the following variables to reflect your local network. The
+# variable is currently setup for an RFC 1918 address space.
+#
+# You can specify it explicitly as: 
+#
+# var HOME_NET 10.1.1.0/24
+#
+# or use global variable $<interfacename>_ADDRESS which will be always
+# initialized to IP address and netmask of the network interface which you run
+# snort at.  Under Windows, this must be specified as
+# $(<interfacename>_ADDRESS), such as:
+# $(\Device\Packet_{12345678-90AB-CDEF-1234567890AB}_ADDRESS)
+#
+# var HOME_NET $eth0_ADDRESS
+#
+# You can specify lists of IP addresses for HOME_NET
+# by separating the IPs with commas like this:
+#
+# var HOME_NET [10.1.1.0/24,192.168.1.0/24]
+#
+# MAKE SURE YOU DON'T PLACE ANY SPACES IN YOUR LIST!
+#
+# or you can specify the variable to be any IP address
+# like this:
+
+var HOME_NET any
+
+# Set up the external network addresses as well.  A good start may be "any"
+var EXTERNAL_NET any
+
+# Configure your server lists.  This allows snort to only look for attacks to
+# systems that have a service up.  Why look for HTTP attacks if you are not
+# running a web server?  This allows quick filtering based on IP addresses
+# These configurations MUST follow the same configuration scheme as defined
+# above for $HOME_NET.  
+
+# List of DNS servers on your network 
+var DNS_SERVERS $HOME_NET
+
+# List of SMTP servers on your network
+var SMTP_SERVERS $HOME_NET
+
+# List of web servers on your network
+var HTTP_SERVERS $HOME_NET
+
+# List of sql servers on your network 
+var SQL_SERVERS $HOME_NET
+
+# List of telnet servers on your network
+var TELNET_SERVERS $HOME_NET
+
+# List of snmp servers on your network
+var SNMP_SERVERS $HOME_NET
+
+# Configure your service ports.  This allows snort to look for attacks destined
+# to a specific application only on the ports that application runs on.  For
+# example, if you run a web server on port 8081, set your HTTP_PORTS variable
+# like this:
+#
+# var HTTP_PORTS 8081
+#
+# Port lists must either be continuous [eg 80:8080], or a single port [eg 80].
+# We will adding support for a real list of ports in the future.
+
+# Ports you run web servers on
+#
+# Please note:  [80,8080] does not work.
+# If you wish to define multiple HTTP ports, use the following convention
+# when customizing your rule set (as part of Step #6 below).  This should
+# not be done here, as the rules files may depend on the classifications
+# and/or references, which are included below.
+# 
+## var HTTP_PORTS 80 
+## include somefile.rules 
+## var HTTP_PORTS 8080
+## include somefile.rules 
+var HTTP_PORTS 80
+
+# Ports you want to look for SHELLCODE on.
+var SHELLCODE_PORTS !80
+
+# Ports you do oracle attacks on
+var ORACLE_PORTS 1521
+
+# other variables
+# 
+# AIM servers.  AOL has a habit of adding new AIM servers, so instead of
+# modifying the signatures when they do, we add them to this list of servers.
+var AIM_SERVERS [64.12.24.0/23,64.12.28.0/23,64.12.161.0/24,64.12.163.0/24,64.12.200.0/24,205.188.3.0/24,205.188.5.0/24,205.188.7.0/24,205.188.9.0/24,205.188.153.0/24,205.188.179.0/24,205.188.248.0/24]
+
+# Path to your rules files (this can be a relative path)
+# Note for Windows users:  You are advised to make this an absolute path,
+# such as:  c:\snort\rules
+var RULE_PATH ../rules
+
+# Configure the snort decoder
+# ============================
+#
+# Snort's decoder will alert on lots of things such as header
+# truncation or options of unusual length or infrequently used tcp options
+#
+#
+# Stop generic decode events:
+#
+# config disable_decode_alerts
+#
+# Stop Alerts on experimental TCP options
+#
+# config disable_tcpopt_experimental_alerts
+#
+# Stop Alerts on obsolete TCP options
+#
+# config disable_tcpopt_obsolete_alerts
+#
+# Stop Alerts on T/TCP alerts
+#
+# In snort 2.0.1 and above, this only alerts when a TCP option is detected
+# that shows T/TCP being actively used on the network.  If this is normal
+# behavior for your network, disable the next option.
+#
+# config disable_tcpopt_ttcp_alerts
+#
+# Stop Alerts on all other TCPOption type events:
+#
+# config disable_tcpopt_alerts
+#
+# Stop Alerts on invalid ip options
+#
+# config disable_ipopt_alerts
+#
+# Alert if value in length field (IP, TCP, UDP) is greater than the
+# actual length of the captured portion of the packet that the length
+# is supposed to represent:
+#
+# config enable_decode_oversized_alerts
+#
+# Same as above, but drop packet if in Inline mode -
+# enable_decode_oversized_alerts must be enabled for this to work:
+#
+# config enable_decode_oversized_drops
+#
+
+# Configure the detection engine
+# ===============================
+#
+# Use a different pattern matcher in case you have a machine with very limited
+# resources:
+#
+# config detection: search-method lowmem
+
+# Configure Inline Resets
+# ========================
+# 
+# If running an iptables firewall with snort in InlineMode() we can now
+# perform resets via a physical device. We grab the indev from iptables
+# and use this for the interface on which to send resets. This config
+# option takes an argument for the src mac address you want to use in the
+# reset packet.  This way the bridge can remain stealthy. If the src mac
+# option is not set we use the mac address of the indev device. If we
+# don't set this option we will default to sending resets via raw socket,
+# which needs an ipaddress to be assigned to the int.
+#
+# config layer2resets: 00:06:76:DD:5F:E3
+
+###################################################
+# Step #2: Configure dynamic loaded libraries
+#
+# If snort was configured to use dynamically loaded libraries,
+# those libraries can be loaded here.
+#
+# Each of the following configuration options can be done via
+# the command line as well.
+#
+# Load all dynamic preprocessors from the install path
+# (same as command line option --dynamic-preprocessor-lib-dir)
+#
+dynamicpreprocessor directory /usr/local/lib/snort_dynamicpreprocessor/
+#
+# Load a specific dynamic preprocessor library from the install path
+# (same as command line option --dynamic-preprocessor-lib)
+#
+# dynamicpreprocessor file /usr/local/lib/snort_dynamicpreprocessor/libdynamicexample.so
+#
+# Load a dynamic engine from the install path
+# (same as command line option --dynamic-engine-lib)
+#
+dynamicengine /usr/local/lib/snort_dynamicengine/libsf_engine.so
+#
+# Load all dynamic rules libraries from the install path
+# (same as command line option --dynamic-detection-lib-dir)
+#
+# dynamicdetection directory /usr/local/lib/snort_dynamicrule/
+#
+# Load a specific dynamic rule library from the install path
+# (same as command line option --dynamic-detection-lib)
+#
+# dynamicdetection file /usr/local/lib/snort_dynamicrule/libdynamicexamplerule.so
+#
+
+###################################################
+# Step #3: Configure preprocessors
+#
+# General configuration for preprocessors is of 
+# the form
+# preprocessor <name_of_processor>: <configuration_options>
+
+# Configure Flow tracking module
+# -------------------------------
+#
+# The Flow tracking module is meant to start unifying the state keeping
+# mechanisms of snort into a single place. Right now, only a portscan detector
+# is implemented but in the long term,  many of the stateful subsystems of
+# snort will be migrated over to becoming flow plugins. This must be enabled
+# for flow-portscan to work correctly.
+#
+# See README.flow for additional information
+#
+preprocessor flow: stats_interval 0 hash 2
+
+# frag2: IP defragmentation support
+# -------------------------------
+# This preprocessor performs IP defragmentation.  This plugin will also detect
+# people launching fragmentation attacks (usually DoS) against hosts.  No
+# arguments loads the default configuration of the preprocessor, which is a 60
+# second timeout and a 4MB fragment buffer. 
+
+# The following (comma delimited) options are available for frag2
+#    timeout [seconds] - sets the number of [seconds] that an unfinished 
+#                        fragment will be kept around waiting for completion,
+#                        if this time expires the fragment will be flushed
+#    memcap [bytes] - limit frag2 memory usage to [number] bytes
+#                      (default:  4194304)
+#
+#    min_ttl [number] - minimum ttl to accept
+# 
+#    ttl_limit [number] - difference of ttl to accept without alerting
+#                         will cause false positves with router flap
+# 
+# Frag2 uses Generator ID 113 and uses the following SIDS 
+# for that GID:
+#  SID     Event description
+# -----   -------------------
+#   1       Oversized fragment (reassembled frag > 64k bytes)
+#   2       Teardrop-type attack
+
+#preprocessor frag2
+
+# frag3: Target-based IP defragmentation 
+# --------------------------------------
+#
+# Frag3 is a brand new IP defragmentation preprocessor that is capable of
+# performing "target-based" processing of IP fragments.  Check out the
+# README.frag3 file in the doc directory for more background and configuration
+# information.
+# 
+# Frag3 configuration is a two step process, a global initialization phase 
+# followed by the definition of a set of defragmentation engines.  
+# 
+# Global configuration defines the number of fragmented packets that Snort can
+# track at the same time and gives you options regarding the memory cap for the
+# subsystem or, optionally, allows you to preallocate all the memory for the 
+# entire frag3 system.
+#
+# frag3_global options:
+#   max_frags: Maximum number of frag trackers that may be active at once.  
+#              Default value is 8192.
+#   memcap: Maximum amount of memory that frag3 may access at any given time.
+#           Default value is 4MB.
+#   prealloc_frags: Maximum number of individual fragments that may be processed
+#                   at once.  This is instead of the memcap system, uses static 
+#                   allocation to increase performance.  No default value.  Each
+#                   preallocated fragment eats ~1550 bytes.
+#
+# Target-based behavior is attached to an engine as a "policy" for handling 
+# overlaps and retransmissions as enumerated in the Paxson paper.  There are
+# currently five policy types available: "BSD", "BSD-right", "First", "Linux" 
+# and "Last".  Engines can be bound to bound to standard Snort CIDR blocks or
+# IP lists.
+#
+# frag3_engine options:
+#   timeout: Amount of time a fragmented packet may be active before expiring.
+#            Default value is 60 seconds.
+#   ttl_limit: Limit of delta allowable for TTLs of packets in the fragments. 
+#              Based on the initial received fragment TTL.
+#   min_ttl: Minimum acceptable TTL for a fragment, frags with TTLs below this
+#            value will be discarded.  Default value is 0.
+#   detect_anomalies: Activates frag3's anomaly detection mechanisms.
+#   policy: Target-based policy to assign to this engine.  Default is BSD.
+#   bind_to: IP address set to bind this engine to.  Default is all hosts.
+#
+# Frag3 configuration example:
+#preprocessor frag3_global: max_frags 65536 prealloc_frags 262144
+#preprocessor frag3_engine: policy linux \
+#                           bind_to [10.1.1.12/32,10.1.1.13/32] \
+#                           detect_anomalies
+#preprocessor frag3_engine: policy first \
+#                           bind_to 10.2.1.0/24 \
+#                           detect_anomalies
+#preprocessor frag3_engine: policy last \
+#                           bind_to 10.3.1.0/24
+#preprocessor frag3_engine: policy bsd
+
+preprocessor frag3_global: max_frags 65536
+preprocessor frag3_engine: policy first detect_anomalies
+
+
+# stream4: stateful inspection/stream reassembly for Snort
+#----------------------------------------------------------------------
+# Use in concert with the -z [all|est] command line switch to defeat stick/snot
+# against TCP rules.  Also performs full TCP stream reassembly, stateful
+# inspection of TCP streams, etc.  Can statefully detect various portscan
+# types, fingerprinting, ECN, etc.
+
+# stateful inspection directive
+# no arguments loads the defaults (timeout 30, memcap 8388608)
+# options (options are comma delimited):
+#   detect_scans - stream4 will detect stealth portscans and generate alerts
+#                  when it sees them when this option is set
+#   detect_state_problems - detect TCP state problems, this tends to be very
+#                           noisy because there are a lot of crappy ip stack
+#                           implementations out there
+#
+#   disable_evasion_alerts - turn off the possibly noisy mitigation of
+#                            overlapping sequences.
+#
+#   ttl_limit [number]     - differential of the initial ttl on a session versus
+#                             the normal that someone may be playing games.
+#                             Routing flap may cause lots of false positives.
+# 
+#   keepstats [machine|binary] - keep session statistics, add "machine" to 
+#                         get them in a flat format for machine reading, add
+#                         "binary" to get them in a unified binary output 
+#                         format
+#   noinspect - turn off stateful inspection only
+#   timeout [number] - set the session timeout counter to [number] seconds,
+#                      default is 30 seconds
+#   max_sessions [number] - limit the number of sessions stream4 keeps
+#                         track of
+#   memcap [number] - limit stream4 memory usage to [number] bytes (does
+#                     not include session tracking, which is set by the
+#                     max_sessions option)
+#   log_flushed_streams - if an event is detected on a stream this option will
+#                         cause all packets that are stored in the stream4
+#                         packet buffers to be flushed to disk.  This only 
+#                         works when logging in pcap mode!
+#   server_inspect_limit [bytes] - Byte limit on server side inspection.
+#   enable_udp_sessions - turn on tracking of "sessions" over UDP.  Requires
+#                         configure --enable-stream4udp.  UDP sessions are
+#                         only created when there is a rule for the sender or
+#                         responder that has a flow or flowbits keyword.
+#   max_udp_sessions [number] - limit the number of simultaneous UDP sessions
+#                               to track
+#   udp_ignore_any - Do not inspect UDP packets unless there is a port specific
+#                    rule for a given port.  This is a performance improvement
+#                    and turns off inspection for udp xxx any -> xxx any rules
+#   cache_clean_sessions [number] - Cleanup the session cache by number sessions
+#                                   at a time.  The larger the value, the
+#                                   more sessions are purged from the cache when
+#                                   the session limit or memcap is reached.
+#                                   Defaults to 5.
+#   
+#   
+#
+# Stream4 uses Generator ID 111 and uses the following SIDS 
+# for that GID:
+#  SID     Event description
+# -----   -------------------
+#   1       Stealth activity
+#   2       Evasive RST packet
+#   3       Evasive TCP packet retransmission
+#   4       TCP Window violation
+#   5       Data on SYN packet
+#   6       Stealth scan: full XMAS
+#   7       Stealth scan: SYN-ACK-PSH-URG
+#   8       Stealth scan: FIN scan
+#   9       Stealth scan: NULL scan
+#   10      Stealth scan: NMAP XMAS scan
+#   11      Stealth scan: Vecna scan
+#   12      Stealth scan: NMAP fingerprint scan stateful detect
+#   13      Stealth scan: SYN-FIN scan
+#   14      TCP forward overlap
+
+preprocessor stream4: disable_evasion_alerts
+
+# tcp stream reassembly directive
+# no arguments loads the default configuration 
+#   Only reassemble the client,
+#   Only reassemble the default list of ports (See below),  
+#   Give alerts for "bad" streams
+#
+# Available options (comma delimited):
+#   clientonly - reassemble traffic for the client side of a connection only
+#   serveronly - reassemble traffic for the server side of a connection only
+#   both - reassemble both sides of a session
+#   noalerts - turn off alerts from the stream reassembly stage of stream4
+#   ports [list] - use the space separated list of ports in [list], "all" 
+#                  will turn on reassembly for all ports, "default" will turn
+#                  on reassembly for ports 21, 23, 25, 42, 53, 80, 110,
+#                  111, 135, 136, 137, 139, 143, 445, 513, 1433, 1521,
+#                  and 3306
+#   favor_old - favor an old segment (based on sequence number) over a new one.
+#               This is the default.
+#   favor_new - favor an new segment (based on sequence number) over an old one.
+#   overlap_limit [number] - limit on overlaping segments for a session.
+#   flush_on_alert - flushes stream when an alert is generated for a session.
+#   flush_behavior [mode] -
+#           default      - use old static flushpoints (default)
+#           large_window - use new larger static flushpoints
+#           random       - use random flushpoints defined by flush_base, 
+#                          flush_seed and flush_range
+#   flush_base [number] - lowest allowed random flushpoint (512 by default)
+#   flush_range [number] - number is the space within which random flushpoints
+#                          are generated (default 1213)
+#   flush_seed [number] - seed for the random number generator, defaults to 
+#                         Snort PID + time
+#
+# Using the default random flushpoints, the smallest flushpoint is 512,
+# and the largest is 1725 bytes.
+preprocessor stream4_reassemble
+
+# stream5: Target Based stateful inspection/stream reassembly for Snort
+# ---------------------------------------------------------------------
+# EXPERIMENTAL CODE!!!
+#
+# THIS CODE IS STILL EXPERIMENTAL AND MAY OR MAY NOT BE STABLE!
+# USE AT YOUR OWN RISK!  DO NOT USE IN PRODUCTION ENVIRONMENTS.
+# YOU HAVE BEEN WARNED.
+#
+# Stream5 is a target-based stream engine for Snort.  Its functionality
+# replaces that of Stream4.  Consequently, BOTH Stream4 and Stream5
+# cannot be used simultaneously.  Comment out the stream4 configurations
+# above to use Stream5.
+# 
+# See README.stream for details on the configuration options.
+#
+# Example config (that emulates Stream4 with UDP support compiled in)
+# preprocessor stream5_global: max_tcp 8192, track_tcp yes, \
+#                              track_udp yes
+# preprocessor stream5_tcp: policy first, use_static_footprint_sizes
+# preprocessor stream5_udp: ignore_any_rules
+
+
+# Performance Statistics
+# ----------------------
+# Documentation for this is provided in the Snort Manual.  You should read it.
+# It is included in the release distribution as doc/snort_manual.pdf
+# 
+# preprocessor perfmonitor: time 300 file /var/snort/snort.stats pktcnt 10000
+
+# http_inspect: normalize and detect HTTP traffic and protocol anomalies
+#
+# lots of options available here. See doc/README.http_inspect.
+# unicode.map should be wherever your snort.conf lives, or given
+# a full path to where snort can find it.
+preprocessor http_inspect: global \
+    iis_unicode_map unicode.map 1252 
+
+preprocessor http_inspect_server: server default \
+    profile all ports { 80 8080 8180 } oversize_dir_length 500
+
+#
+#  Example unique server configuration
+#
+#preprocessor http_inspect_server: server 1.1.1.1 \
+#    ports { 80 3128 8080 } \
+#    flow_depth 0 \
+#    ascii no \
+#    double_decode yes \
+#    non_rfc_char { 0x00 } \
+#    chunk_length 500000 \
+#    non_strict \
+#    oversize_dir_length 300 \
+#    no_alerts
+
+
+# rpc_decode: normalize RPC traffic
+# ---------------------------------
+# RPC may be sent in alternate encodings besides the usual 4-byte encoding
+# that is used by default. This plugin takes the port numbers that RPC
+# services are running on as arguments - it is assumed that the given ports
+# are actually running this type of service. If not, change the ports or turn
+# it off.
+# The RPC decode preprocessor uses generator ID 106
+#
+# arguments: space separated list
+# alert_fragments - alert on any rpc fragmented TCP data
+# no_alert_multiple_requests - don't alert when >1 rpc query is in a packet
+# no_alert_large_fragments - don't alert when the fragmented
+#                            sizes exceed the current packet size
+# no_alert_incomplete - don't alert when a single segment
+#                       exceeds the current packet size
+
+preprocessor rpc_decode: 111 32771
+
+# bo: Back Orifice detector
+# -------------------------
+# Detects Back Orifice traffic on the network.
+#
+# arguments:  
+#   syntax:
+#     preprocessor bo: noalert { client | server | general | snort_attack } \
+#                      drop    { client | server | general | snort_attack }
+#   example:
+#     preprocessor bo: noalert { general server } drop { snort_attack }
+
+# 
+# The Back Orifice detector uses Generator ID 105 and uses the 
+# following SIDS for that GID:
+#  SID     Event description
+# -----   -------------------
+#   1       Back Orifice traffic detected
+#   2       Back Orifice Client Traffic Detected
+#   3       Back Orifice Server Traffic Detected
+#   4       Back Orifice Snort Buffer Attack
+
+preprocessor bo
+
+# telnet_decode: Telnet negotiation string normalizer
+# ---------------------------------------------------
+# This preprocessor "normalizes" telnet negotiation strings from telnet and ftp
+# traffic.  It works in much the same way as the http_decode preprocessor,
+# searching for traffic that breaks up the normal data stream of a protocol and
+# replacing it with a normalized representation of that traffic so that the
+# "content" pattern matching keyword can work without requiring modifications.
+# This preprocessor requires no arguments.
+#
+# DEPRECATED in favor of ftp_telnet dynamic preprocessor
+#preprocessor telnet_decode
+#
+# ftp_telnet: FTP & Telnet normalizer, protocol enforcement and buff overflow
+# ---------------------------------------------------------------------------
+# This preprocessor normalizes telnet negotiation strings from telnet and
+# ftp traffic.  It looks for traffic that breaks the normal data stream
+# of the protocol, replacing it with a normalized representation of that
+# traffic so that the "content" pattern matching keyword can work without
+# requiring modifications.
+#
+# It also performs protocol correctness checks for the FTP command channel,
+# and identifies open FTP data transfers.
+#
+# FTPTelnet has numerous options available, please read
+# README.ftptelnet for help configuring the options for the global
+# telnet, ftp server, and ftp client sections for the protocol.
+
+#####
+# Per Step #2, set the following to load the ftptelnet preprocessor
+# dynamicpreprocessor <full path to libsf_ftptelnet_preproc.so>
+# or use commandline option
+# --dynamic-preprocessor-lib <full path to libsf_ftptelnet_preproc.so>
+
+preprocessor ftp_telnet: global \
+   encrypted_traffic yes \
+   inspection_type stateful
+
+preprocessor ftp_telnet_protocol: telnet \
+   normalize \
+   ayt_attack_thresh 200
+
+# This is consistent with the FTP rules as of 18 Sept 2004.
+# CWD can have param length of 200
+# MODE has an additional mode of Z (compressed)
+# Check for string formats in USER & PASS commands
+# Check nDTM commands that set modification time on the file.
+preprocessor ftp_telnet_protocol: ftp server default \
+   def_max_param_len 100 \
+   alt_max_param_len 200 { CWD } \
+   cmd_validity MODE < char ASBCZ > \
+   cmd_validity MDTM < [ date nnnnnnnnnnnnnn[.n[n[n]]] ] string > \
+   chk_str_fmt { USER PASS RNFR RNTO SITE MKD } \
+   telnet_cmds yes \
+   data_chan
+
+preprocessor ftp_telnet_protocol: ftp client default \
+   max_resp_len 256 \
+   bounce yes \
+   telnet_cmds yes
+
+# smtp: SMTP normalizer, protocol enforcement and buffer overflow
+# ---------------------------------------------------------------------------
+# This preprocessor normalizes SMTP commands by removing extraneous spaces.
+# It looks for overly long command lines, response lines, and data header lines.
+# It can alert on invalid commands, or specific valid commands.  It can optionally
+# ignore mail data, and can ignore TLS encrypted data.
+#
+# SMTP has numerous options available, please read README.SMTP for help
+# configuring options.
+
+#####
+# Per Step #2, set the following to load the smtp preprocessor
+# dynamicpreprocessor <full path to libsf_smtp_preproc.so>
+# or use commandline option
+# --dynamic-preprocessor-lib <full path to libsf_smtp_preproc.so>
+
+preprocessor smtp: \
+  ports { 25 } \
+  inspection_type stateful \
+  normalize cmds \
+  normalize_cmds { EXPN VRFY RCPT } \
+  alt_max_command_line_len 260 { MAIL } \
+  alt_max_command_line_len 300 { RCPT } \
+  alt_max_command_line_len 500 { HELP HELO ETRN } \
+  alt_max_command_line_len 255 { EXPN VRFY }
+
+# sfPortscan
+# ----------
+# Portscan detection module.  Detects various types of portscans and
+# portsweeps.  For more information on detection philosophy, alert types,
+# and detailed portscan information, please refer to the README.sfportscan.
+#
+# -configuration options-
+#     proto { tcp udp icmp ip all }
+#       The arguments to the proto option are the types of protocol scans that
+#       the user wants to detect.  Arguments should be separated by spaces and
+#       not commas.
+#     scan_type { portscan portsweep decoy_portscan distributed_portscan all }
+#       The arguments to the scan_type option are the scan types that the
+#       user wants to detect.  Arguments should be separated by spaces and not
+#       commas.
+#     sense_level { low|medium|high }
+#       There is only one argument to this option and it is the level of
+#       sensitivity in which to detect portscans.  The 'low' sensitivity
+#       detects scans by the common method of looking for response errors, such
+#       as TCP RSTs or ICMP unreachables.  This level requires the least
+#       tuning.  The 'medium' sensitivity level detects portscans and 
+#       filtered portscans (portscans that receive no response).  This
+#       sensitivity level usually requires tuning out scan events from NATed
+#       IPs, DNS cache servers, etc.  The 'high' sensitivity level has
+#       lower thresholds for portscan detection and a longer time window than
+#       the 'medium' sensitivity level.  Requires more tuning and may be noisy
+#       on very active networks.  However, this sensitivity levels catches the
+#       most scans.
+#     memcap { positive integer }
+#       The maximum number of bytes to allocate for portscan detection.  The
+#       higher this number the more nodes that can be tracked.
+#     logfile { filename }
+#       This option specifies the file to log portscan and detailed portscan
+#       values to.  If there is not a leading /, then snort logs to the
+#       configured log directory.  Refer to README.sfportscan for details on
+#       the logged values in the logfile.
+#     watch_ip { Snort IP List }
+#     ignore_scanners { Snort IP List }
+#     ignore_scanned { Snort IP List }
+#       These options take a snort IP list as the argument.  The 'watch_ip'
+#       option specifies the IP(s) to watch for portscan.  The 
+#       'ignore_scanners' option specifies the IP(s) to ignore as scanners.
+#       Note that these hosts are still watched as scanned hosts.  The
+#       'ignore_scanners' option is used to tune alerts from very active
+#       hosts such as NAT, nessus hosts, etc.  The 'ignore_scanned' option 
+#       specifies the IP(s) to ignore as scanned hosts.  Note that these hosts
+#       are still watched as scanner hosts.  The 'ignore_scanned' option is
+#       used to tune alerts from very active hosts such as syslog servers, etc.
+#     detect_ack_scans
+#       This option will include sessions picked up in midstream by the stream
+#       module, which is necessary to detect ACK scans.  However, this can lead to
+#       false alerts, especially under heavy load with dropped packets; which is why
+#       the option is off by default.
+#
+preprocessor sfportscan: proto  { all } \
+                         memcap { 10000000 } \
+                         sense_level { low }
+
+# arpspoof
+#----------------------------------------
+# Experimental ARP detection code from Jeff Nathan, detects ARP attacks,
+# unicast ARP requests, and specific ARP mapping monitoring.  To make use of
+# this preprocessor you must specify the IP and hardware address of hosts on
+# the same layer 2 segment as you.  Specify one host IP MAC combo per line.
+# Also takes a "-unicast" option to turn on unicast ARP request detection. 
+# Arpspoof uses Generator ID 112 and uses the following SIDS for that GID:
+
+#  SID     Event description
+# -----   -------------------
+#   1       Unicast ARP request
+#   2       Etherframe ARP mismatch (src)
+#   3       Etherframe ARP mismatch (dst)
+#   4       ARP cache overwrite attack
+
+#preprocessor arpspoof
+#preprocessor arpspoof_detect_host: 192.168.40.1 f0:0f:00:f0:0f:00
+
+# ssh
+#----------------------------------------
+# EXPERIMENTAL CODE!!!
+#
+# THIS CODE IS STILL EXPERIMENTAL AND MAY OR MAY NOT BE STABLE!
+# USE AT YOUR OWN RISK!  DO NOT USE IN PRODUCTION ENVIRONMENTS.
+# YOU HAVE BEEN WARNED.
+#
+# The SSH preprocessor detects the following exploits: Gobbles, CRC 32,
+# Secure CRT, and the Protocol Mismatch exploit.
+#
+# Both Gobbles and CRC 32 attacks occur after the key exchange, and are
+# therefore encrypted.  Both attacks involve sending a large payload
+# (20kb+) to the server immediately after the authentication challenge.
+# To detect the attacks, the SSH preprocessor counts the number of bytes
+# transmitted to the server.  If those bytes exceed a pre-defined limit
+# within a pre-define number of packets, an alert is generated.  Since
+# Gobbles only effects SSHv2 and CRC 32 only effects SSHv1, the SSH
+# version string exchange is used to distinguish the attacks.
+#
+# The Secure CRT and protocol mismatch exploits are observable before
+# the key exchange.
+#
+# SSH has numerous options available, please read README.ssh for help
+# configuring options.
+
+#####
+# Per Step #2, set the following to load the ssh preprocessor
+# dynamicpreprocessor <full path to libsf_ssh_preproc.so>
+# or use commandline option
+# --dynamic-preprocessor-lib <full path to libsf_ssh_preproc.so>
+#
+#preprocessor ssh: server_ports { 22 } \
+#                  max_client_bytes 19600 \
+#                  max_encrypted_packets 20
+
+# DCE/RPC
+#----------------------------------------
+#
+# The dcerpc preprocessor detects and decodes SMB and DCE/RPC traffic.
+# It is primarily interested in DCE/RPC data, and only decodes SMB
+# to get at the DCE/RPC data carried by the SMB layer.
+# 
+# Currently, the preprocessor only handles reassembly of fragmentation
+# at both the SMB and DCE/RPC layer.  Snort rules can be evaded by
+# using both types of fragmentation; with the preprocessor enabled
+# the rules are given a buffer with a reassembled SMB or DCE/RPC
+# packet to examine.
+# 
+# At the SMB layer, only fragmentation using WriteAndX is currently
+# reassembled.  Other methods will be handled in future versions of
+# the preprocessor.
+# 
+# Autodetection of SMB is done by looking for "\xFFSMB" at the start of
+# the SMB data, as well as checking the NetBIOS header (which is always
+# present for SMB) for the type "SMB Session".
+# 
+# Autodetection of DCE/RPC is not as reliable.  Currently, two bytes are
+# checked in the packet.  Assuming that the data is a DCE/RPC header,
+# one byte is checked for DCE/RPC version (5) and another for the type
+# "DCE/RPC Request".  If both match, the preprocessor proceeds with that
+# assumption that it is looking at DCE/RPC data.  If subsequent checks
+# are nonsensical, it ends processing.
+#
+# DCERPC has numerous options available, please read README.dcerpc for help
+# configuring options.
+
+#####
+# Per Step #2, set the following to load the dcerpc preprocessor
+# dynamicpreprocessor <full path to libsf_dcerpc_preproc.so>
+# or use commandline option
+# --dynamic-preprocessor-lib <full path to libsf_dcerpc_preproc.so>
+
+preprocessor dcerpc: \
+    autodetect \
+    max_frag_size 3000 \
+    memcap 100000
+
+# DNS
+#----------------------------------------
+# The dns preprocessor (currently) decodes DNS Response traffic
+# and detects a few vulnerabilities.
+#
+# DNS has a few options available, please read README.dns for
+# help configuring options.
+
+#####
+# Per Step #2, set the following to load the dns preprocessor
+# dynamicpreprocessor <full path to libsf_dns_preproc.so>
+# or use commandline option
+# --dynamic-preprocessor-lib <full path to libsf_dns_preproc.so>
+
+preprocessor dns: \
+    ports { 53 } \
+    enable_rdata_overflow
+
+####################################################################
+# Step #4: Configure output plugins
+#
+# Uncomment and configure the output plugins you decide to use.  General
+# configuration for output plugins is of the form:
+#
+# output <name_of_plugin>: <configuration_options>
+#
+# alert_syslog: log alerts to syslog
+# ----------------------------------
+# Use one or more syslog facilities as arguments.  Win32 can also optionally
+# specify a particular hostname/port.  Under Win32, the default hostname is
+# '127.0.0.1', and the default port is 514.
+#
+# [Unix flavours should use this format...]
+# output alert_syslog: LOG_AUTH LOG_ALERT
+#
+# [Win32 can use any of these formats...]
+# output alert_syslog: LOG_AUTH LOG_ALERT
+# output alert_syslog: host=hostname, LOG_AUTH LOG_ALERT
+# output alert_syslog: host=hostname:port, LOG_AUTH LOG_ALERT
+
+# log_tcpdump: log packets in binary tcpdump format
+# -------------------------------------------------
+# The only argument is the output file name.
+#
+# output log_tcpdump: tcpdump.log
+
+# database: log to a variety of databases
+# ---------------------------------------
+# See the README.database file for more information about configuring
+# and using this plugin.
+#
+# output database: log, mysql, user=root password=test dbname=db host=localhost
+# output database: alert, postgresql, user=snort dbname=snort
+# output database: log, odbc, user=snort dbname=snort
+# output database: log, mssql, dbname=snort user=snort password=test
+# output database: log, oracle, dbname=snort user=snort password=test
+
+# unified: Snort unified binary format alerting and logging
+# -------------------------------------------------------------
+# The unified output plugin provides two new formats for logging and generating
+# alerts from Snort, the "unified" format.  The unified format is a straight
+# binary format for logging data out of Snort that is designed to be fast and
+# efficient.  Used with barnyard (the new alert/log processor), most of the
+# overhead for logging and alerting to various slow storage mechanisms such as
+# databases or the network can now be avoided.  
+#
+# Check out the spo_unified.h file for the data formats.
+#
+# Two arguments are supported.
+#    filename - base filename to write to (current time_t is appended)
+#    limit    - maximum size of spool file in MB (default: 128)
+#
+# output alert_unified: filename snort.alert, limit 128
+# output log_unified: filename snort.log, limit 128
+
+
+# prelude: log to the Prelude Hybrid IDS system
+# ---------------------------------------------
+#
+# profile = Name of the Prelude profile to use (default is snort).
+#
+# Snort priority to IDMEF severity mappings:
+# high < medium < low < info
+#
+# These are the default mapped from classification.config:
+# info   = 4
+# low    = 3
+# medium = 2
+# high   = anything below medium
+#
+# output alert_prelude
+# output alert_prelude: profile=snort-profile-name
+
+
+# You can optionally define new rule types and associate one or more output
+# plugins specifically to that type.
+#
+# This example will create a type that will log to just tcpdump.
+# ruletype suspicious
+# {
+#   type log
+#   output log_tcpdump: suspicious.log
+# }
+#
+# EXAMPLE RULE FOR SUSPICIOUS RULETYPE:
+# suspicious tcp $HOME_NET any -> $HOME_NET 6667 (msg:"Internal IRC Server";)
+#
+# This example will create a rule type that will log to syslog and a mysql
+# database:
+# ruletype redalert
+# {
+#   type alert
+#   output alert_syslog: LOG_AUTH LOG_ALERT
+#   output database: log, mysql, user=snort dbname=snort host=localhost
+# }
+#
+# EXAMPLE RULE FOR REDALERT RULETYPE:
+# redalert tcp $HOME_NET any -> $EXTERNAL_NET 31337 \
+#   (msg:"Someone is being LEET"; flags:A+;)
+
+#
+# Include classification & priority settings
+# Note for Windows users:  You are advised to make this an absolute path,
+# such as:  c:\snort\etc\classification.config
+#
+
+include classification.config
+
+#
+# Include reference systems
+# Note for Windows users:  You are advised to make this an absolute path,
+# such as:  c:\snort\etc\reference.config
+#
+
+include reference.config
+
+####################################################################
+# Step #5: Configure snort with config statements
+#
+# See the snort manual for a full set of configuration references
+#
+# config flowbits_size: 64
+#
+# New global ignore_ports config option from Andy Mullican
+#
+# config ignore_ports: <tcp|udp> <list of ports separated by whitespace>
+# config ignore_ports: tcp 21 6667:6671 1356
+# config ignore_ports: udp 1:17 53
+
+
+####################################################################
+# Step #6: Customize your rule set
+#
+# Up to date snort rules are available at http://www.snort.org
+#
+# The snort web site has documentation about how to write your own custom snort
+# rules.
+
+#=========================================
+# Include all relevant rulesets here 
+# 
+# The following rulesets are disabled by default:
+#
+#   web-attacks, backdoor, shellcode, policy, porn, info, icmp-info, virus,
+#   chat, multimedia, and p2p
+#            
+# These rules are either site policy specific or require tuning in order to not
+# generate false positive alerts in most enviornments.
+# 
+# Please read the specific include file for more information and
+# README.alert_order for how rule ordering affects how alerts are triggered.
+#=========================================
+
+include $RULE_PATH/local.rules
+include $RULE_PATH/bad-traffic.rules
+include $RULE_PATH/exploit.rules
+include $RULE_PATH/scan.rules
+include $RULE_PATH/finger.rules
+include $RULE_PATH/ftp.rules
+include $RULE_PATH/telnet.rules
+include $RULE_PATH/rpc.rules
+include $RULE_PATH/rservices.rules
+include $RULE_PATH/dos.rules
+include $RULE_PATH/ddos.rules
+include $RULE_PATH/dns.rules
+include $RULE_PATH/tftp.rules
+
+include $RULE_PATH/web-cgi.rules
+include $RULE_PATH/web-coldfusion.rules
+include $RULE_PATH/web-iis.rules
+include $RULE_PATH/web-frontpage.rules
+include $RULE_PATH/web-misc.rules
+include $RULE_PATH/web-client.rules
+include $RULE_PATH/web-php.rules
+
+include $RULE_PATH/sql.rules
+include $RULE_PATH/x11.rules
+include $RULE_PATH/icmp.rules
+include $RULE_PATH/netbios.rules
+include $RULE_PATH/misc.rules
+include $RULE_PATH/attack-responses.rules
+include $RULE_PATH/oracle.rules
+include $RULE_PATH/mysql.rules
+include $RULE_PATH/snmp.rules
+
+include $RULE_PATH/smtp.rules
+include $RULE_PATH/imap.rules
+include $RULE_PATH/pop2.rules
+include $RULE_PATH/pop3.rules
+
+include $RULE_PATH/nntp.rules
+include $RULE_PATH/other-ids.rules
+# include $RULE_PATH/web-attacks.rules
+# include $RULE_PATH/backdoor.rules
+# include $RULE_PATH/shellcode.rules
+# include $RULE_PATH/policy.rules
+# include $RULE_PATH/porn.rules
+# include $RULE_PATH/info.rules
+# include $RULE_PATH/icmp-info.rules
+# include $RULE_PATH/virus.rules
+# include $RULE_PATH/chat.rules
+# include $RULE_PATH/multimedia.rules
+# include $RULE_PATH/p2p.rules
+# include $RULE_PATH/spyware-put.rules
+include $RULE_PATH/experimental.rules
+
+# Include any thresholding or suppression commands. See threshold.conf in the
+# <snort src>/etc directory for details. Commands don't necessarily need to be
+# contained in this conf, but a separate conf makes it easier to maintain them. 
+# Note for Windows users:  You are advised to make this an absolute path,
+# such as:  c:\snort\etc\threshold.conf
+# Uncomment if needed.
+# include threshold.conf
diff -rNu snort-2.7.0/etc/spade.conf snort-2.7.0.mod/etc/spade.conf
--- snort-2.7.0/etc/spade.conf	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/etc/spade.conf	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,93 @@
+# Example configuration file for Spade v021026.1 and later
+# use this as your snort config file (-c option) to run Snort Spade-only
+# include it in your snort config file or put lines of this form in it
+
+# set this to a directory Spade can read and write to store its files
+var SPADEDIR .
+
+# see the Usage.Spade file for the full meaning of and all the options
+#   available for all these lines
+
+# This is the main Spade configuration line; it must appear first.
+# Here are some options for this line:
+# + dest:  the Snort facility that the Spade output should go to
+#   (alert, log, or both)
+# + statefile:  where Spade's persistant data is stored
+# + logfile:  where Spade will store information about its run
+# + Xdports,Xdips,Xsips,Xsports: like below but with global application
+preprocessor spade:  dest=log logfile=$SPADEDIR/spade.log statefile=$SPADEDIR/spade.rcv
+
+# This line sets up your Spade homenet.  Set this to the network that is
+#   connecting to the larger network at the point Spade is running.
+# It is important to configure this line.
+# Your networks should be like [10.0.0.0/8,192.168.0.0/16] or space separated
+preprocessor spade-homenet: any
+
+# Turn on some detectors with "spade-detect" lines.  Each of these enables
+#   a cetain type of detector for a certain type of packet.  If you start to
+#   feel overwhelmed, use Xdports, Xdips, Xsips, and/or Xsports on the lines 
+#   below to suppress reports you don't care about, and/or disable some of
+#   your detectors these that you care least about.
+#        These detect packets going to seemingly closed dest ports
+#            You can add thresh=N to override the default reporting threshold.
+preprocessor spade-detect: type=closed-dport tcpflags=synonly wait=3
+preprocessor spade-detect: type=closed-dport tcpflags=weird thresh=0.5
+#preprocessor spade-detect: type=closed-dport tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport tcpflags=established 
+#preprocessor spade-detect: type=closed-dport tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport proto=udp wait=5
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synonly wait=5
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=weird 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=established 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport to=nothome proto=udp wait=7
+#        These detect packets going to a seemingly non-live IP
+#preprocessor spade-detect: type=dead-dest tcpflags=synonly wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=weird wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=synack wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=setup wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=established wait=5
+preprocessor spade-detect: type=dead-dest tcpflags=teardown wait=2
+preprocessor spade-detect: type=dead-dest proto=udp wait=2
+preprocessor spade-detect: type=dead-dest proto=icmp icmptype=noterr wait=2
+#preprocessor spade-detect: type=dead-dest proto=icmp icmptype=err wait=2
+#        These detect unusual use of a dest port by a source IP
+#            You can add thresh=N to override the default reporting threshold.
+#preprocessor spade-detect: type=odd-dport proto=tcp wait=2
+#preprocessor spade-detect: type=odd-dport proto=udp wait=5
+#preprocessor spade-detect: type=odd-dport from=nothome proto=tcp
+#preprocessor spade-detect: type=odd-dport from=nothome proto=udp
+#        These detect ICMP packets with an unusual type and code
+#            You can add thresh=N to override the default reporting threshold.
+preprocessor spade-detect: type=odd-typecode
+preprocessor spade-detect: type=odd-typecode to=nothome
+#        These detect unusual connections to a dest IP by a source IP when the
+#            dest port has predictable dest IPs
+#            You can add thresh=N to override the default reporting threshold.
+#preprocessor spade-detect: type=odd-port-dest proto=tcp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest proto=udp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=tcp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=udp Xdports=80
+
+# This line causes Spade to adjust the reporting threshold for a given
+#   detector automatically; repeat it for each detector that you want to apply
+#   it to
+# Target is the target rate of alerts for normal circumstances
+#   (0.01= 1% or you can give it an hourly rate)
+# After the first hour (or however long the period is set to with "obsper"),
+#   the initially configured reporting threshold is ignored
+# To use this, you will need to an option of the form id=<label> to the
+#   spade-detect line of the detector you want to be adapted and set
+#   id=<label> below to match
+# This mode is recommended for users getting started that are using absolute
+#   anomaly scores; relative score users might want it as well.
+#preprocessor spade-adapt3: id=<label> target=0.01 obsper=60
+
+# some other possible Spade config lines:
+# offline threshold advising for a detector
+#preprocessor spade-threshadvise: id=<label> target=200 obsper=24
+# periodically report on the anom scores and count of packets seen by a detector
+#preprocessor spade-survey:  id=<label> surveyfile=$SPADEDIR/survey.txt interval=60
+# print out certain all known stats about packet features
+#preprocessor spade-stats: entropy uncondprob condprob
diff -rNu snort-2.7.0/etc/spade.more.conf snort-2.7.0.mod/etc/spade.more.conf
--- snort-2.7.0/etc/spade.more.conf	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/etc/spade.more.conf	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,93 @@
+# Example configuration file for Spade v021026.1 and later
+# use this as your snort config file (-c option) to run Snort Spade-only
+# include it in your snort config file or put lines of this form in it
+
+# set this to a directory Spade can read and write to store its files
+var SPADEDIR .
+
+# see the Usage.Spade file for the full meaning of and all the options
+#   available for all these lines
+
+# This is the main Spade configuration line; it must appear first.
+# Here are some options for this line:
+# + dest:  the Snort facility that the Spade output should go to
+#   (alert, log, or both)
+# + statefile:  where Spade's persistant data is stored
+# + logfile:  where Spade will store information about its run
+# + Xdports,Xdips,Xsips,Xsports: like below but with global application
+preprocessor spade:  dest=alert logfile=$SPADEDIR/spade.log statefile=$SPADEDIR/spade.rcv
+
+# This line sets up your Spade homenet.  Set this to the network that is
+#   connecting to the larger network at the point Spade is running.
+# It is important to configure this line.
+# Your networks should be like [10.0.0.0/8,192.168.0.0/16] or space separated
+preprocessor spade-homenet: any
+
+# Turn on some detectors with "spade-detect" lines.  Each of these enables
+#   a cetain type of detector for a certain type of packet.  If you start to
+#   feel overwhelmed, use Xdports, Xdips, Xsips, and/or Xsports on the lines 
+#   below to suppress reports you don't care about, and/or disable some of
+#   your detectors these that you care least about.
+#        These detect packets going to seemingly closed dest ports
+#            You can add thresh=N to override the default reporting threshold.
+preprocessor spade-detect: type=closed-dport tcpflags=synonly wait=3
+preprocessor spade-detect: type=closed-dport tcpflags=weird thresh=0.5
+#preprocessor spade-detect: type=closed-dport tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport tcpflags=established 
+preprocessor spade-detect: type=closed-dport tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport proto=udp wait=5
+preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synonly wait=5
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=weird 
+preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=established 
+preprocessor spade-detect: type=closed-dport to=nothome tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport to=nothome proto=udp wait=7
+#        These detect packets going to a seemingly non-live IP
+#preprocessor spade-detect: type=dead-dest tcpflags=synonly wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=weird wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=synack wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=setup wait=2
+preprocessor spade-detect: type=dead-dest tcpflags=established wait=5
+preprocessor spade-detect: type=dead-dest tcpflags=teardown wait=2
+preprocessor spade-detect: type=dead-dest proto=udp wait=2
+preprocessor spade-detect: type=dead-dest proto=icmp icmptype=noterr wait=2
+#preprocessor spade-detect: type=dead-dest proto=icmp icmptype=err wait=2
+#        These detect unusual use of a dest port by a source IP
+#            You can add thresh=N to override the default reporting threshold.
+preprocessor spade-detect: type=odd-dport proto=tcp wait=2
+#preprocessor spade-detect: type=odd-dport proto=udp wait=5
+#preprocessor spade-detect: type=odd-dport from=nothome proto=tcp
+#preprocessor spade-detect: type=odd-dport from=nothome proto=udp
+#        These detect ICMP packets with an unusual type and code
+#            You can add thresh=N to override the default reporting threshold.
+preprocessor spade-detect: type=odd-typecode
+preprocessor spade-detect: type=odd-typecode to=nothome
+#        These detect unusual connections to a dest IP by a source IP when the
+#            dest port has predictable dest IPs
+#            You can add thresh=N to override the default reporting threshold.
+#preprocessor spade-detect: type=odd-port-dest proto=tcp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest proto=udp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=tcp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=udp Xdports=80
+
+# This line causes Spade to adjust the reporting threshold for a given
+#   detector automatically; repeat it for each detector that you want to apply
+#   it to
+# Target is the target rate of alerts for normal circumstances
+#   (0.01= 1% or you can give it an hourly rate)
+# After the first hour (or however long the period is set to with "obsper"),
+#   the initially configured reporting threshold is ignored
+# To use this, you will need to an option of the form id=<label> to the
+#   spade-detect line of the detector you want to be adapted and set
+#   id=<label> below to match
+# This mode is recommended for users getting started that are using absolute
+#   anomaly scores; relative score users might want it as well.
+#preprocessor spade-adapt3: id=<label> target=0.01 obsper=60
+
+# some other possible Spade config lines:
+# offline threshold advising for a detector
+#preprocessor spade-threshadvise: id=<label> target=200 obsper=24
+# periodically report on the anom scores and count of packets seen by a detector
+#preprocessor spade-survey:  id=<label> surveyfile=$SPADEDIR/survey.txt interval=60
+# print out certain all known stats about packet features
+#preprocessor spade-stats: entropy uncondprob condprob
diff -auNr snort-2.7.0.orig/etc/spade.ossim.conf snort-2.7.0/etc/spade.ossim.conf
--- snort-2.7.0.orig/etc/spade.ossim.conf	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0/etc/spade.ossim.conf	2007-11-05 12:07:10.000000000 +0100
@@ -0,0 +1,117 @@
+# Example configuration file for Spade v021026.1 and later
+# use this as your snort config file (-c option) to run Snort Spade-only
+# include it in your snort config file or put lines of this form in it
+
+# set this to a directory Spade can read and write to store its files
+var SPADEDIR /var/log/snort/
+
+# see the Usage.Spade file for the full meaning of and all the options
+#   available for all these lines
+
+# This is the main Spade configuration line; it must appear first.
+# Here are some options for this line:
+# + dest:  the Snort facility that the Spade output should go to
+#   (alert, log, or both)
+# + statefile:  where Spade's persistant data is stored
+# + logfile:  where Spade will store information about its run
+# + Xdports,Xdips,Xsips,Xsports: like below but with global application
+preprocessor spade:  dest=both logfile=$SPADEDIR/spade.log statefile=$SPADEDIR/spade.rcv
+
+# This line sets up your Spade homenet.  Set this to the network that is
+#   connecting to the larger network at the point Spade is running.
+# It is important to configure this line.
+# Your networks should be like [10.0.0.0/8,192.168.0.0/16] or space separated
+#preprocessor spade-homenet: 192.168.1.0/24
+
+# Turn on some detectors with "spade-detect" lines.  Each of these enables
+#   a cetain type of detector for a certain type of packet.  If you start to
+#   feel overwhelmed, use Xdports, Xdips, Xsips, and/or Xsports on the lines 
+#   below to suppress reports you don't care about, and/or disable some of
+#   your detectors these that you care least about.
+#        These detect packets going to seemingly closed dest ports
+#            You can add thresh=N to override the default reporting threshold.
+#
+#
+#  Closed Dest Ports
+preprocessor spade-detect: type=closed-dport Xsports=80,443 tcpflags=synonly wait=2
+preprocessor spade-detect: type=closed-dport Xsports=53,137,138,139 proto=udp wait=2
+#  Rare but Open Dst Used
+preprocessor spade-detect: type=closed-dport Xsports=80,443 Xdports=80,443 tcpflags=synonly revwaitrpt wait=2
+preprocessor spade-detect: type=closed-dport Xsports=53,137,138,139 proto=udp revwaitrpt wait=2
+#preprocessor spade-detect: type=closed-dport tcpflags=weird thresh=0.5
+#preprocessor spade-detect: type=closed-dport tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport tcpflags=established 
+#preprocessor spade-detect: type=closed-dport tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synonly wait=5
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=weird 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=synack 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=established 
+#preprocessor spade-detect: type=closed-dport to=nothome tcpflags=teardown 
+#preprocessor spade-detect: type=closed-dport to=nothome proto=udp wait=7
+
+
+#  These detect packets going to a seemingly non-live IP
+#
+#
+preprocessor spade-detect: type=dead-dest Xdports=80,443 tcpflags=synack wait=2
+preprocessor spade-detect: type=dead-dest proto=udp Xsports=53 wait=2
+preprocessor spade-detect: type=dead-dest proto=icmp icmptype=noterr wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=weird wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=setup wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=synonly wait=2
+#preprocessor spade-detect: type=dead-dest tcpflags=established wait=5
+#preprocessor spade-detect: type=dead-dest tcpflags=teardown wait=2
+#preprocessor spade-detect: type=dead-dest proto=icmp icmptype=err wait=2
+
+
+
+#        These detect unusual use of a dest port by a source IP
+#            You can add thresh=N to override the default reporting threshold.
+#
+#  Source used Odd Dest Port
+preprocessor spade-detect: type=odd-dport proto=tcp wait=2
+preprocessor spade-detect: type=odd-dport proto=udp Xsports=53,137,138,139 wait=2
+#preprocessor spade-detect: type=odd-dport from=nothome proto=tcp
+#preprocessor spade-detect: type=odd-dport from=nothome proto=udp
+
+
+#        These detect ICMP packets with an unusual type and code
+#            You can add thresh=N to override the default reporting threshold.
+#
+#
+preprocessor spade-detect: type=odd-typecode
+preprocessor spade-detect: type=odd-typecode to=nothome
+
+
+#        These detect unusual connections to a dest IP by a source IP when the
+#            dest port has predictable dest IPs
+#            You can add thresh=N to override the default reporting threshold.
+#
+#   Source Used Odd Dest For Port
+preprocessor spade-detect: type=odd-port-dest proto=tcp Xdports=80,443
+preprocessor spade-detect: type=odd-port-dest proto=udp Xsports=53,137,138,139
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=tcp Xdports=80
+#preprocessor spade-detect: type=odd-port-dest from=nothome proto=udp Xdports=80
+
+
+# This line causes Spade to adjust the reporting threshold for a given
+#   detector automatically; repeat it for each detector that you want to apply
+#   it to
+# Target is the target rate of alerts for normal circumstances
+#   (0.01= 1% or you can give it an hourly rate)
+# After the first hour (or however long the period is set to with "obsper"),
+#   the initially configured reporting threshold is ignored
+# To use this, you will need to an option of the form id=<label> to the
+#   spade-detect line of the detector you want to be adapted and set
+#   id=<label> below to match
+# This mode is recommended for users getting started that are using absolute
+#   anomaly scores; relative score users might want it as well.
+#preprocessor spade-adapt3: id=<label> target=0.01 obsper=60
+
+# some other possible Spade config lines:
+# offline threshold advising for a detector
+#preprocessor spade-threshadvise: id=<label> target=200 obsper=24
+# periodically report on the anom scores and count of packets seen by a detector
+#preprocessor spade-survey:  id=<label> surveyfile=$SPADEDIR/survey.txt interval=60
+# print out certain all known stats about packet features
+#preprocessor spade-stats: entropy uncondprob condprob
diff -rNu snort-2.7.0/src/generators.h snort-2.7.0.mod/src/generators.h
--- snort-2.7.0/src/generators.h	2007-07-03 22:41:28.000000000 +0200
+++ snort-2.7.0.mod/src/generators.h	2007-09-06 20:16:14.000000000 +0200
@@ -26,6 +26,10 @@
 #define GENERATOR_TAG                 2
 #define    TAG_LOG_PKT                1
 
+#define GENERATOR_SPP_SPADE         104
+#define     SPADE_ANOM_THRESHOLD_EXCEEDED   1
+#define     SPADE_ANOM_THRESHOLD_ADJUSTED   2
+
 #define GENERATOR_SPP_BO            105
 #define     BO_TRAFFIC_DETECT           1
 #define     BO_CLIENT_TRAFFIC_DETECT    2
diff -rNu snort-2.7.0/src/Makefile.am snort-2.7.0.mod/src/Makefile.am
--- snort-2.7.0/src/Makefile.am	2007-03-28 17:07:48.000000000 +0200
+++ snort-2.7.0.mod/src/Makefile.am	2007-09-06 20:15:11.000000000 +0200
@@ -4,6 +4,7 @@
 bin_PROGRAMS = snort
 
 snort_SOURCES = cdefs.h \
+packets.c packets.h \
 event.h \
 fatal.h \
 generators.h \
diff -rNu snort-2.7.0/src/Makefile.in snort-2.7.0.mod/src/Makefile.in
--- snort-2.7.0/src/Makefile.in	2007-07-16 14:12:31.000000000 +0200
+++ snort-2.7.0.mod/src/Makefile.in	2007-09-06 20:15:11.000000000 +0200
@@ -51,6 +51,7 @@
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(bin_PROGRAMS)
 am_snort_OBJECTS = codes.$(OBJEXT) debug.$(OBJEXT) decode.$(OBJEXT) \
+	packets.$(OBJEXT) \
 	log.$(OBJEXT) mstring.$(OBJEXT) parser.$(OBJEXT) \
 	profiler.$(OBJEXT) plugbase.$(OBJEXT) snort.$(OBJEXT) \
 	snprintf.$(OBJEXT) strlcatu.$(OBJEXT) strlcpyu.$(OBJEXT) \
diff -rNu snort-2.7.0/src/packets.c snort-2.7.0.mod/src/packets.c
--- snort-2.7.0/src/packets.c	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/packets.c	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,266 @@
+/*
+To: snort-devel@lists.sourceforge.net
+From: James Hoagland <hoagland@SiliconDefense.com>
+Cc: hoagland@SiliconDefense.com
+Subject: [Snort-devel] New internal facility: packet cloning
+Date: Sun, 29 Sep 2002 20:31:08 -0700
+
+Greetings all,
+
+I have written some new Snort internal functionality that should help current and future Snort detectors (e.g., preprocessors) do better detection and/or more complete and standard reporting.  That functionality is creating a copy of a Packet.
+
+Some background first, as I understand it (correct me if I am mistaken).  A Packet is the Snort data structure that contains the parsed fields of a packet that libpcap presents to Snort.  It is Snort's standard representation of a packet and so is used throughout the program.  It is given to preprocessors and Snort's signature based detector as one in a stream of packets.  When these detectors wish to report on a packet, they typically pass the Packet to the alert/log facilities (e.g., alert file or database) that the user has configured.  However, sometimes detectors use different output means than the standard ones that the user configured.  For example, spp_portscan and spp_portscan2 and their packet logs.  (There could be others.)
+
+I cannot say for sure why these two do not use the standard output mechanism.  But one barrier is the combination of the fact that the output mechanisms can only output a Packet structure and the fact that the Packet that is given to the detectors does not persist beyond that call into that detector.  Specifically, there is only one Packet that Snort has in memory at a time.  Regardless of the reason, the effect is that the user does not have the control they might like over the place where packets are stored.  For example, they cannot have portscan packets (as reported by spp_portscan) be logged to the database.  So this suggests that in order to give this flexibility to the user, the simplest thing is to provide the detector with a means of holding onto a Packet beyond its invocation.  However, this functionality does not exist in Snort and, given the complexity, it can be daunting for the detector writer to do write it themselves.
+
+The class of detectors that this will help is those that do not want to immediately report on a packet.  Often this will be because they want to wait for future information contained on the packet stream. For example, they want to eliminate a potential false positive.  And we know that false positives can be a barrier to effective use of Snort (and other IDSs).  So, providing the copying functionality, while not getting rid of false positives and promoting more standard packet reporting, can be enabling towards these goals.
+
+
+Okay, enough for the motivational speech. :)  Its working code that gets things done in open source.  So, it is attached.  At least it is working in my tests; I need others to test it our as well since, e.g., I do not have access to FDDI network packet to try it on.  And I am not an expert on the Packet data structure.  But I know much more about it now, given frequent consultation with decode.[ch].
+
+This is what is attached:
+
+1) packets.c: the code that implements ClonePacket() and FreePacket().
+
+2) packet.h:  I'll let you guess what role this serves. :)
+
+3) snort+pclone.patch:  A patch against snort 1.9.0beta6 that puts packets.[ch] into the Snort source.  In addition, the patch includes a hack of a preprocessor, spp_pcopytest, that uses the cloning code. It makes clones of 100 packets on the packet stream at a time before pushing them to the standard output facilities.  For reference, the original packets are spit out as they are received.  The original should match the clone (as they do in all my tests).  Run it as "src/snort -c etc/pcopytest.conf".
+
+Implementation notes.  There were other ways that this can be approached.  My goal was for it to be efficient and with only localized changes (e.g., no changes to Packet).  There are some other notes in the source.
+
+Snort notes.  There might be a couple small snags when using cloned packets.  One that I noticed is an (now) incorrect assumption that there will only be one call to PrintNetData between each packet acquisition.  (The workaround it to manually flush its cache.)  If some output mechanism makes a hardcoded reference to "the" Packet, that will be broken.  And if anything else makes the assumption that PrintNetData did, that would be broken.
+
+
+My main motivation for doing this is that the next generation version of Spade will need this functionality to reduce false positives and to accurately detect new scan types.  I could have this functionality internal to Spade, but I'd rather it be a general Snort internal facility that can be used anywhere in Snort.  If someone can implement this better, go for it.  But the functionality of a Packet persisting across calls to a preprocessor is something that I'll be needing in the not-too-distant future.
+
+If anyone has any questions/concerns/comments/fixes, let me know.
+
+Sorry for the length of this message.
+
+Kind regards,
+
+  Jim
+
+P.s. I do not think that Packet cloning is covered by any US federal or state stature, so at least we are safe that way. :)
+*/
+
+#include <pcap.h>
+#include <stdlib.h>
+#include <string.h>
+#include "decode.h"
+#include "snort.h"
+#include "packets.h"
+
+typedef struct _PacketClone
+{
+    Packet p; /* our packet; the address of this must be the same as
+                 the address of the structure */
+    struct pcap_pkthdr pkth; /* the pcap packet header to be included
+                                in the above packet */
+    u_int8_t *pkt; /* storage space for the packet data */
+    int pkt_alloc_size; /* how much space is allocated there */
+    struct _PacketClone *next;
+} PacketClone;
+
+PacketClone *free_packets; /* freelist of normal sized PacketClones */
+PacketClone *free_oz_packets; /* freelist of oversized PacketClones */
+
+#define ADJUST_PKT_INDEX_FIELD(to_p,from_p,field) \
+    if ((from_p)->field) \
+        (to_p)->field= (void *)((to_p)->pkt + \
+           ((unsigned long)(from_p)->field - (unsigned long)(from_p)->pkt));
+    
+#define ADJUST_OPTIONS_DATA_FIELD(to_p,from_p,field,index) \
+    if ((from_p)->field[index].data) \
+        (to_p)->field[index].data= ((to_p)->pkt + \
+            ((unsigned long)(from_p)->field[index].data - \
+             (unsigned long)(from_p)->pkt));
+
+
+/* the normal (minimum) size packet length to allocate; based on pcap snap length */
+#define NORMAL_ALLOC_PACKETLEN (pv.pkt_snaplen ? pv.pkt_snaplen : SNAPLEN)
+/* sometimes we'll need more that the snap length (e.g., with stream4_reassemble 
+   packets), so here's how we calculate how big; oversized allocations get up to
+   63 bytes extra added on at end to make their reuse more likely. */
+#define PACKET_ALLOC_SIZE(min) \
+    (min < NORMAL_ALLOC_PACKETLEN \
+    ? NORMAL_ALLOC_PACKETLEN \
+    : (((min+63) >> 6) << 6))
+
+/*
+ * Function: ClonePacket(Packet *p)
+ *
+ * Purpose: Make a copy of a decoded packet struct (Packet) so that the
+ *          contents of a Packet can survive beyond a call to pcap for a
+ *          new packet
+ *
+ * Arguments: p   => pointer to the decoded packet struct to clone
+ *
+ * Returns: a pointer to the copied Packet
+ *
+ * Notes: this function and FreePacket participate in a recycling program
+ *        for Packets to minimize malloc calls.  ssnptr and state fields not
+ *        copied but set to NULL instead.
+ */
+Packet *ClonePacket(Packet *p)
+{
+    PacketClone *clone,*prev,*here;
+    Packet *cp;
+    int i;
+    int packet_alloc_size= PACKET_ALLOC_SIZE(p->pkth->len);
+    int oversized= packet_alloc_size > NORMAL_ALLOC_PACKETLEN;
+    
+    /* get storage for the Packet */
+    if (free_packets != NULL || free_oz_packets != NULL)
+    {
+        if (oversized) {
+            /* draw from oversize list else the regular list */
+            if (free_oz_packets != NULL) {
+                prev= NULL;
+                here= free_oz_packets;
+                while (here->next != NULL) {
+                    if (here->pkt_alloc_size >= packet_alloc_size) break;
+                    prev= here;
+                    here= here->next;
+                }
+                clone= here;
+                if (prev != NULL)
+                    prev->next= here->next;
+                else
+                    free_oz_packets= here->next;
+            } else {
+                clone= free_packets;
+                free_packets= free_packets->next;
+            }
+            /* get bigger memory chunk if needed */
+            if (clone->pkt_alloc_size < packet_alloc_size) {
+                free(clone->pkt);
+                clone->pkt= (u_int8_t *)calloc(packet_alloc_size,sizeof(u_int8_t));
+                if (clone->pkt == NULL) /* must be out of memory */
+                {
+                    free(clone);
+                    return NULL;
+                }
+                clone->pkt_alloc_size= packet_alloc_size;
+            }
+        } else {
+            /* draw from regular list else the oversize list */
+            if (free_packets != NULL) {
+                clone= free_packets;
+                free_packets= free_packets->next;
+            } else {
+                clone= free_oz_packets;
+                free_oz_packets= free_oz_packets->next;
+            }
+        }
+    } else {
+        clone= (PacketClone *)calloc(1,sizeof(PacketClone));
+        if (clone == NULL) return NULL; /* must be out of memory */
+        
+        clone->pkt= (u_int8_t *)calloc(packet_alloc_size,sizeof(u_int8_t));
+        if (clone->pkt == NULL) /* must be out of memory */
+        {
+            free(clone);
+            return NULL;
+        }
+        clone->pkt_alloc_size= packet_alloc_size;
+    }
+    
+    /* make a copy of the Packet p into cp */
+    cp= &clone->p;
+    *cp= *p; /* this will get everything except the pointers */
+    
+    /* copy the pcap header */
+    cp->pkth= &clone->pkth; /* we use the PacketClone storage space rather
+                               than malloc */
+    *cp->pkth= *(p->pkth);
+    
+    /* copy the packet data */
+    cp->pkt= clone->pkt;
+    memcpy(cp->pkt,p->pkt,p->pkth->len);
+    
+    /* set the Packet fields which are just pointers into the packet data
+       (i.e., just about all of them) */
+    /* many of these fields are NULL, so let's use some knowledge about 
+       the relationship between fields to avoid trying to adjust; of course
+       this means that this must be maintained */
+    if (p->fddihdr) {
+        ADJUST_PKT_INDEX_FIELD(cp,p,fddihdr);
+        ADJUST_PKT_INDEX_FIELD(cp,p,fddisaps);
+        ADJUST_PKT_INDEX_FIELD(cp,p,fddisna);
+        ADJUST_PKT_INDEX_FIELD(cp,p,fddiiparp);
+        ADJUST_PKT_INDEX_FIELD(cp,p,fddiother);
+    }
+    if (p->trh) {
+        ADJUST_PKT_INDEX_FIELD(cp,p,trh);
+        ADJUST_PKT_INDEX_FIELD(cp,p,trhllc);
+        ADJUST_PKT_INDEX_FIELD(cp,p,trhmr);
+    }
+    ADJUST_PKT_INDEX_FIELD(cp,p,sllh);
+    ADJUST_PKT_INDEX_FIELD(cp,p,pfh);
+    ADJUST_PKT_INDEX_FIELD(cp,p,eh);
+    ADJUST_PKT_INDEX_FIELD(cp,p,vh);
+    ADJUST_PKT_INDEX_FIELD(cp,p,ehllc);
+    ADJUST_PKT_INDEX_FIELD(cp,p,ehllcother);
+    ADJUST_PKT_INDEX_FIELD(cp,p,wifih);
+    ADJUST_PKT_INDEX_FIELD(cp,p,ah);
+    if (p->eplh) {
+        ADJUST_PKT_INDEX_FIELD(cp,p,eplh);
+        ADJUST_PKT_INDEX_FIELD(cp,p,eaph);
+        ADJUST_PKT_INDEX_FIELD(cp,p,eaptype);
+        ADJUST_PKT_INDEX_FIELD(cp,p,eapolk);
+    }
+    if (p->iph) {
+        ADJUST_PKT_INDEX_FIELD(cp,p,iph);
+        ADJUST_PKT_INDEX_FIELD(cp,p,ip_options_data);
+        /* get the ones inside decoded options too */
+        for (i= 0; i < p->ip_option_count; i++)
+            ADJUST_OPTIONS_DATA_FIELD(cp,p,ip_options,i);
+        if (p->tcph) {
+            ADJUST_PKT_INDEX_FIELD(cp,p,tcph);
+            ADJUST_PKT_INDEX_FIELD(cp,p,tcp_options_data);
+            for (i= 0; i < p->tcp_option_count; i++)
+                ADJUST_OPTIONS_DATA_FIELD(cp,p,tcp_options,i);
+        } else if (p->icmph) {
+            ADJUST_PKT_INDEX_FIELD(cp,p,icmph);
+            ADJUST_PKT_INDEX_FIELD(cp,p,orig_iph);
+            ADJUST_PKT_INDEX_FIELD(cp,p,orig_udph);
+            ADJUST_PKT_INDEX_FIELD(cp,p,orig_tcph);
+            ADJUST_PKT_INDEX_FIELD(cp,p,orig_icmph);
+        } else
+            ADJUST_PKT_INDEX_FIELD(cp,p,udph);
+    }
+    //not used and no ext variable in 2.4.0 Snort
+    //ADJUST_PKT_INDEX_FIELD(cp,p,ext); /* is this used anywhere? */
+    ADJUST_PKT_INDEX_FIELD(cp,p,data);
+
+    /* we don't copy these over */
+    cp->ssnptr= NULL;
+
+    return cp;
+}
+
+/*
+ * Function: FreePacket(Packet *p)
+ *
+ * Purpose: Free a Packet created by ClonePacket
+ *
+ * Arguments: p   => pointer to the decoded packet struct to free
+ *
+ * Returns: nada
+ *
+ * Notes: this function and FreePacket participate in a recycling program
+ *        for Packets to minimize malloc calls.
+ */
+void FreePacket(Packet *p)
+{
+    PacketClone *pc= (PacketClone *)p; /* assumes pc has same addr as p */
+    if (pc->pkt_alloc_size > NORMAL_ALLOC_PACKETLEN) {
+        pc->next= free_oz_packets;
+        free_oz_packets= pc;
+    } else {
+        pc->next= free_packets;
+        free_packets= pc;
+    }
+    /* note: pc->pkt remains allocated. */
+}
diff -rNu snort-2.7.0/src/packets.h snort-2.7.0.mod/src/packets.h
--- snort-2.7.0/src/packets.h	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/packets.h	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,11 @@
+/* part of the packet cloning patch by Jim Hoagland, Silicon Defense
+ (hoagland@silicondefense.com).  Hopefully this or equivalent functionality
+ will become a standard part of the Snort source. */
+
+#ifndef __PACKETS_H__
+#define __PACKETS_H__
+
+Packet *ClonePacket(Packet *p);
+void FreePacket(Packet *p);
+
+#endif // __PACKETS_H__
diff -rNu snort-2.7.0/src/plugbase.c snort-2.7.0.mod/src/plugbase.c
--- snort-2.7.0/src/plugbase.c	2007-07-03 22:41:29.000000000 +0200
+++ snort-2.7.0.mod/src/plugbase.c	2007-09-06 20:15:11.000000000 +0200
@@ -59,7 +59,7 @@
 #include "preprocessors/spp_flow.h"
 #include "preprocessors/spp_sfportscan.h"
 #include "preprocessors/spp_frag3.h"
-
+#include "preprocessors/spp_spade.h"
 /* built-in detection plugins */
 #include "detection-plugins/sp_pattern_match.h"
 #include "detection-plugins/sp_tcp_flag_check.h"
@@ -186,6 +186,7 @@
 #endif
     SetupFTPBounce();
     SetupUriLenCheck();
+    SetupSpade();
 }
 
 /****************************************************************************
diff -rNu snort-2.7.0/src/plugbase.c.orig snort-2.7.0.mod/src/plugbase.c.orig
--- snort-2.7.0/src/plugbase.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/plugbase.c.orig	2007-07-03 22:41:29.000000000 +0200
@@ -0,0 +1,1666 @@
+/* $Id: snort-spade-2.7.0.diff,v 1.3 2007/11/05 11:12:39 dvgil Exp $ */
+/*
+** Copyright (C) 1998-2002 Martin Roesch <roesch@sourcefire.com>
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License Version 2 as
+** published by the Free Software Foundation.  You may not use, modify or
+** distribute this program under any other version of the GNU General
+** Public License.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+
+#ifndef WIN32
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif /* !WIN32 */
+#include <time.h>
+#include <errno.h>
+
+
+#include "plugbase.h"
+#include "spo_plugbase.h"
+#include "snort.h"
+#include "debug.h"
+#include "util.h"
+#include "log.h"
+#include "detect.h"
+
+/* built-in preprocessors */
+#include "preprocessors/spp_rpc_decode.h"
+#include "preprocessors/spp_bo.h"
+#include "preprocessors/spp_stream4.h"
+#include "preprocessors/spp_stream5.h"
+#include "preprocessors/spp_arpspoof.h"
+#include "preprocessors/spp_perfmonitor.h"
+#include "preprocessors/spp_httpinspect.h"
+#include "preprocessors/spp_flow.h"
+#include "preprocessors/spp_sfportscan.h"
+#include "preprocessors/spp_frag3.h"
+
+/* built-in detection plugins */
+#include "detection-plugins/sp_pattern_match.h"
+#include "detection-plugins/sp_tcp_flag_check.h"
+#include "detection-plugins/sp_icmp_type_check.h"
+#include "detection-plugins/sp_icmp_code_check.h"
+#include "detection-plugins/sp_ttl_check.h"
+#include "detection-plugins/sp_ip_id_check.h"
+#include "detection-plugins/sp_tcp_ack_check.h"
+#include "detection-plugins/sp_tcp_seq_check.h"
+#include "detection-plugins/sp_dsize_check.h"
+#include "detection-plugins/sp_ipoption_check.h"
+#include "detection-plugins/sp_rpc_check.h"
+#include "detection-plugins/sp_icmp_id_check.h"
+#include "detection-plugins/sp_icmp_seq_check.h"
+#include "detection-plugins/sp_session.h"
+#include "detection-plugins/sp_ip_tos_check.h"
+#include "detection-plugins/sp_ip_fragbits.h"
+#include "detection-plugins/sp_tcp_win_check.h"
+#include "detection-plugins/sp_ip_same_check.h"
+#include "detection-plugins/sp_ip_proto.h"
+#include "detection-plugins/sp_ip_same_check.h"
+#include "detection-plugins/sp_clientserver.h"
+#include "detection-plugins/sp_byte_check.h"
+#include "detection-plugins/sp_byte_jump.h"
+#include "detection-plugins/sp_isdataat.h"
+#include "detection-plugins/sp_pcre.h"
+#include "detection-plugins/sp_flowbits.h"
+#include "detection-plugins/sp_asn1.h"
+#if defined(ENABLE_RESPONSE) && !defined(ENABLE_RESPONSE2)
+#include "detection-plugins/sp_react.h"
+#include "detection-plugins/sp_respond.h"
+#elif defined(ENABLE_RESPONSE2) && !defined(ENABLE_RESPONSE)
+#include "detection-plugins/sp_respond2.h"
+#endif
+#if defined(ENABLE_REACT) && !defined(ENABLE_RESPONSE)
+#include "detection-plugins/sp_react.h"
+#endif
+#include "detection-plugins/sp_ftpbounce.h"
+#include "detection-plugins/sp_urilen_check.h"
+
+/* built-in output plugins */
+#include "output-plugins/spo_alert_syslog.h"
+#include "output-plugins/spo_log_tcpdump.h"
+#include "output-plugins/spo_database.h"
+#include "output-plugins/spo_alert_fast.h"
+#include "output-plugins/spo_alert_full.h"
+#include "output-plugins/spo_alert_unixsock.h"
+#include "output-plugins/spo_csv.h"
+#include "output-plugins/spo_unified.h"
+#include "output-plugins/spo_log_null.h"
+#include "output-plugins/spo_log_ascii.h"
+
+#ifdef ARUBA
+#include "output-plugins/spo_alert_arubaaction.h"
+#endif
+
+#ifdef HAVE_LIBPRELUDE
+#include "output-plugins/spo_alert_prelude.h"
+#endif
+
+#ifdef LINUX
+#include "output-plugins/spo_alert_sf_socket.h"
+#endif
+
+PluginSignalFuncNode *PluginShutdownList;
+PluginSignalFuncNode *PluginCleanExitList;
+PluginSignalFuncNode *PluginRestartList;
+PluginSignalFuncNode *PluginPostConfigList;
+
+PreprocSignalFuncNode *PreprocShutdownList;
+PreprocSignalFuncNode *PreprocCleanExitList;
+PreprocSignalFuncNode *PreprocRestartList;
+
+extern int file_line;
+extern char *file_name;
+
+
+
+
+/**************************** Detection Plugin API ****************************/
+KeywordXlateList *KeywordList;
+
+void InitPlugIns()
+{
+    if(!pv.quiet_flag)
+    {
+        LogMessage("Initializing Plug-ins!\n");
+    }
+    SetupPatternMatch();
+    SetupTCPFlagCheck();
+    SetupIcmpTypeCheck();
+    SetupIcmpCodeCheck();
+    SetupTtlCheck();
+    SetupIpIdCheck();
+    SetupTcpAckCheck();
+    SetupTcpSeqCheck();
+    SetupDsizeCheck();
+    SetupIpOptionCheck();
+    SetupRpcCheck();
+    SetupIcmpIdCheck();
+    SetupIcmpSeqCheck();
+    SetupSession();
+    SetupIpTosCheck();
+    SetupFragBits();
+    SetupFragOffset();
+    SetupTcpWinCheck();
+    SetupIpProto();
+    SetupIpSameCheck();
+    SetupClientServer();
+    SetupByteTest();
+    SetupByteJump();
+    SetupIsDataAt();
+    SetupPcre();
+    SetupFlowBits();
+    SetupAsn1();
+#if defined(ENABLE_RESPONSE) && !defined(ENABLE_RESPONSE2)
+    SetupReact();
+    SetupRespond();
+#elif defined(ENABLE_RESPONSE2) && !defined(ENABLE_RESPONSE)
+    SetupRespond2();
+#endif
+#if defined(ENABLE_REACT) && !defined(ENABLE_RESPONSE)
+    SetupReact();
+#endif
+    SetupFTPBounce();
+    SetupUriLenCheck();
+}
+
+/****************************************************************************
+ *
+ * Function: RegisterPlugin(char *, void (*func)())
+ *
+ * Purpose:  Associates a rule option keyword with an option setup/linking
+ *           function.
+ *
+ * Arguments: keyword => The option keyword to associate with the option
+ *                       handler
+ *            *func => function pointer to the handler
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void RegisterPlugin(char *keyword, void (*func) (char *, OptTreeNode *, int))
+{
+    KeywordXlateList *idx;
+
+    DEBUG_WRAP(DebugMessage(DEBUG_PLUGIN, "Registering keyword:func => %s:%p\n",
+               keyword, func););
+
+    idx = KeywordList;
+
+    if(idx == NULL)
+    {
+        KeywordList = (KeywordXlateList *)SnortAlloc(sizeof(KeywordXlateList));
+
+        KeywordList->entry.keyword = (char *)SnortAlloc((strlen(keyword) + 1) * sizeof(char));
+
+        SnortStrncpy(KeywordList->entry.keyword, keyword, strlen(keyword) + 1);
+        KeywordList->entry.func = func;
+    }
+    else
+    {
+        /* go to the end of the list */
+        while(idx->next != NULL)
+        {
+            if(!strcasecmp(idx->entry.keyword, keyword))
+            {
+                FatalError("RegisterPlugin: Duplicate detection plugin keyword:"
+                        " (%s) (%s)!\n", idx->entry.keyword, keyword);
+            }
+            idx = idx->next;
+        }
+
+        idx->next = (KeywordXlateList *)SnortAlloc(sizeof(KeywordXlateList));
+
+        idx = idx->next;
+
+        idx->entry.keyword = (char *)SnortAlloc((strlen(keyword) + 1) * sizeof(char));
+        SnortStrncpy(idx->entry.keyword, keyword, strlen(keyword) + 1);
+        idx->entry.func = func;
+    }
+}
+
+
+
+
+/****************************************************************************
+ *
+ * Function: DumpPlugIns()
+ *
+ * Purpose:  Prints the keyword->function list
+ *
+ * Arguments: None.
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void DumpPlugIns()
+{
+    KeywordXlateList *idx;
+
+    if(pv.quiet_flag)
+        return;
+
+    idx = KeywordList;
+
+    printf("-------------------------------------------------\n");
+    printf(" Keyword     |      Plugin Registered @\n");
+    printf("-------------------------------------------------\n");
+    while(idx != NULL)
+    {
+        printf("%-13s:      %p\n", idx->entry.keyword, idx->entry.func);
+        idx = idx->next;
+    }
+    printf("-------------------------------------------------\n\n");
+}
+
+
+/****************************************************************************
+ * 
+ * Function: AddOptFuncToList(int (*func)(), OptTreeNode *)
+ *
+ * Purpose: Links the option detection module to the OTN
+ *
+ * Arguments: (*func)() => function pointer to the detection module
+ *            otn =>  pointer to the current OptTreeNode
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+OptFpList *AddOptFuncToList(int (*func) (Packet *, struct _OptTreeNode *, 
+            struct _OptFpList *), OptTreeNode * otn)
+{
+    OptFpList *idx;     /* index pointer */
+
+    DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,"Adding new rule to list\n"););
+
+    /* set the index pointer to the start of this OTN's function list */
+    idx = otn->opt_func;
+
+    /* if there are no nodes on the function list... */
+    if(idx == NULL)
+    {
+        /* calloc the list head */
+        otn->opt_func = (OptFpList *)calloc(1, sizeof(OptFpList));
+
+        if(otn->opt_func == NULL)
+        {
+            FatalError("new node calloc failed: %s\n",
+                       strerror(errno));
+        }
+
+        /* set the head function */
+        otn->opt_func->OptTestFunc = func;
+
+        idx = otn->opt_func;
+    }
+    else
+    {
+        /* walk to the end of the list */
+        while(idx->next != NULL)
+        {
+            idx = idx->next;
+        }
+
+        /* allocate a new node on the end of the list */
+        idx->next = (OptFpList *)calloc(1, sizeof(OptFpList));
+
+        if(idx->next == NULL)
+        {
+            FatalError("AddOptFuncToList new node calloc failed: %s\n",
+                       strerror(errno));
+        }
+
+        /* move up to the new node */
+        idx = idx->next;
+
+        /* link the function to the new node */
+        idx->OptTestFunc = func;
+
+        DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,"Set OptTestFunc to %p\n", 
+                    func););
+    }
+
+    return idx;
+}
+
+/****************************************************************************
+ *
+ * Function: AddRspFuncToList(int (*func)(), OptTreeNode *)
+ *
+ * Purpose: Adds Response function to OTN
+ *
+ * Arguments: (*func)() => function pointer to the response module
+ *            otn =>  pointer to the current OptTreeNode
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void AddRspFuncToList(int (*func) (Packet *, struct _RspFpList *), OptTreeNode * otn, void *params)
+{
+    RspFpList *idx;     /* index pointer */
+
+    DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,"Adding response to list\n"););
+
+    /* set the index pointer to the start of this OTN's function list */
+    idx = otn->rsp_func;
+
+    /* if there are no nodes on the function list... */
+    if(idx == NULL)
+    {
+        /* calloc the list head */
+        otn->rsp_func = (RspFpList *)calloc(1, sizeof(RspFpList));
+
+        if(otn->rsp_func == NULL)
+        {
+            FatalError("AddRspFuncToList new node calloc failed: %s\n", strerror(errno));
+        }
+        /* set the head function */
+        otn->rsp_func->ResponseFunc = func;
+        otn->rsp_func->params = params;
+    }
+    else
+    {
+        /* walk to the end of the list */
+        while(idx->next != NULL)
+        {
+            idx = idx->next;
+        }
+
+        /* allocate a new node on the end of the list */
+        idx->next = (RspFpList *)calloc(1, sizeof(RspFpList));
+
+        if(idx->next == NULL)
+        {
+            FatalError("AddRspFuncToList new node calloc failed: %s\n", strerror(errno));
+        }
+        /* link the function to the new node */
+        idx->next->ResponseFunc = func;
+        idx->next->params = params;
+
+        DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,"Set ResponseFunc to %p\n", func););
+    }
+}
+
+
+/************************* End Detection Plugin API ***************************/
+
+
+/************************** Preprocessor Plugin API ***************************/
+PreprocessKeywordList *PreprocessKeywords = NULL;
+PreprocessFuncNode *PreprocessList = NULL;
+PreprocessCheckConfigNode *PreprocessConfigCheckList = NULL;
+
+void InitPreprocessors()
+{
+    if(!pv.quiet_flag)
+    {
+        LogMessage("Initializing Preprocessors!\n");
+    }
+    SetupRpcDecode();
+    SetupBo();
+    SetupStream4();
+    SetupARPspoof();
+    SetupHttpInspect();
+    SetupPerfMonitor();
+    SetupFlow();
+    SetupPsng();
+    SetupFrag3();
+    SetupStream5();
+}
+
+void CheckPreprocessorsConfig()
+{
+    PreprocessCheckConfigNode *idx;
+
+    idx = PreprocessConfigCheckList;
+
+    if(!pv.quiet_flag)
+    {
+        LogMessage("Verifying Preprocessor Configurations!\n");
+    }
+
+    while(idx != NULL)
+    {
+        idx->func();
+        idx = idx->next;
+    }
+}
+
+void PostConfigInitPlugins()
+{
+    PluginSignalFuncNode *idx;
+
+    idx = PluginPostConfigList;
+
+    while (idx != NULL)
+    {
+        idx->func(0, idx->arg);
+        idx = idx->next;
+    }
+}
+
+/****************************************************************************
+ *
+ * Function: RegisterPreprocessor(char *, void (*func)(u_char *))
+ *
+ * Purpose:  Associates a preprocessor statement with its function.
+ *
+ * Arguments: keyword => The option keyword to associate with the
+ *                       preprocessor
+ *            *func => function pointer to the handler
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void RegisterPreprocessor(char *keyword, void (*func) (u_char *))
+{
+    PreprocessKeywordList *idx;
+
+    DEBUG_WRAP(DebugMessage(DEBUG_PLUGIN,"Registering keyword:preproc => %s:%p\n", keyword, func););
+
+    idx = PreprocessKeywords;
+
+    if(idx == NULL)
+    {
+        /* alloc the node */
+        PreprocessKeywords = (PreprocessKeywordList *)SnortAlloc(sizeof(PreprocessKeywordList));
+
+        /* alloc space for the keyword */
+        PreprocessKeywords->entry.keyword = (char *)SnortAlloc((strlen(keyword) + 1) * sizeof(char));
+
+        /* copy the keyword into the struct */
+        SnortStrncpy(PreprocessKeywords->entry.keyword, keyword, strlen(keyword) + 1);
+
+        /* set the function pointer to the keyword handler function */
+        PreprocessKeywords->entry.func = (void (*)(char *))func;
+    }
+    else
+    {
+        /* loop to the end of the list */
+        while(idx->next != NULL)
+        {
+            if(!strcasecmp(idx->entry.keyword, keyword))
+            {
+                FatalError("%s(%d) => Duplicate preprocessor keyword!\n",
+                           file_name, file_line);
+            }
+            idx = idx->next;
+        }
+
+        idx->next = (PreprocessKeywordList *)SnortAlloc(sizeof(PreprocessKeywordList));
+
+        idx = idx->next;
+
+        /* alloc space for the keyword */
+        idx->entry.keyword = (char *)SnortAlloc((strlen(keyword) + 1) * sizeof(char));
+
+        /* copy the keyword into the struct */
+        SnortStrncpy(idx->entry.keyword, keyword, strlen(keyword) + 1);
+
+        /* set the function pointer to the keyword handler function */
+        idx->entry.func = (void (*)(char *))func;
+    }
+}
+
+
+
+
+/****************************************************************************
+ *
+ * Function: DumpPreprocessors()
+ *
+ * Purpose:  Prints the keyword->preprocess list
+ *
+ * Arguments: None.
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void DumpPreprocessors()
+{
+    PreprocessKeywordList *idx;
+
+    if(pv.quiet_flag)
+        return;
+    idx = PreprocessKeywords;
+
+    printf("-------------------------------------------------\n");
+    printf(" Keyword     |       Preprocessor @ \n");
+    printf("-------------------------------------------------\n");
+    while(idx != NULL)
+    {
+        printf("%-13s:       %p\n", idx->entry.keyword, idx->entry.func);
+        idx = idx->next;
+    }
+    printf("-------------------------------------------------\n\n");
+}
+
+static SFGHASH *preprocIdTable = NULL;
+unsigned int num_preprocs = 0;
+int IsPreprocBitSet(Packet *p, unsigned int preproc_bit)
+{
+#if 0
+    int preproc_bit;
+    PreprocessFuncNode *idx = sfghash_find(preprocIdTable, &preproc_id);
+    if (idx)
+    {
+        preproc_bit = idx->preproc_bit;
+        return boIsBitSet(p->preprocessor_bits, preproc_bit);
+    }
+    return 0;
+#endif
+    return boIsBitSet(p->preprocessor_bits, preproc_bit);
+}
+
+int SetPreprocBit(Packet *p, unsigned int preproc_id)
+{
+    int preproc_bit;
+    PreprocessFuncNode *idx = sfghash_find(preprocIdTable, &preproc_id);
+    if (idx)
+    {
+        preproc_bit = idx->preproc_bit;
+        return boSetBit(p->preprocessor_bits, preproc_bit);
+    }
+    return 0;
+}
+
+PreprocessFuncNode *AddFuncToPreprocList(void (*func) (Packet *, void *),
+        unsigned short priority,
+        unsigned int preproc_id)
+{
+    PreprocessFuncNode *idx;
+    PreprocessFuncNode *tmpNext;
+    PreprocessFuncNode *insertAfter = NULL;
+
+    DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,
+        "Adding preprocessor function ID %d/bit %d/pri %d to list\n",
+         preproc_id, num_preprocs, priority););
+    idx = PreprocessList;
+
+    if(idx == NULL)
+    {
+        PreprocessList = (PreprocessFuncNode *)SnortAlloc(sizeof(PreprocessFuncNode));
+
+        PreprocessList->func = func;
+        PreprocessList->priority = priority;
+        PreprocessList->preproc_id = preproc_id;
+        PreprocessList->preproc_bit = num_preprocs++;
+
+        idx = PreprocessList;
+    }
+    else
+    {
+        do
+        {
+            if (idx->preproc_id == preproc_id)
+            {
+                FatalError("Preprocessor already registered with ID %d\n", preproc_id);
+                //return NULL;
+            }
+            
+            if (idx->priority > priority)
+                break;
+            insertAfter = idx;
+            idx = idx->next;
+        }
+        while (idx);
+
+        idx = (PreprocessFuncNode *)SnortAlloc(sizeof(PreprocessFuncNode));
+        if (insertAfter)
+        {
+            tmpNext = insertAfter->next;
+            insertAfter->next = idx;
+            idx->next = tmpNext;
+        }
+        else
+        {
+            idx->next = PreprocessList;
+            PreprocessList = idx;
+        }
+
+        idx->func = func;
+        idx->priority = priority;
+        idx->preproc_id = preproc_id;
+        idx->preproc_bit = num_preprocs++;
+    }
+
+    return idx;
+}
+
+void MapPreprocessorIds()
+{
+    PreprocessFuncNode *idx;
+    if (preprocIdTable || !num_preprocs)
+        return;
+
+    preprocIdTable = sfghash_new(num_preprocs, 4, 1, NULL);
+
+    idx = PreprocessList;
+
+    while (idx)
+    {
+        DEBUG_WRAP(DebugMessage(DEBUG_CONFIGRULES,
+                   "Adding preprocessor ID %d/bit %d/pri %d to hash table\n",
+                   idx->preproc_id, idx->preproc_bit, idx->priority););
+        sfghash_add(preprocIdTable, &(idx->preproc_id), idx);
+        idx = idx->next;
+    }
+}
+
+PreprocessCheckConfigNode *AddFuncToConfigCheckList(void (*func)(void))
+{
+    PreprocessCheckConfigNode *idx;
+
+    idx = PreprocessConfigCheckList;
+
+    if(idx == NULL)
+    {
+        PreprocessConfigCheckList = (PreprocessCheckConfigNode *)SnortAlloc(sizeof(PreprocessCheckConfigNode));
+
+        PreprocessConfigCheckList->func = func;
+
+        idx = PreprocessConfigCheckList;
+    }
+    else
+    {
+        while(idx->next != NULL)
+            idx = idx->next;
+
+        idx->next = (PreprocessCheckConfigNode *)SnortAlloc(sizeof(PreprocessCheckConfigNode));
+
+        idx = idx->next;
+        idx->func = func;
+    }
+
+    return idx;
+}
+
+/* functions to aid in cleaning up aftre plugins */
+void AddFuncToPreprocRestartList(void (*func) (int, void *), void *arg,
+        unsigned short priority, unsigned int preproc_id)
+{
+    PreprocRestartList = AddFuncToPreprocSignalList(func, arg, PreprocRestartList, priority, preproc_id);
+}
+
+void AddFuncToPreprocCleanExitList(void (*func) (int, void *), void *arg,
+        unsigned short priority, unsigned int preproc_id)
+{
+    PreprocCleanExitList = AddFuncToPreprocSignalList(func, arg, PreprocCleanExitList, priority, preproc_id);
+}
+
+void AddFuncToPreprocShutdownList(void (*func) (int, void *), void *arg,
+        unsigned short priority, unsigned int preproc_id)
+{
+    PreprocShutdownList = AddFuncToPreprocSignalList(func, arg, PreprocShutdownList, priority, preproc_id);
+}
+
+PreprocSignalFuncNode *AddFuncToPreprocSignalList(void (*func) (int, void *), void *arg,
+                                          PreprocSignalFuncNode * list, unsigned short priority, unsigned int preproc_id)
+{
+    PreprocSignalFuncNode *idx;
+    PreprocSignalFuncNode *insertAfter = NULL;
+    PreprocSignalFuncNode *tmpNext;
+
+    idx = list;
+
+    if(idx == NULL)
+    {
+        idx = (PreprocSignalFuncNode *)SnortAlloc(sizeof(PreprocSignalFuncNode));
+
+        idx->func = func;
+        idx->arg = arg;
+        idx->preproc_id = preproc_id;
+        idx->priority = priority;
+        list = idx;
+    }
+    else
+    {
+        do
+        {
+            if (idx->priority > priority)
+                break;
+
+            insertAfter = idx;
+            idx = idx->next;
+        }
+        while(idx);
+
+        idx = (PreprocSignalFuncNode *)SnortAlloc(sizeof(PreprocSignalFuncNode));
+        if (insertAfter)
+        {
+            tmpNext = insertAfter->next;
+            insertAfter->next = idx;
+            idx->next = tmpNext;
+        }
+        else
+        {
+            idx->next = list;
+            list = idx;
+        }
+
+        idx->func = func;
+        idx->arg = arg;
+        idx->priority = priority;
+        idx->preproc_id = preproc_id;
+    }
+
+    return list;
+}
+
+/************************ End Preprocessor Plugin API  ************************/
+
+/***************************** Output Plugin API  *****************************/
+OutputKeywordList *OutputKeywords;
+OutputFuncNode *AlertList;
+OutputFuncNode *LogList;
+OutputFuncNode *AppendOutputFuncList(void (*) (Packet *,char *,void *,Event*),
+                void *, OutputFuncNode *);
+
+void InitOutputPlugins()
+{
+    if(!pv.quiet_flag)
+    {
+        LogMessage("Initializing Output Plugins!\n");
+    }
+    AlertSyslogSetup();
+    LogTcpdumpSetup();
+    DatabaseSetup();
+    AlertFastSetup();
+    AlertFullSetup();
+#ifndef WIN32
+    /* Win32 doesn't support AF_UNIX sockets */
+    AlertUnixSockSetup();
+#endif /* !WIN32 */
+    AlertCSVSetup();
+    LogNullSetup();
+    UnifiedSetup();
+    LogAsciiSetup();
+
+#ifdef ARUBA
+    AlertArubaActionSetup();
+#endif
+
+#ifdef LINUX
+    /* This uses linux only capabilities */
+    AlertSFSocket_Setup();
+#endif
+
+#ifdef HAVE_LIBPRELUDE
+    AlertPreludeSetup();
+#endif
+}
+
+int ActivateOutputPlugin(char *plugin_name, char *plugin_options)
+{
+    OutputKeywordNode *plugin;
+    
+    if(!plugin_name)
+        return -1;
+    
+    /* get the output plugin node */
+    plugin = GetOutputPlugin(plugin_name);
+    if (!plugin)
+        return -1;
+
+    switch(plugin->node_type)
+    {
+        case NT_OUTPUT_SPECIAL: /* both alert & logging in one plugin */
+            plugin->func(plugin_options);
+            break;
+        case NT_OUTPUT_ALERT:
+            plugin->func(plugin_options);
+            break;
+        case NT_OUTPUT_LOG:
+            plugin->func(plugin_options);
+            break;
+    }
+
+    return 0;
+}
+
+OutputKeywordNode *GetOutputPlugin(char *plugin_name)
+{
+    OutputKeywordList *list_node = NULL;
+    OutputKeywordNode *ret = NULL;
+
+    if (!plugin_name)
+        return NULL;
+
+    list_node = OutputKeywords;
+
+    while (list_node != NULL)
+    {
+        if (strcasecmp(plugin_name, list_node->entry.keyword) == 0)
+        {
+            ret = &(list_node->entry);
+            break;
+        }
+
+        list_node = list_node->next;
+    }
+
+    if (ret == NULL)
+    {
+        FatalError("unknown output plugin: '%s'", plugin_name);
+    }
+
+    return ret;
+}
+
+
+/****************************************************************************
+ *
+ * Function: RegisterOutputPlugin(char *, void (*func)(Packet *, u_char *))
+ *
+ * Purpose:  Associates an output statement with its function.
+ *
+ * Arguments: keyword => The output keyword to associate with the
+ *                       output processor
+ *            type => alert or log types
+ *            *func => function pointer to the handler
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void RegisterOutputPlugin(char *keyword, int type, void (*func) (u_char *))
+{
+    OutputKeywordList *idx;
+
+    DEBUG_WRAP(DebugMessage(DEBUG_PLUGIN,"Registering keyword:output => %s:%p\n", 
+                keyword, func););
+
+    idx = OutputKeywords;
+
+    if(idx == NULL)
+    {
+        /* alloc the node */
+        OutputKeywords = (OutputKeywordList *)SnortAlloc(sizeof(OutputKeywordList));
+
+        idx = OutputKeywords;
+    }
+    else
+    {
+        /* loop to the end of the list */
+        while(idx->next != NULL)
+        {
+            if(!strcasecmp(idx->entry.keyword, keyword))
+            {
+                FatalError("%s(%d) => Duplicate output keyword!\n", 
+                        file_name, file_line);
+            }
+            idx = idx->next;
+        }
+
+        idx->next = (OutputKeywordList *)SnortAlloc(sizeof(OutputKeywordList));
+
+        idx = idx->next;
+    }
+
+    /* alloc space for the keyword */
+    idx->entry.keyword = (char *)SnortAlloc((strlen(keyword) + 1) * sizeof(char));
+
+    /* copy the keyword into the struct */
+    SnortStrncpy(idx->entry.keyword, keyword, strlen(keyword) + 1);
+
+    /*
+     * set the plugin type, needed to determine whether an overriding command
+     * line arg has been specified
+     */
+    idx->entry.node_type = (char) type;
+
+    /* set the function pointer to the keyword handler function */
+    idx->entry.func = (void (*)(char *))func;
+}
+
+
+/****************************************************************************
+ *
+ * Function: DumpOutputPlugins()
+ *
+ * Purpose:  Prints the keyword->preprocess list
+ *
+ * Arguments: None.
+ *
+ * Returns: void function
+ *
+ ***************************************************************************/
+void DumpOutputPlugins()
+{
+    OutputKeywordList *idx;
+
+    if(pv.quiet_flag)
+        return;
+
+    idx = OutputKeywords;
+
+    printf("-------------------------------------------------\n");
+    printf(" Keyword     |          Output @ \n");
+    printf("-------------------------------------------------\n");
+    while(idx != NULL)
+    {
+        printf("%-13s:       %p\n", idx->entry.keyword, idx->entry.func);
+        idx = idx->next;
+    }
+    printf("-------------------------------------------------\n\n");
+}
+
+extern ListHead *head_tmp;
+
+void AddFuncToOutputList(void (*func) (Packet *, char *, void *, Event *),
+        char node_type, void *arg)
+{
+    switch(node_type)
+    {
+        case NT_OUTPUT_ALERT:
+            if(head_tmp != NULL)
+                head_tmp->AlertList = AppendOutputFuncList(func, arg,
+                        head_tmp->AlertList);
+            else
+                AlertList = AppendOutputFuncList(func, arg, AlertList);
+            break;
+
+        case NT_OUTPUT_LOG:
+            if(head_tmp != NULL)
+                head_tmp->LogList = AppendOutputFuncList(func, arg,
+                        head_tmp->LogList);
+            else
+                LogList = AppendOutputFuncList(func, arg, LogList);
+            break;
+
+        default:
+            /* just to be error-prone */
+            FatalError("Unknown nodetype: %i. Possible bug, please report\n",
+                    node_type);
+    }
+
+    return;
+}
+
+
+OutputFuncNode *AppendOutputFuncList(
+        void (*func) (Packet *, char *, void *, Event *),
+        void *arg, OutputFuncNode * list)
+{
+    OutputFuncNode *idx = list;
+
+    if(idx == NULL)
+    {
+        idx = (OutputFuncNode *)SnortAlloc(sizeof(OutputFuncNode));
+        idx->func = func;
+        idx->arg = arg;
+        list = idx;
+    }
+    else
+    {
+        while(idx->next != NULL)
+            idx = idx->next;
+
+        idx->next = (OutputFuncNode *)SnortAlloc(sizeof(OutputFuncNode));
+        idx = idx->next;
+        idx->func = func;
+        idx->arg = arg;
+    }
+
+    idx->next = NULL;
+
+    return list;
+}
+
+/*
+ * frees the existing OutputList ands sets it a single node for the
+ * function argument
+ */
+void SetOutputList(void (*func) (Packet *, char *, void *, Event *),
+        char node_type, void *arg)
+{
+    OutputFuncNode *idx;
+    OutputFuncNode *prev;
+
+    switch(node_type)
+    {
+        case NT_OUTPUT_ALERT:
+            prev = AlertList;
+            break;
+
+        case NT_OUTPUT_LOG:
+            prev = LogList;
+            break;
+
+        default:
+            return;
+    }
+
+    while(prev != NULL)
+    {
+        idx = prev->next;
+        free(prev);
+        prev = idx;
+    }
+
+    switch(node_type)
+    {
+        case NT_OUTPUT_ALERT:
+            AlertList = prev;
+            break;
+
+        case NT_OUTPUT_LOG:
+            LogList = prev;
+            break;
+
+        default:
+            return;
+    }
+
+    AddFuncToOutputList(func, node_type, arg);
+
+    return;
+}
+
+
+
+/*************************** End Output Plugin API  ***************************/
+
+
+/************************** Miscellaneous Functions  **************************/
+
+int PacketIsIP(Packet * p)
+{
+    if(p->iph != NULL)
+        return 1;
+
+    return 0;
+}
+
+
+
+int PacketIsTCP(Packet * p)
+{
+    if(p->iph != NULL && p->tcph != NULL)
+        return 1;
+
+    return 0;
+}
+
+
+
+int PacketIsUDP(Packet * p)
+{
+    if(p->iph != NULL && p->udph != NULL)
+        return 1;
+
+    return 0;
+}
+
+
+
+int PacketIsICMP(Packet * p)
+{
+    if(p->iph != NULL && p->icmph != NULL)
+        return 1;
+
+    return 0;
+}
+
+
+
+int DestinationIpIsHomenet(Packet * p)
+{
+    if((p->iph->ip_dst.s_addr & pv.netmask) == pv.homenet)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+
+
+int SourceIpIsHomenet(Packet * p)
+{
+    if((p->iph->ip_src.s_addr & pv.netmask) == pv.homenet)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+int CheckNet(struct in_addr * compare, struct in_addr * compare2)
+{
+    if(compare->s_addr == compare2->s_addr)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+/* functions to aid in cleaning up aftre plugins */
+void AddFuncToRestartList(void (*func) (int, void *), void *arg)
+{
+    PluginRestartList = AddFuncToSignalList(func, arg, PluginRestartList);
+}
+
+void AddFuncToCleanExitList(void (*func) (int, void *), void *arg)
+{
+    PluginCleanExitList = AddFuncToSignalList(func, arg, PluginCleanExitList);
+}
+
+void AddFuncToShutdownList(void (*func) (int, void *), void *arg)
+{
+    PluginShutdownList = AddFuncToSignalList(func, arg, PluginShutdownList);
+}
+
+void AddFuncToPostConfigList(void (*func)(int, void *), void *arg)
+{
+    PluginPostConfigList = AddFuncToSignalList(func, arg, PluginPostConfigList);
+}
+
+PluginSignalFuncNode *AddFuncToSignalList(void (*func) (int, void *), void *arg,
+                                          PluginSignalFuncNode * list)
+{
+    PluginSignalFuncNode *idx;
+
+    idx = list;
+
+    if(idx == NULL)
+    {
+        idx = (PluginSignalFuncNode *)SnortAlloc(sizeof(PluginSignalFuncNode));
+
+        idx->func = func;
+        idx->arg = arg;
+        list = idx;
+    }
+    else
+    {
+        while(idx->next != NULL)
+            idx = idx->next;
+
+        idx->next = (PluginSignalFuncNode *)SnortAlloc(sizeof(PluginSignalFuncNode));
+
+        idx = idx->next;
+        idx->func = func;
+        idx->arg = arg;
+    }
+    idx->next = NULL;
+
+    return list;
+}
+
+
+/****************************************************************************
+ *
+ * Function: GetUniqueName(char * iface)
+ *
+ * Purpose: To return a string that has a high probability of being unique
+ *          for a given sensor.
+ *
+ * Arguments: char * iface - The network interface you are sniffing
+ *
+ * Returns: A char * -- its a static char * so you should not free it
+ *
+ ***************************************************************************/
+char *GetUniqueName(char * iface)
+{
+    char * rptr;
+    static char uniq_name[256];
+
+    if (iface == NULL) LogMessage("Interface is NULL. Name may not be unique for the host\n");
+#ifndef WIN32
+    rptr = GetIP(iface); 
+    if(rptr == NULL || !strcmp(rptr, "unknown"))
+#endif
+    {
+        SnortSnprintf(uniq_name, 255, "%s:%s\n",GetHostname(),iface);
+        rptr = uniq_name; 
+    }
+    if (pv.verbose_flag) LogMessage("Node unique name is: %s\n", rptr);
+    return rptr;
+}    
+
+/****************************************************************************
+ *
+ * Function: GetIP(char * iface)
+ *
+ * Purpose: To return a string representing the IP address for an interface
+ *
+ * Arguments: char * iface - The network interface you want to find an IP
+ *            address for.
+ *
+ * Returns: A char * -- make sure you call free on this when you are done
+ *          with it.
+ *
+ ***************************************************************************/
+char *GetIP(char * iface)
+{
+    struct ifreq ifr;
+    struct sockaddr_in *addr;
+    int s;
+
+    if(iface)
+    {
+        /* Set up a dummy socket just so we can use ioctl to find the
+           ip address of the interface */
+        s = socket(PF_INET, SOCK_DGRAM, 0);
+        if(s == -1)
+        {
+            FatalError("Problem establishing socket to find IP address for interface: %s\n", iface);
+        }
+
+        SnortStrncpy(ifr.ifr_name, iface, strlen(iface) + 1);
+
+#ifndef WIN32
+        if(ioctl(s, SIOCGIFADDR, &ifr) < 0) return NULL;
+        else
+#endif
+        {
+            addr = (struct sockaddr_in *) &ifr.ifr_broadaddr;
+        }
+        close(s);
+
+        return SnortStrdup(inet_ntoa(addr->sin_addr));
+    }
+    else
+    {
+        return "unknown";
+    }
+}
+
+/****************************************************************************
+ *
+ * Function: GetHostname()
+ *
+ * Purpose: To return a string representing the hostname
+ *
+ * Arguments: None
+ *
+ * Returns: A static char * representing the hostname. 
+ *
+ ***************************************************************************/
+char *GetHostname()
+{
+#ifdef WIN32
+    DWORD bufflen = 256;
+    static char buff[256];
+    GetComputerName(buff, &bufflen);
+    return buff;
+#else
+    char * error = "unknown";
+    if(getenv("HOSTNAME")) return getenv("HOSTNAME");
+    else if(getenv("HOST")) return getenv("HOST");
+    else return error;
+#endif
+}
+
+/****************************************************************************
+ *
+ * Function: GetTimestamp(register const struct timeval *tvp, int tz)
+ *
+ * Purpose: Get an ISO-8601 formatted timestamp for tvp within the tz
+ *          timezone. 
+ *
+ * Arguments: tvp is a timeval pointer. tz is a timezone. 
+ *
+ * Returns: char * -- You must free this char * when you are done with it.
+ *
+ ***************************************************************************/
+char *GetTimestamp(register const struct timeval *tvp, int tz)
+{
+    struct tm *lt;  /* localtime */
+    char * buf;
+    int msec;
+
+    buf = (char *)SnortAlloc(SMALLBUFFER * sizeof(char));
+
+    msec = tvp->tv_usec / 1000;
+
+    if(pv.use_utc == 1)
+    {
+        lt = gmtime((time_t *)&tvp->tv_sec);
+        SnortSnprintf(buf, SMALLBUFFER, "%04i-%02i-%02i %02i:%02i:%02i.%03i",
+                1900 + lt->tm_year, lt->tm_mon + 1, lt->tm_mday,
+                lt->tm_hour, lt->tm_min, lt->tm_sec, msec);
+    }
+    else
+    {
+        lt = localtime((time_t *)&tvp->tv_sec);
+        SnortSnprintf(buf, SMALLBUFFER,
+                "%04i-%02i-%02i %02i:%02i:%02i.%03i+%03i",
+                1900 + lt->tm_year, lt->tm_mon + 1, lt->tm_mday,
+                lt->tm_hour, lt->tm_min, lt->tm_sec, msec, tz);
+    }
+
+    return buf;
+}
+
+/****************************************************************************
+ *
+ * Function: GetLocalTimezone()
+ *
+ * Purpose: Find the offset from GMT for current host
+ *
+ * Arguments: none 
+ *
+ * Returns: int representing the offset from GMT
+ *
+ ***************************************************************************/
+int GetLocalTimezone()
+{
+    time_t      ut;
+    struct tm * ltm;
+    long        seconds_away_from_utc;
+
+    time(&ut);
+    ltm = localtime(&ut);
+
+#if defined(WIN32) || defined(SOLARIS) || defined(AIX)
+    /* localtime() sets the global timezone variable,
+       which is defined in <time.h> */
+    seconds_away_from_utc = timezone;
+#else
+    seconds_away_from_utc = ltm->tm_gmtoff;
+#endif
+
+    return  seconds_away_from_utc/3600;
+}
+
+/****************************************************************************
+ *
+ * Function: GetCurrentTimestamp()
+ *
+ * Purpose: Generate an ISO-8601 formatted timestamp for the current time.
+ *
+ * Arguments: none 
+ *
+ * Returns: char * -- You must free this char * when you are done with it.
+ *
+ ***************************************************************************/
+char *GetCurrentTimestamp()
+{
+    struct tm *lt;
+    struct timezone tz;
+    struct timeval tv;
+    struct timeval *tvp;
+    char * buf;
+    int tzone;
+    int msec;
+
+    buf = (char *)SnortAlloc(SMALLBUFFER * sizeof(char));
+
+    bzero((char *)&tz,sizeof(tz));
+    gettimeofday(&tv,&tz);
+    tvp = &tv;
+
+    msec = tvp->tv_usec/1000;
+
+    if(pv.use_utc == 1)
+    {
+        lt = gmtime((time_t *)&tvp->tv_sec);
+        SnortSnprintf(buf, SMALLBUFFER, "%04i-%02i-%02i %02i:%02i:%02i.%03i",
+                1900 + lt->tm_year, lt->tm_mon + 1, lt->tm_mday,
+                lt->tm_hour, lt->tm_min, lt->tm_sec, msec);
+    }
+    else
+    {
+        lt = localtime((time_t *)&tvp->tv_sec);
+
+        tzone = GetLocalTimezone();
+
+        SnortSnprintf(buf, SMALLBUFFER,
+                "%04i-%02i-%02i %02i:%02i:%02i.%03i+%03i",
+                1900 + lt->tm_year, lt->tm_mon + 1, lt->tm_mday,
+                lt->tm_hour, lt->tm_min, lt->tm_sec, msec, tzone);
+    }
+
+    return buf;
+}
+
+/****************************************************************************
+ * Function: base64(char * xdata, int length)
+ *
+ * Purpose: Insert data into the database
+ *
+ * Arguments: xdata  => pointer to data to base64 encode
+ *            length => how much data to encode 
+ *
+ * Make sure you allocate memory for the output before you pass
+ * the output pointer into this function. You should allocate 
+ * (1.5 * length) bytes to be safe.
+ *
+ * Returns: data base64 encoded as a char *
+ *
+ ***************************************************************************/
+char * base64(u_char * xdata, int length)
+{
+    int count, cols, bits, c, char_count;
+    unsigned char alpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";  /* 64 bytes */
+    char * payloadptr;
+    char * output;
+    char_count = 0;
+    bits = 0;
+    cols = 0;
+
+    output = (char *)SnortAlloc( ((unsigned int) (length * 1.5 + 4)) * sizeof(char) );
+
+    payloadptr = output;
+
+    for(count = 0; count < length; count++)
+    {
+        c = xdata[count];
+
+        if(c > 255)
+        {
+            ErrorMessage("plugbase.c->base64(): encountered char > 255 (decimal %d)\n If you see this error message a char is more than one byte on your machine\n This means your base64 results can not be trusted", c);
+        }
+
+        bits += c;
+        char_count++;
+
+        if(char_count == 3)
+        {
+            *output = alpha[bits >> 18]; output++;
+            *output = alpha[(bits >> 12) & 0x3f]; output++;
+            *output = alpha[(bits >> 6) & 0x3f]; output++;
+            *output = alpha[bits & 0x3f]; output++; 
+            cols += 4;
+            if(cols == 72)
+            {
+                *output = '\n'; output++;
+                cols = 0;
+            }
+            bits = 0;
+            char_count = 0;
+        }
+        else
+        {
+            bits <<= 8;
+        }
+    }
+
+    if(char_count != 0)
+    {
+        bits <<= 16 - (8 * char_count);
+        *output = alpha[bits >> 18]; output++;
+        *output = alpha[(bits >> 12) & 0x3f]; output++;
+        if(char_count == 1)
+        {
+            *output = '='; output++;
+            *output = '='; output++;
+        }
+        else
+        {
+            *output = alpha[(bits >> 6) & 0x3f]; 
+            output++; *output = '='; 
+            output++;
+        }
+    }
+    *output = '\0';
+    return payloadptr;
+} 
+
+/****************************************************************************
+ *
+ * Function: ascii(u_char *xdata, int length)
+ *
+ * Purpose: This function takes takes a buffer "xdata" and its length then
+ *          returns a string of only the printible ASCII characters.
+ *
+ * Arguments: xdata is the buffer, length is the length of the buffer in
+ *            bytes
+ *
+ * Returns: char * -- You must free this char * when you are done with it.
+ *
+ ***************************************************************************/
+char *ascii(u_char *xdata, int length)
+{
+     char *d_ptr, *ret_val;
+     int i,count = 0;
+     int size;
+     
+     if(xdata == NULL)
+     {
+         return NULL;         
+     }
+     
+     for(i=0;i<length;i++)
+     {
+         if(xdata[i] == '<')
+             count+=4;              /* &lt; */
+         else if(xdata[i] == '&')
+             count+=5;              /* &amp; */
+         else if(xdata[i] == '>')   /* &gt;  */
+             count += 4;
+     }
+
+     size = length + count + 1;
+     ret_val = (char *) calloc(1,size);
+     
+     if(ret_val == NULL)
+     {
+         LogMessage("plugbase.c: ascii(): Out of memory, can't log anything!\n");
+         return NULL;
+     }
+     
+     d_ptr = ret_val; 
+     
+     for(i=0;i<length;i++)
+     {
+         if((xdata[i] > 0x1F) && (xdata[i] < 0x7F))
+         {
+             if(xdata[i] == '<')
+             {
+                 SnortStrncpy(d_ptr, "&lt;", size - (d_ptr - ret_val));
+                 d_ptr+=4;
+             }
+             else if(xdata[i] == '&')
+             {
+                 SnortStrncpy(d_ptr, "&amp;", size - (d_ptr - ret_val));
+                 d_ptr += 5;
+             }
+             else if(xdata[i] == '>')
+             {
+                 SnortStrncpy(d_ptr, "&gt;", size - (d_ptr - ret_val));
+                 d_ptr += 4;
+             }
+             else
+             {
+                 *d_ptr++ = xdata[i];
+             }
+         }
+         else
+         {
+             *d_ptr++ = '.';
+         }        
+     }
+     
+     *d_ptr++ = '\0';
+     
+     return ret_val;
+}
+
+/****************************************************************************
+ *
+ * Function: hex(u_char *xdata, int length)
+ *
+ * Purpose: This function takes takes a buffer "xdata" and its length then
+ *          returns a string of hex with no spaces
+ *
+ * Arguments: xdata is the buffer, length is the length of the buffer in
+ *            bytes
+ *
+ * Returns: char * -- You must free this char * when you are done with it.
+ *
+ ***************************************************************************/
+char *hex(u_char *xdata, int length)
+{
+    int x;
+    char *rval = NULL;
+    char *buf = NULL;
+
+    if (xdata == NULL)
+        return NULL;
+
+    buf = (char *)calloc((length * 2) + 1, sizeof(char));
+
+    if (buf != NULL)
+    {
+        rval = buf;
+
+        for (x = 0; x < length; x++)
+        {
+            SnortSnprintf(buf, 3, "%02X", xdata[x]);
+            buf += 2;
+        } 
+
+        rval[length * 2] = '\0';
+    }
+
+    return rval;
+}
+
+
+
+char *fasthex(u_char *xdata, int length)
+{
+    char conv[] = "0123456789ABCDEF";
+    char *retbuf = NULL; 
+    char *index;
+    char *end;
+    char *ridx;
+
+    index = xdata;
+    end = xdata + length;
+    retbuf = (char *)SnortAlloc(((length * 2) + 1) * sizeof(char));
+    ridx = retbuf;
+
+    while(index < end)
+    {
+        *ridx++ = conv[((*index & 0xFF)>>4)];
+        *ridx++ = conv[((*index & 0xFF)&0x0F)];
+        index++;
+    }
+
+    return retbuf;
+}
+
diff -rNu snort-2.7.0/src/preprocessors/Makefile.am snort-2.7.0.mod/src/preprocessors/Makefile.am
--- snort-2.7.0/src/preprocessors/Makefile.am	2007-02-02 16:15:51.000000000 +0100
+++ snort-2.7.0.mod/src/preprocessors/Makefile.am	2007-09-06 20:15:11.000000000 +0200
@@ -6,6 +6,8 @@
 SUBDIRS = flow HttpInspect Stream5
 
 libspp_a_SOURCES = spp_arpspoof.c spp_arpspoof.h spp_bo.c spp_bo.h \
+spp_spade.c spp_spade.h \
+spp_spade.c spp_spade.h \
 spp_rpc_decode.c spp_rpc_decode.h  \
 spp_stream4.c spp_stream4.h stream.h \
 snort_stream4_session.c snort_stream4_session.h \
diff -rNu snort-2.7.0/src/preprocessors/Makefile.in snort-2.7.0.mod/src/preprocessors/Makefile.in
--- snort-2.7.0/src/preprocessors/Makefile.in	2007-07-16 14:12:31.000000000 +0200
+++ snort-2.7.0.mod/src/preprocessors/Makefile.in	2007-09-06 20:15:11.000000000 +0200
@@ -51,6 +51,8 @@
 libspp_a_AR = $(AR) $(ARFLAGS)
 libspp_a_LIBADD =
 am_libspp_a_OBJECTS = spp_arpspoof.$(OBJEXT) spp_bo.$(OBJEXT) \
+	spp_spade.$(OBJEXT) \
+	spp_spade.$(OBJEXT) \
 	spp_rpc_decode.$(OBJEXT) spp_stream4.$(OBJEXT) \
 	snort_stream4_session.$(OBJEXT) snort_stream4_udp.$(OBJEXT) \
 	stream_ignore.$(OBJEXT) spp_perfmonitor.$(OBJEXT) \
diff -rNu snort-2.7.0/src/preprocessors/Makefile.in.orig snort-2.7.0.mod/src/preprocessors/Makefile.in.orig
--- snort-2.7.0/src/preprocessors/Makefile.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/preprocessors/Makefile.in.orig	2007-07-16 14:12:31.000000000 +0200
@@ -0,0 +1,559 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/preprocessors
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libprelude.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libspp_a_AR = $(AR) $(ARFLAGS)
+libspp_a_LIBADD =
+am_libspp_a_OBJECTS = spp_arpspoof.$(OBJEXT) spp_bo.$(OBJEXT) \
+	spp_rpc_decode.$(OBJEXT) spp_stream4.$(OBJEXT) \
+	snort_stream4_session.$(OBJEXT) snort_stream4_udp.$(OBJEXT) \
+	stream_ignore.$(OBJEXT) spp_perfmonitor.$(OBJEXT) \
+	perf.$(OBJEXT) perf-base.$(OBJEXT) perf-flow.$(OBJEXT) \
+	perf-event.$(OBJEXT) sfprocpidstats.$(OBJEXT) \
+	spp_httpinspect.$(OBJEXT) snort_httpinspect.$(OBJEXT) \
+	spp_flow.$(OBJEXT) portscan.$(OBJEXT) spp_sfportscan.$(OBJEXT) \
+	spp_frag3.$(OBJEXT) str_search.$(OBJEXT) spp_stream5.$(OBJEXT) \
+	stream_api.$(OBJEXT)
+libspp_a_OBJECTS = $(am_libspp_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libspp_a_SOURCES)
+DIST_SOURCES = $(libspp_a_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+HAVE_DYNAMIC_PLUGINS_FALSE = @HAVE_DYNAMIC_PLUGINS_FALSE@
+HAVE_DYNAMIC_PLUGINS_TRUE = @HAVE_DYNAMIC_PLUGINS_TRUE@
+INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBPRELUDE_CFLAGS = @LIBPRELUDE_CFLAGS@
+LIBPRELUDE_CONFIG = @LIBPRELUDE_CONFIG@
+LIBPRELUDE_CONFIG_PREFIX = @LIBPRELUDE_CONFIG_PREFIX@
+LIBPRELUDE_LDFLAGS = @LIBPRELUDE_LDFLAGS@
+LIBPRELUDE_LIBS = @LIBPRELUDE_LIBS@
+LIBPRELUDE_PREFIX = @LIBPRELUDE_PREFIX@
+LIBPRELUDE_PTHREAD_CFLAGS = @LIBPRELUDE_PTHREAD_CFLAGS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+AUTOMAKE_OPTIONS = foreign no-dependencies
+noinst_LIBRARIES = libspp.a
+SUBDIRS = flow HttpInspect Stream5
+libspp_a_SOURCES = spp_arpspoof.c spp_arpspoof.h spp_bo.c spp_bo.h \
+spp_rpc_decode.c spp_rpc_decode.h  \
+spp_stream4.c spp_stream4.h stream.h \
+snort_stream4_session.c snort_stream4_session.h \
+snort_stream4_udp.c snort_stream4_udp.h \
+stream_ignore.c stream_ignore.h \
+spp_perfmonitor.c spp_perfmonitor.h \
+perf.c perf.h \
+perf-base.c perf-base.h \
+perf-flow.c perf-flow.h \
+perf-event.c perf-event.h \
+sfprocpidstats.c sfprocpidstats.h \
+spp_httpinspect.c spp_httpinspect.h \
+snort_httpinspect.c snort_httpinspect.h \
+spp_flow.c spp_flow.h \
+portscan.c portscan.h \
+spp_sfportscan.c spp_sfportscan.h \
+spp_frag3.c spp_frag3.h \
+str_search.c str_search.h \
+spp_stream5.c spp_stream5.h \
+stream_api.c stream_api.h
+
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/preprocessors/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libspp.a: $(libspp_a_OBJECTS) $(libspp_a_DEPENDENCIES) 
+	-rm -f libspp.a
+	$(libspp_a_AR) libspp.a $(libspp_a_OBJECTS) $(libspp_a_LIBADD)
+	$(RANLIB) libspp.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.c.o:
+	$(COMPILE) -c $<
+
+.c.obj:
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LIBRARIES)
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-libtool clean-noinstLIBRARIES \
+	clean-recursive ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rNu snort-2.7.0/src/preprocessors/spp_spade.c snort-2.7.0.mod/src/preprocessors/spp_spade.c
--- snort-2.7.0/src/preprocessors/spp_spade.c	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/preprocessors/spp_spade.c	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,7480 @@
+/*********************************************************************
+Spade, a Snort preprocessor plugin to report unusual packets
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
+
+Spade description:
+
+SPADE, the Statistical Packet Anomaly Detection Engine, is a Snort
+preprocessor plugin to report packets that are unusual for your network. 
+Port scans and probes tend to be unusual, so this will tend to report them
+(as well as some benign packets that are simply uncommon).
+
+Spade's home page: http://www.silicondefense.com/spice/
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com. This is a research project and would love to
+have your feedback.  It is still under active development and may change at
+any time.
+
+This file (snort_spade.c) is part of Spade v030125.1.  It makes netspade
+available via a snort plugin.
+*********************************************************************/
+
+/* Internal version control: Id: snort_spade.c,v 1.2 2005/09/02 18:31:18 jebrahimi Exp $ */
+ 
+/*! \file snort_spade.c
+ * \brief 
+ *  snort_spade.c makes netspade available to snort
+ * \ingroup snort_spade
+ */
+
+/*! \addtogroup snort_spade Netspade for Snort
+ * \brief this group contains objects in the Snort binding to netspade
+ * @{
+*/
+
+/*! \addtogroup libnetspade */
+
+#define ENABLE_IDMEF 0
+
+
+/* this should be in generators.h */
+#ifndef SPADE_CLOSED_DESTPORT_USED
+#define     SPADE_CLOSED_DESTPORT_USED   1
+#define     SPADE_NONLIVE_DEST_USED   3
+#define     SPADE_SRC_ODD_DESTPORT_USED   4
+#define     SPADE_SRC_ODD_TYPECODE_USED   5
+#define     SPADE_SRC_ODD_PORTDEST_USED   6
+#endif
+ 
+#include "snort.h"
+#include "plugbase.h"
+#include "generators.h"
+#include "util.h"
+#include "parser.h"
+#include "log.h"
+#include "detect.h"
+#if ENABLE_IDMEF
+#include "../output-plugins/spo_idmef.h"
+#endif
+#include "packets.h"
+#include "spp_spade.h"
+#include <string.h>
+#include <stdarg.h>
+#include <signal.h>
+
+/** external globals from parser.c **/
+extern char *file_name;
+extern int file_line;
+
+static void SpadeReportAnom(void *context,spade_report *rpt);
+static void SpadeReportThreshChanged(void *context, char *id,char *mess, int using_corrscore);
+static void SnortSpadeMsgFn(spade_message_type msg_type,const char *msg);
+
+/// our instance of netspade
+netspade *spade;
+
+#define DEST_NOWHERE 0
+#define DEST_ALERT_FACILITY 1
+#define DEST_LOG_FACILITY 2
+#define DEST_IDMEF_FACILITY 4
+
+/// where to send spade alerts
+int spade_alert_dest= DEST_ALERT_FACILITY;
+/// where to send spade threshold adjusted messages
+int spade_adj_dest= DEST_ALERT_FACILITY;
+
+/// the bigger the number, the more debuging statements that are active
+int as_debug= 0; 
+
+/// is threshold adapting enabled?
+int adapt_active= 0;
+/// the number of detectors that have been enabled
+int num_detectors= 0;
+/// how many packets has Snort passed to us
+int pkt_count= 0;
+
+/*************/
+
+/* A call to this function needs to be added to plugbase.c somehow */
+void SetupSpade()
+{
+    /* link the preprocessor keyword list to the init functions in 
+       the preproc list to arrange for modules to run when specified */
+    RegisterPreprocessor("spade", SpadeInit);
+    RegisterPreprocessor("spade-homenet", SpadeHomenetInit);
+    RegisterPreprocessor("spade-detect", SpadeDetectInit);
+    RegisterPreprocessor("spade-stats", SpadeStatInit);
+    RegisterPreprocessor("spade-threshlearn", SpadeThreshadviseInit); /* for backwards compatability */
+    RegisterPreprocessor("spade-threshadvise", SpadeThreshadviseInit);
+    RegisterPreprocessor("spade-adapt", SpadeAdaptInit);
+    RegisterPreprocessor("spade-adapt2", SpadeAdapt2Init);
+    RegisterPreprocessor("spade-adapt3", SpadeAdapt3Init);
+    RegisterPreprocessor("spade-survey", SpadeSurveyInit);
+
+    if (as_debug) printf("Preprocessor: Spade is setup...\n");
+}
+
+
+
+/*========================================================================*/
+/*========================= Spade core routines ==========================*/
+/*========================================================================*/
+
+/* Spade core init function:
+     set up netspade, recover, register the signal handler,
+     register the preprocessor function */
+void SpadeInit(u_char *argsstr)
+{
+    int prob_mode=3,checkpoint_freq=50000,recover;
+    double init_thresh= -1;
+    char statefile[401]= "spade.rcv";
+    char outfile[401]= "-";
+    int use_corrscore= 0;
+    char dest[11]= "alert";
+    char adjdest[11]= "\0";
+    char xsips[401]="",xdips[401]="",xsports[401]="",xdports[401]="";
+    void *args[12];
+
+    args[0]= &init_thresh;
+    args[1]= &statefile;
+    args[2]= &outfile;
+    args[3]= &prob_mode;
+    args[4]= &checkpoint_freq;
+    args[5]= &use_corrscore;
+    args[6]= &dest;
+    args[7]= &adjdest;
+    args[8]= &xsips;
+    args[9]= &xdips;
+    args[10]= &xsports;
+    args[11]= &xdports;
+    fill_args_space_sep(argsstr,"d:thresh;s400:statefile;s400:logfile;"
+            "i:probmode;i:cpfreq;b:-corrscore,corrscore;s10:dest;s10:adjdest;"
+            "s400:Xsips,Xsip,xsips;s400:Xdips,Xdip,xdips;"
+            "s400:Xsports,Xsport,xsports;s400:Xdports,Xdport,xdports",args,SnortSpadeMsgFn);
+
+    if (as_debug) printf("statefile=%s; logfile=%s; cpfreq=%d\n",statefile,outfile,checkpoint_freq);
+
+    LogMessage("Spade is enabled\n");
+    recover= strcmp(statefile,"0") && strcmp(statefile,"/dev/null");
+
+    if (recover) {
+        spade= new_netspade_from_statefile(statefile,SnortSpadeMsgFn,as_debug,&recover);
+        if (recover)
+            LogMessage("    Spade state initialized to what is in %s\n",statefile);
+        else
+            LogMessage("    Could not load Spade state from %s\n",statefile);
+    }
+
+    if (!recover) {
+        spade= new_netspade(SnortSpadeMsgFn,as_debug);
+        LogMessage("    Spade state initialized to a clean slate (no prior knowledge)\n");
+    }
+    if (spade == NULL) {
+        FatalError("Spade initialization failed: out of memory!");
+    }
+
+    netspade_set_checkpointing(spade,statefile,checkpoint_freq);
+    LogMessage("    Spade will record its state to %s after every %d updates\n",statefile,checkpoint_freq);
+    netspade_set_output_file(spade,outfile);
+    LogMessage("    Spade's log is %s\n",outfile);
+
+    if (!strcmp(dest,"log")) {
+        LogMessage("    Spade reports will go to the log facility\n");
+        spade_alert_dest= DEST_LOG_FACILITY;
+    } else if (!strcmp(dest,"both")) {
+        LogMessage("    Spade reports will go to both the alert and log facility\n");
+        spade_alert_dest= DEST_ALERT_FACILITY|DEST_LOG_FACILITY;
+#if ENABLE_IDMEF
+    } else if (!strcmp(dest,"spo_idmef")) {
+        LogMessage("    Spade reports will go directly to the IDMEF facility\n");
+        spade_alert_dest= DEST_IDMEF_FACILITY;
+#endif
+    } else {
+        if (strcmp(dest,"alert"))
+            ErrorMessage("Spade: dest=%s not recognized, using dest=alert\n",dest);
+        LogMessage("    Spade reports will go to the alert facility\n");
+        spade_alert_dest= DEST_ALERT_FACILITY;
+    }
+    if (adjdest[0] == '\0') {
+        spade_adj_dest= spade_alert_dest;
+    } else {
+        if (!strcmp(adjdest,"log")) {
+            LogMessage("    Spade threshold adjusted reports will go to the log facility\n");
+            spade_adj_dest= DEST_LOG_FACILITY;
+        } else if (!strcmp(adjdest,"both")) {
+            LogMessage("    Spade threshold adjusted reports will go to both the alert and log facility\n");
+            spade_adj_dest= DEST_ALERT_FACILITY|DEST_LOG_FACILITY;
+        } else if (!strcmp(adjdest,"none")) {
+            LogMessage("    Spade threshold adjusted reports will not be reported\n");
+            spade_adj_dest= DEST_NOWHERE;
+        } else {
+            if (strcmp(adjdest,"alert"))
+                ErrorMessage("Spade: adjdest=%s not recognized, using adjdest=alert\n",adjdest);
+            LogMessage("    Spade threshold adjusted reports will go to the alert facility\n");
+            spade_adj_dest= DEST_ALERT_FACILITY;
+        }
+    }
+    netspade_set_callbacks(spade,NULL,SpadeReportAnom,((spade_adj_dest == DEST_NOWHERE) ? NULL : SpadeReportThreshChanged),(event_native_copier_t)ClonePacket,(event_native_freer_t)FreePacket);
+    
+    netspade_add_rpt_excludes(spade,xsips,xdips,xsports,xdports);
+    
+    /* at this point we don't know if there are any spade-detect lines, but
+       if this looks like the old form of this line (corrscore, thresh, or
+       probmode is specified).  Our approximation of specified is variance
+       from defaults.  Because our defaults are the same as netspade's
+       default detection mode, if the user did explicitly set things to the
+       default and provides no spade-detect line, the default detector will
+       be enabled in netspade automatically with the configuration we want. */
+       
+    if (prob_mode != 3 || init_thresh != -1 || use_corrscore) {
+        char init_detect_str[100];
+        /* backwards compatability mode */
+        if (prob_mode > 4 || prob_mode < 0) {
+            ErrorMessage("Warning: Spade probabity mode %d undefined, using #3 instead",prob_mode);
+            prob_mode= 3;
+        }
+        if (as_debug) printf("thresh=%f; probmode=%d; corrscore=%d\n",init_thresh,prob_mode,use_corrscore);
+
+        sprintf(init_detect_str,"id=default relscore=0  corrscore=0 thresh=%f probmode=%d corrscore=%d",
+                                                init_thresh,prob_mode,use_corrscore);
+        netspade_new_detector(spade,init_detect_str);
+        
+        LogMessage("    default detector enabled with: %s\n",init_detect_str);
+        num_detectors++;
+
+        if (as_debug) netspade_print_detector_config_details(spade,stdout,"default");
+    }       
+    
+
+   /* Set the preprocessor function into the function list */
+    AddFuncToPreprocList(PreprocSpade,GENERATOR_SPP_SPADE,10000);
+    AddFuncToCleanExitList(SpadeCatchSig,NULL);
+    AddFuncToRestartList(SpadeCatchSig,NULL);
+}
+
+
+/*========================================================================*/
+/*========================= SpadeHomenet module ==========================*/
+/*========================================================================*/
+
+/* Set the Spade homenet */
+
+/* snort config file line:
+    preprocessor spade-homenet: {<network>}
+    where <network> is a network in CIDR notation (address/numbits)
+                       or an IP address */
+                                                        
+/* Spade homenet init function:
+     set up the homenet list */
+void SpadeHomenetInit(u_char *args)
+{
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-homenet: %s(%d)\n",
+        file_name,file_line);
+
+    netspade_set_homenet_from_str(spade,args);
+    LogMessage("    Spade homenet set to: %s\n",args);
+}
+
+
+
+/*========================================================================*/
+/*======================== SpadeDetect module ==========================*/
+/*========================================================================*/
+
+/* enable a Spade detector */                                                     
+void SpadeDetectInit(u_char *args)
+{
+    char *id;
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-detect: %s(%d)\n",
+        file_name,file_line);
+
+    id= netspade_new_detector(spade,args);
+    LogMessage("    detector %s enabled with: %s\n",id,args);
+    num_detectors++;
+
+    if (as_debug) netspade_print_detector_config_details(spade,stdout,id);
+}
+
+
+/*========================================================================*/
+/*=========================== SpadeStat module ===========================*/
+/*========================================================================*/
+
+/* Whenever SpadeCatchSig is invoked, this module arranges for certain
+   specified statistics to be written to the log file.  The available
+   statistics depend on what is recorded in the tree, which depends on the
+   probability measure used.  There is no good way to have more granularity
+   at present. */
+
+/* snort config file line:
+    preprocessor spade-stats: {<stat-option>}
+    where <stat-option> is one of:
+      "entropy" (to display the known entropies and conditional entropies)
+      "uncondprob" (to display the known non-0 simple (joint) probabilities)
+      "condprob" (to display the known non-0 conditional (joint)
+probabilities) */
+                                                        
+void SpadeStatInit(u_char *args)
+{
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-stat: %s(%d)\n",
+        file_name,file_line);
+
+    /* parse the argument list from the rules file */
+    netspade_set_output_stats_from_str(spade,args);
+    LogMessage("    Spade will report certain observation statistics to its log file: %s\n",args);
+}
+
+
+
+/*========================================================================*/
+/*======================== SpadeThreshadvise module =======================*/
+/*========================================================================*/
+
+/* Given a packet count and a length of time, this module reports a reporting
+   threshold that would have been effective in producing that number of alerts
+   in that time interval.  The idea is that one might use this as a threshold
+   for future runs.  The module quietly watches the network for the length of
+   time, adding events to the tree and calculating anomaly scores.  When the
+   time period is up, the module calls exit() after reporting the top anomaly
+   scores seen to the log file. */
+   
+   /* Spade threshold learning module init function:
+     set up threshold learning module per args */
+void SpadeThreshadviseInit(u_char *args)
+{
+    char *id;
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-threshadvise (a.k.a. "
+        "spade-threshlearn): %s(%d)\n",
+        file_name,file_line);
+    
+    id=netspade_setup_detector_advise_from_str(spade,args);
+
+    LogMessage("    Spade threshold advising inited for %s: %s\n",id,args);
+}
+
+/*========================================================================*/
+/*=========================== SpadeAdapt module ==========================*/
+/*========================================================================*/
+
+/* Given a report count target and a length of time, this module tries to keep
+   the reporting threshold at a level that would produce that number of alerts
+   in that time interval based on what was observed in the last interval.  To
+   support this, a list of the most anomalous scores seen in the current
+   interval is maintained.  At the end of the interval, an ideal threshold is
+   calculated based on the interval's scores.  This is combined linearly with
+   the current threshold to produce the threshold for the next interval.  As a
+   default option, the interval can implemented in terms of a count of packets,
+   where this count is the average number of packets seen during the specified
+   time interval length; this tends to make the transitions more smooth and
+   reliable since a more constant number of anomaly scores is used in finding
+   the topmost anamolous ones. */
+
+void SpadeAdaptInit(u_char *args)
+{
+    char *id;
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-adapt: %s(%d)\n",
+        file_name,file_line);
+    if (adapt_active && num_detectors < 2) {
+        ErrorMessage("Spade threshold adapting repeatedly specified, "
+            "ignoring later specification: %s(%d)\n",file_name,file_line);
+        return;
+    }
+    adapt_active= 1;
+
+    /* parse the argument list from the rules file */
+    id= netspade_setup_detector_adapt_from_str(spade,1,args);
+    
+    LogMessage("    Spade adapt mode 1 inited for %s: %s\n",id,args);
+
+    if (as_debug) netspade_print_detector_config_details(spade,stdout,id);
+}
+
+
+/*========================================================================*/
+/*========================== SpadeAdapt2 module ==========================*/
+/*========================================================================*/
+
+/* Given an hourly alert target count (or target fraction) and a length of
+   time, this module tries to keep the reporting threshold at a level that
+   would produce that number of alerts (or fraction of total reports) in an
+   hour based on what has been observed in the past.  When the report threshold
+   is updated, it is based in equal parts on observations from the short term,
+   middle term, and long term (at least for these that have been observed). 
+   The user can specify the time period for observations, the number of those
+   that make up the short term (NS), the number of short terms that make up the
+   medium term (NM), and the number of medium terms that make up the long term
+   (NL).  The short term component of the threshold is defined to be the
+   average of the kth and (k+1)st highest anomaly scores in the last NS
+   complete periods of observation, where k is number of anamoly reports that
+   should occur in the observation period assuming a uniform rate.  The middle
+   term component is the average of the last NM special short term components. 
+   The special short term components are the ones that are multiples of NS if
+   labeled with the number of observation periods that had completed when it
+   was calculated (i.e., #NS, #2NS, #3NS, etc.); these have the property that
+   they are based entirely on distinct measurements.  The long term component
+   is based on the last NL medium term componenets, including the current one. 
+   For each of the components, if there have been less than the specified
+   number of constituant parts (but there has been at least one complete one),
+   what is observed thus far is used.  To accomadate the varying rates of
+   packets fairly, the observation period is based on a count of packets.  This
+   count is the product of the specified observation period and the average
+   packet rate.
+*/
+
+void SpadeAdapt2Init(u_char *args)
+{
+    char *id;
+    
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-adapt2: %s(%d)\n",
+        file_name,file_line);
+    if (adapt_active && num_detectors < 2) {
+        ErrorMessage("Spade threshold adapting repeatedly specified, "
+            "ignoring later specification: %s(%d)\n",file_name,file_line);
+        return;
+    }
+    adapt_active= 2;
+
+    /* parse the argument list from the rules file */
+    id= netspade_setup_detector_adapt_from_str(spade,2,args);
+    
+    LogMessage("    Spade adapt mode 2 inited for %s: %s\n",id,args);
+
+    if (as_debug) netspade_print_detector_config_details(spade,stdout,id);
+}
+
+/*========================================================================*/
+/*========================== SpadeAdapt3 module ==========================*/
+/*========================================================================*/
+
+/* Given an hourly alert target count (or target fraction) and a length of
+   time, this module tries to keep the reporting threshold at a level that
+   would produce that number of alerts (or fraction of total reports) in an
+   hour based on what has been observed in the past.  ...
+*/
+
+void SpadeAdapt3Init(u_char *args)
+{
+    char *id;
+    
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-adapt3: %s(%d)\n",
+        file_name,file_line);
+    if (adapt_active && num_detectors < 2) {
+        ErrorMessage("Spade threshold adapting repeatedly specified, "
+            "ignoring later specification: %s(%d)\n",file_name,file_line);
+        return;
+    }
+    adapt_active= 3;
+
+    /* parse the argument list from the rules file */
+    id= netspade_setup_detector_adapt_from_str(spade,3,args);
+
+    LogMessage("    Spade adapt mode 3 inited for %s: %s\n",id,args);
+}
+
+
+/*========================================================================*/
+/*========================== SpadeSurvey module ==========================*/
+/*========================================================================*/
+
+/* This module surveys the anomoly scores observed across periods of time
+and reports this to a specified survey file.  The period #, the packet
+count, the median score, the 90th percentile score, and the 99th percentile
+score are recorded to the file in tab-delinated format.  Interpolation is
+used between scores if there is no score at exactly the position implied by
+the percentile. */
+
+/* efficiency note:  This use linked list to represent the observed anomoly
+   scores.  While it is necessary to maintain all these scores (the current
+   worst score might end up being the 99th percentile), a different
+   representation (order stat tree?) should be used if the packet count gets
+   high.  */
+
+void SpadeSurveyInit(u_char *args)
+{
+    char *id;
+    
+    if (spade == NULL) FatalError("Please initialize Spade with the "
+        "'preprocessor spade:' line before listing spade-survey: %s(%d)\n",
+        file_name,file_line);
+
+    /* parse the argument list from the rules file */
+    id= netspade_setup_detector_survey_from_str(spade,args);
+
+    LogMessage("    Spade survey mode inited for %s: %s\n",id,args);
+
+    if (as_debug) netspade_print_detector_config_details(spade,stdout,id);
+}
+
+
+/*********************************************************************/
+
+/* Spade core routine that is called with each packet; be efficient! */
+void PreprocSpade(Packet *p,void *context)
+{
+    spade_event pkt;
+    pkt_count++;
+    
+    if (p == NULL || p->iph == NULL) return; /* netspade only looks at IP packets for now */
+    
+    pkt.native= p;
+    pkt.time= (time_t)p->pkth->ts.tv_sec;
+    
+    pkt.origin= PKTORIG_TOP;
+    pkt.fldval[IPPROTO]= p->iph->ip_proto;
+    
+    switch (pkt.fldval[IPPROTO]) { /* protocol-specific processing */
+    case IPPROTO_TCP:
+        if (p->tcph == NULL) return;
+        pkt.fldval[TCPFLAGS]= p->tcph->th_flags;
+        break;
+    case IPPROTO_UDP:
+        if (p->udph == NULL) return;
+        break;
+    case IPPROTO_ICMP:
+        if (p->icmph == NULL) return;
+        pkt.fldval[ICMPTYPE]= p->icmph->type;
+        pkt.fldval[ICMPTYPECODE]= (p->icmph->type << 8) | p->icmph->code;
+        break;
+    default:;
+    }
+
+    pkt.fldval[SIP]= ntohl(p->iph->ip_src.s_addr);
+    pkt.fldval[DIP]= ntohl(p->iph->ip_dst.s_addr);
+    pkt.fldval[SPORT]= p->sp;
+    pkt.fldval[DPORT]= p->dp;
+    //pkt.fldval[TTL]= p->iph->ip_ttl;
+    //pkt.fldval[WIN] = p->tcph->th_win;
+
+    netspade_new_pkt(spade,&pkt);
+    
+    if ((p->orig_iph != NULL) && (p->icmph != NULL) && (p->icmph->type == 3)) {
+        pkt.origin= PKTORIG_UNRCH;
+
+        pkt.fldval[IPPROTO]= p->orig_iph->ip_proto;
+        
+        switch (pkt.fldval[IPPROTO]) { /* protocol-specific processing */
+        case IPPROTO_TCP:
+            if (p->orig_tcph == NULL) return;
+            pkt.fldval[TCPFLAGS]= p->orig_tcph->th_flags;
+            break;
+        case IPPROTO_UDP:
+            if (p->orig_udph == NULL) return;
+            break;
+        case IPPROTO_ICMP:
+            if (p->orig_icmph == NULL) return;
+            //pkt.fldval[ICMPTYPE]= p->orig_icmph->type;
+            //pkt.fldval[ICMPTYPECODE]= (p->orig_icmph->type << 8) | p->orig_icmph->code;
+            break;
+        default:;
+        }
+    
+        pkt.fldval[SIP]= ntohl(p->orig_iph->ip_src.s_addr);
+        pkt.fldval[DIP]= ntohl(p->orig_iph->ip_dst.s_addr);
+        pkt.fldval[SPORT]= p->orig_sp;
+        pkt.fldval[DPORT]= p->orig_dp;
+
+        netspade_new_pkt(spade,&pkt);
+    }
+}
+
+
+/*********************************************************************/
+/*********************************************************************/
+
+/* our netspade callback for when there is something anomalous to report */
+static void SpadeReportAnom(void *context,spade_report *rpt) {
+    char message[256];
+    Event event;
+    u_int32_t id;
+    spade_event *pkt= rpt->pkt;
+    Packet *p= pkt->native;
+    double score= spade_report_mainscore(rpt);
+
+    sprintf(message,"Spade: %s: %s: %.4f",rpt->detect_type_str,rpt->scope_str,score);
+    
+    switch (rpt->detect_type) {
+    case SPADE_DR_TYPE_CLOSED_DPORT: id= SPADE_CLOSED_DESTPORT_USED; break;
+    case SPADE_DR_TYPE_DEAD_DEST: id= SPADE_NONLIVE_DEST_USED; break;
+    case SPADE_DR_TYPE_ODD_DPORT: id= SPADE_SRC_ODD_DESTPORT_USED; break;
+    case SPADE_DR_TYPE_ODD_TYPECODE: id= SPADE_SRC_ODD_TYPECODE_USED; break;
+    case SPADE_DR_TYPE_ODD_PORTDEST: id= SPADE_SRC_ODD_PORTDEST_USED; break;
+    default : id= 0;
+    }
+    SetEvent(&event, GENERATOR_SPP_SPADE, id,
+            1, 0, 0, 0);
+
+#if ENABLE_IDMEF
+    if (spade_alert_dest & DEST_IDMEF_FACILITY)
+        SpadeIDMEFDirect(p, rpt->detect_type_str, NULL, &event, score, rpt->detectorid);
+#endif
+    if (spade_alert_dest & DEST_ALERT_FACILITY)
+        CallAlertFuncs(p, message, NULL, &event);
+    if (spade_alert_dest & DEST_LOG_FACILITY)
+        CallLogFuncs(p, message, NULL, &event);
+}   
+
+/* our netspade callback for when there the threshold is adjusted */
+static void SpadeReportThreshChanged(void *context,char *id,char *mess,int using_corrrscore) {
+    char message[100];
+    Event event;
+
+    sprintf(message,"Spade: id=%s: %s",id,mess);
+
+    SetEvent(&event, GENERATOR_SPP_SPADE,
+            SPADE_ANOM_THRESHOLD_ADJUSTED, 1, 0, 0, 0);
+    if (spade_adj_dest & DEST_ALERT_FACILITY)
+        CallAlertFuncs(NULL, message, NULL, &event);
+    if (spade_adj_dest & DEST_LOG_FACILITY)
+        CallLogFuncs(NULL, message, NULL, &event);
+}
+
+static void SnortSpadeMsgFn(spade_message_type msg_type,const char *msg) {
+    char buf[MAX_SPADE_MSG_LEN+1];
+    const char *newmsg;
+    
+    if (!pkt_count)  { // must be a message originating from configuration activity; include conf file name and line #
+        switch (msg_type) {
+        case SPADE_MSG_TYPE_FATAL:
+        case SPADE_MSG_TYPE_WARNING:
+        case SPADE_MSG_TYPE_DEBUG:
+        {
+            int len= strlen(msg);
+            strncpy(buf,msg,MAX_SPADE_MSG_LEN);
+            snprintf(buf+len,MAX_SPADE_MSG_LEN-len,": %s(%d)\n",file_name,file_line);
+            newmsg= (const char *)buf;
+            break;
+        }
+        default:
+            newmsg= msg;
+            break;
+        }
+    } else {
+        newmsg= msg;
+    }
+        
+    switch (msg_type) {
+    case SPADE_MSG_TYPE_FATAL:
+        FatalError("%s", newmsg);
+        break;
+    case SPADE_MSG_TYPE_WARNING:
+        ErrorMessage("%s", newmsg);
+        break;
+    default:
+        LogMessage("%s", newmsg);
+        break;
+    }
+}
+
+
+/*****************************************************
+ * Called on signals
+ *****************************************************/
+void SpadeCatchSig(int signal,void *arg) {
+    if (signal == SIGUSR1) {
+        LogMessage("Spade got SIGUSR1, refreshing its disk state");
+        netspade_dump(spade);
+    } else if (signal == SIGQUIT || signal == SIGHUP || signal == SIGINT) {
+        LogMessage("Spade got shutdown signal, cleaning up");
+        netspade_cleanup(spade);
+    }
+}
+
+/*********************************************************************
+netspade.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file netspade.c
+ * \ingroup netspade_layer
+ * \brief 
+ *  netspade.c contains a "class" netspade which applies Spade to a network
+ */
+
+/*! \addtogroup libnetspade Netspade Library
+ * \brief This group contains objects the objects in libnetspade, which
+ * applies Spade to the network packets.
+  @{
+*/
+/*! \addtogroup libspade */
+/*@}*/
+
+/*! \addtogroup netspade_layer Netspade Layer
+ * \brief This group contains objects the objects specific to Netspade, which
+ * applies Spade to the network packets.
+ * \ingroup libnetspade
+  @{
+*/
+
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+/// an array mapping a netspade feature number to its name
+const char *featurenames[NETSPADE_NUM_FEATURES+1]= {"sip","dip","sport","dport","proto","tcpflags","icmptype","icmptype+code",NULL};
+
+#define IS_TCP          EVENT_CONDITION_NUM(1) ///< is the packet TCP?
+#define IS_UDP          EVENT_CONDITION_NUM(2) ///< is the packet UDP?
+#define IS_ICMP         EVENT_CONDITION_NUM(3) ///< is the packet ICMP?
+#define IS_UNRCHTCP     EVENT_CONDITION_NUM(5) ///< is the packet from inside a unreachable packet and is TCP?
+#define IS_UNRCHUDP     EVENT_CONDITION_NUM(6) ///< is the packet from inside a unreachable packet and is UDP?
+#define IS_UNRCHICMP    EVENT_CONDITION_NUM(7) ///< is the packet from inside a unreachable packet and is ICMP?
+#define SYNONLY         EVENT_CONDITION_NUM(9) ///< is the packet TCP and only have the SYN flag set (among the 6 flags)?
+#define NORMAL_RST      EVENT_CONDITION_NUM(10) ///< is the packet TCP and a normal RST?
+#define SYNACK          EVENT_CONDITION_NUM(11) ///< is the packet TCP and only have the SYN and ACK flags set?
+#define WEIRDFLAGS      EVENT_CONDITION_NUM(12) ///< is the packet TCP and have an unusual combination of flags?
+#define SETUPFLAGS      EVENT_CONDITION_NUM(13) ///< is the packet TCP and have flags associated with connection setup?
+#define ESTFLAGS        EVENT_CONDITION_NUM(14) ///< is the packet TCP and have flags associated with the established phase of a connection?
+#define TEARDOWNFLAGS   EVENT_CONDITION_NUM(15) ///< is the packet TCP and have flags associated with connection teardown?
+#define SIP_IN_HOMENET      EVENT_CONDITION_NUM(17) ///< is the source IP of the packet in the homenet?
+#define SIP_NOT_IN_HOMENET  EVENT_CONDITION_NUM(18) ///< is the source IP of the packet not in the homenet?
+#define DIP_IN_HOMENET      EVENT_CONDITION_NUM(19) ///< is the dest IP of the packet in the homenet?
+#define DIP_NOT_IN_HOMENET  EVENT_CONDITION_NUM(20) ///< is the dest IP of the packet not in the homenet?
+#define ICMPNOTERR      EVENT_CONDITION_NUM(21) ///< is the packet an ICMP but not indicating an error?
+#define ICMPERR         EVENT_CONDITION_NUM(22) ///< is the packet an ICMP and not indicating an error?
+#define REPR_PKT        EVENT_CONDITION_NUM(23) ///< does this packet fit in the minority of packets that can be considered representative of the sources of packets?
+#define UDPRESP         EVENT_CONDITION_NUM(25) ///< might the packet be a response to a UDP packet?
+#define ICMPRESP        EVENT_CONDITION_NUM(26) ///< might the packet be a response to a ICMP packet?
+#define SYNRESP         EVENT_CONDITION_NUM(27) ///< might the packet be a response to a SYN packet?
+#define ESTRESP         EVENT_CONDITION_NUM(29) ///< might the packet be a response to a ESTFLAGS packet?
+#define TEARDOWNRESP    EVENT_CONDITION_NUM(30) ///< might the packet be a response to a TEARDOWN packet?
+#define SETUPRESP       EVENT_CONDITION_NUM(31) ///< might the packet be a response to a SETUP packet?
+
+#define HOMENET_CONDS (CONDS_PLUS_3CONDS(SIP_IN_HOMENET,SIP_NOT_IN_HOMENET,DIP_IN_HOMENET,DIP_NOT_IN_HOMENET))
+#define TCPFLAG_CONDS (CONDS_PLUS_6CONDS(SYNACK,SYNONLY,NORMAL_RST,WEIRDFLAGS,ESTFLAGS,TEARDOWNFLAGS,SETUPFLAGS))
+#define REPR_PKT_CONDS (CONDS_PLUS_3CONDS(SETUPFLAGS,TEARDOWNFLAGS,IS_UDP,IS_ICMP))
+
+#define SYNRESP_CONDS (CONDS_PLUS_2CONDS(SYNACK,NORMAL_RST,IS_UNRCHTCP))
+#define ESTRESP_CONDS (CONDS_PLUS_2CONDS(ESTFLAGS,TEARDOWNFLAGS,IS_UNRCHTCP))
+#define TEARDOWNRESP_CONDS (CONDS_PLUS_CONDS(TEARDOWNFLAGS,IS_UNRCHTCP))
+#define SETUPRESP_CONDS (CONDS_PLUS_CONDS(SYNRESP_CONDS,ESTRESP_CONDS))
+#define UDPRESP_CONDS (CONDS_PLUS_CONDS(IS_UDP,IS_UNRCHUDP))
+#define ICMPRESP_CONDS (CONDS_PLUS_CONDS(ICMPNOTERR,IS_UNRCHICMP))
+
+
+#define PKT_IP_IN_HOMENET_LIST(pkt,fldname,list,res) {\
+    res= 0; \
+    if (list != NULL) { \
+        ll_net *home; \
+        for (home= list; home != NULL; home= home->next) { \
+            if ((pkt->fldval[fldname] & home->netmask) == home->netaddr) { \
+                res= 1; \
+                break; \
+            } \
+        } \
+    } else { \
+        res= 1; \
+    } \
+}
+
+static void init_netspade_empty(netspade *self,spade_msg_fn msg_callback, int debug_level);
+static netspade_detector *acquire_detector_for_id(netspade *self, char *id);
+static netspade_detector *detector_for_id(netspade *self, char *id);
+static void netspade_detector_dump(netspade_detector *detector);
+static void netspade_detector_cleanup(netspade_detector *detector);
+static void netspade_update_conds_to_calc(netspade *self);
+static event_condition_set netspade_nonstore_conds(netspade *self);
+static event_condition_set flipped_homenet_conds(event_condition_set orig);
+static int do_checkpointing(netspade *self);
+static int do_recovery(netspade *self, char *statefile);
+static void threshold_was_exceeded(void *context, void *mgrref, spade_event *pkt, score_info *score);
+static void canceller_status_report(void *context, spade_report *rpt, port_status_t status);
+static void threshold_was_adjusted(void *context, void *mgrref);
+static void netspade_add_net_to_homenet(netspade *self, char *net_str);
+static char *scope_str_for_cond(event_condition_set cond);
+static void process_netspade_xarg(netspade *self, char *str, features feat, xarg_type_t type);
+static void process_detector_xargs(netspade_detector *d, char *xsips, char *xdips, char *xsports, char *xdports);
+static void process_detector_xarg(netspade_detector *d, char *str, features feat, xarg_type_t type);
+static void process_detector_xarg(netspade_detector *d,char *str,features feat,xarg_type_t type);
+static xfeatval_link *process_xarg(char *str,features feat,xarg_type_t type,spade_msg_fn msg_callback,xfeatval_link **tail);
+static xfeatval_link *new_xfeatval_link(features feat, xarg_type_t type, char *val);
+static int pkt_is_excluded(xfeatval_link *list,spade_event *pkt);
+static int cidr_to_netmask(char *str, u32 *netip, u32 *netmask);
+static void file_print_conds(FILE *file,event_condition_set conds);
+
+void init_netspade(netspade *self,spade_msg_fn msg_callback, int debug_level) {
+    init_netspade_empty(self,msg_callback,debug_level);
+}
+
+static void init_netspade_empty(netspade *self,spade_msg_fn msg_callback, int debug_level) {
+    self->msg_callback= (msg_callback == NULL) ? default_spade_msg_fn : msg_callback;
+    self->debug_level= debug_level;
+
+    self->detectors= NULL;
+    self->detectors_tail= NULL;
+    
+    self->homelist_head= NULL;
+    self->homelist_tail= NULL;
+    
+    self->checkpoint_file= NULL;
+    self->checkpoint_freq= -1;
+
+    self->records_since_checkpoint=0;
+    self->last_time_forwarded= (time_t)0;
+    
+    self->callback_context= NULL;
+    self->exc_callback= NULL;
+    self->adj_callback= NULL;
+    self->pkt_native_copier_callback= NULL;
+    self->pkt_native_freer_callback= NULL;
+
+    self->rpt_exclude_list= NULL;
+    
+    init_event_recorder(&self->recorder);
+    self->recorder_needed_conds= 0;
+    self->nonstore_conds= 0;
+    self->conds_to_calc= 0;
+    
+    self->stats_to_print= 0;
+    self->outfile= NULL;
+    
+    self->detector_id_nonce= 0;
+    self->total_pkts= 0;
+}
+
+int init_netspade_from_statefile(netspade *self,char *statefile,spade_msg_fn msg_callback, int debug_level) {
+    init_netspade_empty(self,msg_callback,debug_level);
+    return do_recovery(self,statefile);
+}
+
+netspade *new_netspade(spade_msg_fn msg_callback, int debug_level) {
+    netspade *new= (netspade *)malloc(sizeof(netspade));
+    init_netspade(new,msg_callback,debug_level);
+    return new;
+}
+
+netspade *new_netspade_from_statefile(char *statefile,spade_msg_fn msg_callback, int debug_level,int *succ) {
+    netspade *new= (netspade *)malloc(sizeof(netspade));
+    *succ= init_netspade_from_statefile(new,statefile,msg_callback,debug_level);
+    return new;
+}
+
+void netspade_set_callbacks(netspade *self,void *context,netspade_exc_callback_t exc_callback,netspade_adj_callback_t adj_callback,event_native_copier_t pkt_native_copier_callback,event_native_freer_t pkt_native_freer_callback) {
+    self->callback_context= context;
+    self->exc_callback= exc_callback;
+    self->adj_callback= adj_callback;
+    self->pkt_native_copier_callback= pkt_native_copier_callback;
+    self->pkt_native_freer_callback= pkt_native_freer_callback;
+}
+
+void netspade_set_checkpointing(netspade *self,char *checkpoint_file,int checkpoint_freq) {
+    self->checkpoint_file= (checkpoint_file == NULL) ? NULL : strdup(checkpoint_file);
+    self->checkpoint_freq= checkpoint_freq;
+}
+
+void netspade_set_homenet_from_str(netspade *self,char *homenet_str) {
+    char *strcopy= (homenet_str == NULL) ? NULL : strdup(homenet_str);
+    char *p= strcopy;
+    int len;
+    char oldchar,*term;
+    if (strcopy == NULL) return;
+
+    while (isspace((int)*p)) p++; /* kill leading whitepspace */
+    if (*p == '[') {
+        char *end;
+        p++;
+        end= strrchr(p, (int)']');
+        if (end != NULL) *end = '\0'; /* null out the end-bracket */
+    }
+    while ((len= terminate_first_tok(p,", \t\n",&p,&oldchar)) > 0) {
+        netspade_add_net_to_homenet(self,p);
+        term= p+len;
+        *term= oldchar;
+        if (oldchar == '\0') { break; } /* Thanks Risto! */
+        p= term+1;
+    }
+
+    free(strcopy);
+
+    if (self->debug_level) {
+        ll_net *n;
+        struct in_addr net;
+        (*self->msg_callback)(SPADE_MSG_TYPE_DEBUG,"Spade home nets are:\n");
+        for (n=self->homelist_head; n != NULL; n=n->next) {
+            net.s_addr= ntohl(n->netaddr);
+            formatted_spade_msg_send(SPADE_MSG_TYPE_DEBUG,self->msg_callback,"\t%s with mask %lx\n",inet_ntoa(net),(u_long)ntohl(n->netmask));
+        }
+    }
+}
+
+void netspade_set_output_stats(netspade *self,int stats_to_print) {
+    self->stats_to_print= stats_to_print;
+}
+
+void netspade_set_output_stats_from_str(netspade *self,char *str) {
+    char *strcopy= strdup(str);
+    char *head= strcopy;
+    char oldchar;
+    int len;
+    char *term;
+    
+    self->stats_to_print= STATS_NONE;
+    
+    while ((len= terminate_first_tok(head,", \t\n",&head,&oldchar)) > 0) {
+        if (!(strcmp(head,"entropy"))) {
+            self->stats_to_print |= STATS_ENTROPY;
+        } else if (!(strcmp(head,"condprob"))) {
+            self->stats_to_print |= STATS_CONDPROB;
+        } else if (!(strcmp(head,"uncondprob"))) {
+            self->stats_to_print |= STATS_UNCONDPROB;
+        } else {
+            // warn
+        }
+        term= head+len;
+        *term= oldchar;
+        head= term+1;
+    }
+    free(strcopy);
+}
+
+int netspade_set_output(netspade *self,char *file,int stats_to_print) {
+    self->outfile= strdup(file);
+    self->stats_to_print= stats_to_print;
+    return 1;
+}
+
+int netspade_set_output_file(netspade *self,char *file) {
+    self->outfile= strdup(file);
+    return 1;
+}
+
+void netspade_add_rpt_excludes(netspade *self,char *xsips,char *xdips,char *xsports,char *xdports) {
+    process_netspade_xarg(self,xsports,SPORT,XARG_TYPE_UINT);
+    process_netspade_xarg(self,xdips,DIP,XARG_TYPE_CIDR);
+    process_netspade_xarg(self,xsips,SIP,XARG_TYPE_CIDR);
+    process_netspade_xarg(self,xdports,DPORT,XARG_TYPE_UINT);
+}
+
+char *netspade_new_detector(netspade *self,char *str) {
+    netspade_detector *new;
+    char *strcopy= strdup(str);
+    char *type;
+    int calcboth;
+    int minobs_prefix_len= -1,entropy_prefix_len=-1;
+    int canceller_timeout_implication;
+    event_condition_set cancel_homenet_conds;
+    feature_list fla[4];
+    char to[8]="home",from[8]="home",protocol[5]="tcp";
+    char tcpflags[21]="synonly";
+    char xsips[401]="",xdips[401]="",xsports[401]="",xdports[401]="";
+    double thresh= 10000000;
+    int wait=0;
+    int relscore=1,minobs=0,probmode=3;
+    int scalefreqmins=240;
+    double scalefactor= 0.98363,scalecutoff= 0.18,scalehalflifehrs=-1;
+    int reverse_reporting=0;
+    double maxentropy= -1;
+    void *args[30];
+    char formatstr[500]="$i:wait;s50:id;i:minobs;"
+                "i:scalefreq;d:scalefactor;d:scalecutoff;d:scalehalflife;"
+                "s400:Xsips,Xsip,xsips;s400:Xdips,Xdip,xdips;"
+                "s400:Xsports,Xsport,xsports;s400:Xdports,Xdport,xdports;"
+                "b:revwaitrpt";
+    char id[51]="\0";
+    char defaultid[31];
+    sprintf(defaultid,"%d",++self->detector_id_nonce);
+    
+    args[0]= &wait;
+    args[1]= &id;
+    args[2]= &minobs;
+    args[3]= &scalefreqmins;
+    args[4]= &scalefactor;
+    args[5]= &scalecutoff;
+    args[6]= &scalehalflifehrs;
+    args[7]= &xsips;
+    args[8]= &xdips;
+    args[9]= &xsports;
+    args[10]= &xdports;
+    args[11]= &reverse_reporting;
+    
+    new= (netspade_detector *)malloc(sizeof(netspade_detector));
+    new->parent= self;
+    init_score_calculator_clear(&new->calculator,&self->recorder);
+    new->store_conds= 0;
+    new->scorecalc_conds= 0;
+    new->thresh_exc_port_impl= PORT_UNKNOWN;
+    PS_INIT_SET_WITH_STRONGER(new->port_report_criterea,PORT_UNKNOWN);
+    new->cancel_closed_conds= EVENT_CONDITION_FALSE;
+    new->cancel_open_conds= EVENT_CONDITION_FALSE;
+    new->report_scope_str= NULL;
+    new->exclude_broadcast_dip= 0;
+    
+    type= extract_str_arg_space_sep(strcopy,"type");
+
+    if (type == NULL) type= "closed-dport";
+    new->detect_type= SPADE_DR_TYPE_NUM4SHORT(type);
+    new->report_detection_type= DEFAULT_DN_TYPE_FOR_DR_TYPE(new->detect_type); // may be overridden below
+    
+    switch (new->detect_type) {
+    case SPADE_DR_TYPE_CLOSED_DPORT: {
+        int corrscore=1;
+        scalefactor= 0.96409; /* this detection type uses a different that normal scaling factor */
+        minobs= -1;
+        minobs_prefix_len= 0;
+        
+        new->thresh_exc_port_impl= PORT_PROBCLOSED;
+        PS_INIT_SET_WITH_STRONGER(new->port_report_criterea,PORT_PROBCLOSED); /* override default default; this will be overriden if wait is set */
+        
+        args[12]= &protocol;
+        args[13]= &to;
+        args[14]= &tcpflags;
+        args[15]= &thresh;
+        args[16]= &relscore;
+        args[17]= &probmode;
+        args[18]= &corrscore;
+        strcat(formatstr,";s4:protocol,proto;s7:to;s20:tcpflags;d:thresh;b:relscore;"
+                          "i:probmode;b:-corrscore,corrscore");
+        fill_args_space_sep(strcopy,formatstr,args,self->msg_callback);
+            
+        if (thresh == 10000000) thresh= relscore ? 0.85 : -1;
+        if (minobs == -1) minobs= relscore ? 400 : 0;
+        score_calculator_set_corrscore(&new->calculator,corrscore);
+
+        fla[0].feat[0]= DIP; fla[0].feat[1]= DPORT;
+        fla[0].feat[2]= SIP; fla[0].feat[3]= SPORT;
+        switch (probmode) {
+            case 0:
+                fla[0].num= 1; fla[0].feat[0]= DIP;
+                fla[1].num= 3; fla[1].feat[0]= SIP; fla[1].feat[1]= DPORT; fla[1].feat[2]= SPORT;
+                fla[2].num= 2; fla[2].feat[0]= SPORT; fla[2].feat[1]= DPORT;
+                fla[3].num= 3; fla[3].feat[0]= DIP; fla[3].feat[1]= SPORT; fla[3].feat[2]= SIP;
+                /* P(dport) * P(sip|dport,sport) * P(sport|dport) * P(dip|sport,sip) */
+                score_calculator_set_features(&new->calculator,4,fla,NULL,featurenames);
+                minobs= 0; /* prob mode 0 disables minobs; what would it mean? */
+                break;
+            case 1: 
+                fla[0].num= 4;
+                score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+                break;
+            case 2:
+                fla[0].num= 3;
+                score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+                break;
+            default:
+                if (probmode < 0 || probmode > 3) formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Probability mode %d not valid, using mode 3\n",probmode);
+            case 3:
+                fla[0].num= 2;
+                score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+                break;
+        }
+
+        score_calculator_set_condcutoff(&new->calculator,0);
+        
+        if (!strcmp(to,"any")) {
+            /* no restriction => no conditions to set */
+        } else if (!strcmp(to,"nothome")) {
+            ADD_TO_CONDS(new->scorecalc_conds,DIP_NOT_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,DIP_NOT_IN_HOMENET);
+        } else {
+            if (strcmp(to,"home")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"\"to\" setting %s not valid, using home\n",to);
+            }
+            ADD_TO_CONDS(new->scorecalc_conds,DIP_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,DIP_IN_HOMENET);
+        }
+
+        if (!strcmp(protocol,"udp")) {
+            ADD_TO_CONDS(new->store_conds,IS_UDP);
+            ADD_TO_CONDS(new->scorecalc_conds,IS_UDP);
+            //new->cancel_open_conds= IS_UDP; /* waiting to see if might be open is optional */
+            new->cancel_closed_conds= IS_UNRCHUDP; /* waiting for a ICMP UNRCH to be sure it is a probe is optional */
+            //if (!wait) wait= 5;
+       } else {
+            if (strcmp(protocol,"tcp")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Protocol %s not valid, using tcp\n",protocol);
+            }
+            ADD_TO_CONDS(new->store_conds,SYNONLY);           /* only store tcp syns */
+            if (!strcmp(tcpflags,"weird")) {
+                ADD_TO_CONDS(new->scorecalc_conds,WEIRDFLAGS);
+                new->cancel_open_conds= EVENT_CONDITION_FALSE; /* not available */
+            } else if (!strcmp(tcpflags,"synack")) {
+                ADD_TO_CONDS(new->scorecalc_conds,SYNACK);
+                new->cancel_closed_conds= NORMAL_RST; /* we need to wait for a RST to be sure it is a probe */
+                if (!wait) wait= 5;
+            } else if (!strcmp(tcpflags,"established")) {
+                ADD_TO_CONDS(new->scorecalc_conds,ESTFLAGS);
+                new->cancel_closed_conds= NORMAL_RST; /* we need to wait for a RST to be sure it is a probe */
+                if (!wait) wait= 5;
+            } else if (!strcmp(tcpflags,"teardown")) {
+                ADD_TO_CONDS(new->scorecalc_conds,TEARDOWNFLAGS);
+                new->cancel_closed_conds= NORMAL_RST; /* we need to wait for a RST to be sure it is a probe */
+                if (!wait) wait= 5;
+            } else {
+                if (strcmp(tcpflags,"synonly")) {
+                    formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"TCP flags %s not valid, using synonly\n",tcpflags);
+                }
+                ADD_TO_CONDS(new->scorecalc_conds,SYNONLY);
+                new->cancel_open_conds= SYNACK; /* waiting to see if might be open is optional */
+            }
+        }
+        
+        if (!wait) {
+            new->report_detection_type= SPADE_DN_TYPE_ODD_DPORT;
+        } else if (reverse_reporting) {
+            new->report_detection_type= SPADE_DN_TYPE_ODD_OPEN_DPORT;
+        }
+        break;
+    }
+    case SPADE_DR_TYPE_ODD_TYPECODE: {
+        char icmptype[7]="any";
+        thresh=0.9;
+        scalefactor= 0.96409; /* this detection type uses a different that normal scaling factor */
+        minobs=-1; /* this detection type uses a different that normal default minobs */
+        
+        minobs_prefix_len= 0;
+
+        args[12]= &to;
+        args[13]= &thresh;
+        args[14]= &icmptype;        
+        strcat(formatstr,";s7:to;d:thresh;s6:icmptype");
+        fill_args_space_sep(strcopy,formatstr,args,self->msg_callback);
+            
+        fla[0].num= 1; fla[0].feat[0]= ICMPTYPECODE;
+        score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+        score_calculator_set_condcutoff(&new->calculator,0);
+
+        if (!strcmp(to,"any")) {
+            /* no restriction => no conditions to set */
+        } else if (!strcmp(to,"nothome")) {
+            ADD_TO_CONDS(new->scorecalc_conds,DIP_NOT_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,DIP_NOT_IN_HOMENET);
+        } else {
+            if (strcmp(to,"home")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"\"to\" setting %s not valid, using home\n",from);
+            }
+            ADD_TO_CONDS(new->scorecalc_conds,DIP_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,DIP_IN_HOMENET);
+        }
+
+        if (!strcmp(icmptype,"noterr")) {
+            ADD_TO_CONDS(new->scorecalc_conds,ICMPNOTERR);
+            ADD_TO_CONDS(new->store_conds,ICMPNOTERR);
+            if (minobs == -1) minobs= 2000;
+        } else if (!strcmp(icmptype,"err")) {
+            ADD_TO_CONDS(new->scorecalc_conds,ICMPERR);
+            ADD_TO_CONDS(new->store_conds,ICMPERR);
+            if (minobs == -1) minobs= 2000;
+        } else {
+            if (strcmp(icmptype,"any")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"ICMP type %s not valid, using any\n",icmptype);
+            }
+            ADD_TO_CONDS(new->scorecalc_conds,IS_ICMP);
+            ADD_TO_CONDS(new->store_conds,IS_ICMP);
+            if (minobs == -1) minobs= 4000;
+        }
+
+        new->cancel_open_conds= ICMPNOTERR;
+        
+        break;
+    }
+    case SPADE_DR_TYPE_ODD_DPORT: {
+        thresh=0.8;
+        minobs=600; /* this detection type uses a different that normal default minobs */
+        
+        args[12]= &protocol;
+        args[13]= &from;
+        args[14]= &thresh;
+        strcat(formatstr,";s4:protocol,proto;s7:from;d:thresh");
+        fill_args_space_sep(strcopy,formatstr,args,self->msg_callback);
+            
+        fla[0].num= 2; fla[0].feat[0]= SIP; fla[0].feat[1]= DPORT;
+        score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+        score_calculator_set_condcutoff(&new->calculator,1);
+
+        if (!strcmp(from,"any")) {
+            /* no restriction => no conditions to set */
+        } else if (!strcmp(from,"nothome")) {
+            ADD_TO_CONDS(new->scorecalc_conds,SIP_NOT_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,SIP_NOT_IN_HOMENET);
+        } else {
+            if (strcmp(from,"home")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"\"from\" setting %s not valid, using home\n",from);
+            }
+            ADD_TO_CONDS(new->scorecalc_conds,SIP_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,SIP_IN_HOMENET);
+        }
+
+        /* this detection type only makes sense for connection-openers */    
+        if (!strcmp(protocol,"udp")) {
+            ADD_TO_CONDS(new->store_conds,IS_UDP);
+            ADD_TO_CONDS(new->scorecalc_conds,IS_UDP);
+            //new->cancel_open_conds= IS_UDP;
+            new->cancel_closed_conds= IS_UNRCHUDP; /* waiting for a ICMP UNRCH is optional */
+        } else {
+            if (strcmp(protocol,"tcp")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Protocol %s not valid, using tcp\n",protocol);
+            }
+            ADD_TO_CONDS(new->store_conds,SYNONLY);           /* only store tcp syns */
+            ADD_TO_CONDS(new->scorecalc_conds,SYNONLY);
+            new->cancel_open_conds= SYNACK;
+        }
+        
+        break;
+    }
+    case SPADE_DR_TYPE_ODD_PORTDEST: {
+        thresh=0.9;
+        minobs=-1; /* this detection type uses a different that normal default minobs */
+        maxentropy= 2.5;
+        scalefreqmins= 90; /* override the default defaults */
+        scalefactor= 0.97957;
+        scalecutoff= 0.25;
+        
+        args[12]= &protocol;
+        args[13]= &from;
+        args[14]= &thresh;
+        args[15]= &maxentropy;
+        strcat(formatstr,";s4:protocol,proto;s7:from;d:thresh;d:maxentropy");
+        fill_args_space_sep(strcopy,formatstr,args,self->msg_callback);
+
+        fla[0].num= 3; fla[0].feat[0]= SIP; fla[0].feat[1]= DPORT; fla[0].feat[2]= DIP;
+        score_calculator_set_features(&new->calculator,1,fla,NULL,featurenames);
+        score_calculator_set_condcutoff(&new->calculator,1);
+
+        if (!strcmp(from,"any")) {
+            /* no restriction => no conditions to set */
+        } else if (!strcmp(from,"nothome")) {
+            ADD_TO_CONDS(new->scorecalc_conds,SIP_NOT_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,SIP_NOT_IN_HOMENET);
+        } else {
+            if (strcmp(from,"home")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"\"from\" setting %s not valid, using home\n",from);
+            }
+            ADD_TO_CONDS(new->scorecalc_conds,SIP_IN_HOMENET);
+            ADD_TO_CONDS(new->store_conds,SIP_IN_HOMENET);
+        }
+
+        /* this detection type only makes sense for connection-openers */    
+        if (!strcmp(protocol,"udp")) {
+            ADD_TO_CONDS(new->store_conds,IS_UDP);
+            ADD_TO_CONDS(new->scorecalc_conds,IS_UDP);
+            //new->cancel_open_conds= IS_UDP;
+            new->cancel_closed_conds= IS_UNRCHUDP; /* waiting for a ICMP UNRCH is optional */
+
+            if (minobs == -1) minobs= pow(2,maxentropy) * 200; /* default is 200 times the minimum number of observations need to acheive maxentropy */
+        } else {
+            if (strcmp(protocol,"tcp")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Protocol %s not valid, using tcp\n",protocol);
+            }
+            ADD_TO_CONDS(new->store_conds,SYNONLY);           /* only store tcp syns */
+            ADD_TO_CONDS(new->scorecalc_conds,SYNONLY);
+            new->cancel_open_conds= SYNACK;
+
+            if (minobs == -1) minobs= pow(2,maxentropy) * 100; /* default is 100 times the minimum number of observations need to acheive maxentropy */
+        }
+        
+        break;
+    }
+    case SPADE_DR_TYPE_DEAD_DEST: {
+        feature_list cfl;
+        char icmptype[7]="noterr";
+        scalefreqmins= 60; /* override the default defaults */
+        scalefactor= 0.94387;
+        scalecutoff= 0.25;
+        wait= 2;
+        minobs= 2000;
+        minobs_prefix_len= 0;
+        thresh= 1;
+        
+        new->exclude_broadcast_dip= 1;
+        new->thresh_exc_port_impl= PORT_PROBCLOSED;
+        ADD_TO_CONDS(new->scorecalc_conds,DIP_IN_HOMENET);
+        ADD_TO_CONDS(new->store_conds,SIP_IN_HOMENET);
+        ADD_TO_CONDS(new->store_conds,REPR_PKT);
+
+        fla[0].num= 1; fla[0].feat[0]= SIP;
+        cfl.num= 1; cfl.feat[0]= DIP;
+        score_calculator_set_features(&new->calculator,1,fla,&cfl,featurenames);
+        score_calculator_set_corrscore(&new->calculator,1);
+        
+        args[12]= &protocol;
+        args[13]= &tcpflags;        
+        args[14]= &icmptype;        
+        strcat(formatstr,";s4:protocol,proto;s20:tcpflags;s6:icmptype");
+        fill_args_space_sep(strcopy,formatstr,args,self->msg_callback);
+
+        score_calculator_set_condcutoff(&new->calculator,0);
+
+        if (!strcmp(protocol,"udp")) {
+            ADD_TO_CONDS(new->scorecalc_conds,IS_UDP);
+            new->cancel_open_conds= UDPRESP; /* waiting to see if might be live is optional */
+        } else if (!strcmp(protocol,"icmp")) {
+            new->cancel_open_conds= ICMPRESP; /* waiting to see if might be live is optional */
+            if (!strcmp(icmptype,"any")) {
+                ADD_TO_CONDS(new->scorecalc_conds,IS_ICMP);
+            } else if (!strcmp(icmptype,"err")) {
+                ADD_TO_CONDS(new->scorecalc_conds,ICMPERR);
+            } else {
+                if (strcmp(icmptype,"noterr")) {
+                    formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"ICMP type %s not valid, using noterr\n",icmptype);
+                }
+                ADD_TO_CONDS(new->scorecalc_conds,ICMPNOTERR);
+            }
+        } else {
+            if (strcmp(protocol,"tcp")) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Protocol %s not valid, using tcp\n",protocol);
+            }
+            if (!strcmp(tcpflags,"weird")) {
+                ADD_TO_CONDS(new->scorecalc_conds,WEIRDFLAGS);
+                new->cancel_open_conds= EVENT_CONDITION_FALSE; /* not available */
+            } else if (!strcmp(tcpflags,"setup")) {
+                ADD_TO_CONDS(new->scorecalc_conds,SETUPFLAGS);
+                new->cancel_open_conds= SETUPRESP;
+            } else if (!strcmp(tcpflags,"synack")) {
+                ADD_TO_CONDS(new->scorecalc_conds,SYNACK);
+                new->cancel_open_conds= ESTRESP;
+            } else if (!strcmp(tcpflags,"established")) {
+                ADD_TO_CONDS(new->scorecalc_conds,ESTFLAGS);
+                new->cancel_open_conds= ESTRESP;
+            } else if (!strcmp(tcpflags,"teardown")) {
+                ADD_TO_CONDS(new->scorecalc_conds,TEARDOWNFLAGS);
+                new->cancel_open_conds= TEARDOWNRESP;
+            } else {
+                if (strcmp(tcpflags,"synonly")) {
+                    formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"TCP flags %s not valid, using synonly\n",tcpflags);
+                }
+                ADD_TO_CONDS(new->scorecalc_conds,SYNONLY);
+                new->cancel_open_conds= SYNRESP;
+            }
+        }
+
+        break;
+    }
+    default:
+        free(new);
+        formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"detector type \"%s\" not recognized, not enabling this detector: %s",type,str);
+        return NULL;
+    } 
+
+    /* finish new->store_conds,scorecalc_conds and cancel_open_conds */
+    
+    if (wait > 0 && (CONDS_NOT_FALSE(new->cancel_open_conds) ||  CONDS_NOT_FALSE(new->cancel_closed_conds))) {
+        int canceller_response_implication;
+        int report_timeout;
+        if (CONDS_NOT_FALSE(new->cancel_closed_conds)) { /* waiting is for closed */
+            canceller_timeout_implication= PORT_UNKNOWN;
+            canceller_response_implication= PORT_CLOSED;
+            new->cancel_open_conds= EVENT_CONDITION_FALSE;
+            report_timeout= 0 || reverse_reporting;
+        } else { /* waiting is for open */
+            canceller_timeout_implication= PORT_LIKELYCLOSED;
+            canceller_response_implication= PORT_OPEN;
+            new->cancel_closed_conds= EVENT_CONDITION_FALSE;
+            report_timeout= 1 && !reverse_reporting;
+        }
+        if (report_timeout) {
+            PS_INIT_SET(new->port_report_criterea,canceller_timeout_implication);
+        } else {
+            PS_INIT_SET_WITH_STRONGER(new->port_report_criterea,canceller_response_implication);
+        }
+        new->canceller= new_packet_resp_canceller(wait,&canceller_status_report,new,canceller_timeout_implication);
+    } else {
+        new->canceller= NULL;
+        new->cancel_open_conds= EVENT_CONDITION_FALSE;
+        new->cancel_closed_conds= EVENT_CONDITION_FALSE;
+    }
+    /* check if restrictions on report's homenet, need to flip for cancelling */
+    cancel_homenet_conds= flipped_homenet_conds(new->scorecalc_conds);
+    if (CONDS_NOT_FALSE(new->cancel_open_conds))
+        ADD_TO_CONDS(new->cancel_open_conds,cancel_homenet_conds);
+    if (CONDS_NOT_FALSE(new->cancel_closed_conds))
+        ADD_TO_CONDS(new->cancel_closed_conds,cancel_homenet_conds);
+
+    score_calculator_set_storage_conditions(&new->calculator,new->store_conds);
+    
+    calcboth= 0; /*relscore ? 0 : 1;*/
+    score_calculator_set_relscore(&new->calculator,relscore || calcboth,relscore);
+    score_calculator_set_rawscore(&new->calculator,!relscore || calcboth,!relscore);
+    if (scalehalflifehrs >= 0) // set factor based on halflife and frequency
+        scalefactor= exp((scalefreqmins/(scalehalflifehrs*60))*log(0.5));
+    score_calculator_set_scaling(&new->calculator,scalefreqmins*60,scalefactor,scalecutoff);
+    if (minobs > 0) {
+        if (minobs_prefix_len < 0) minobs_prefix_len+= fla[0].num;
+        score_calculator_set_min_obs(&new->calculator,minobs_prefix_len,minobs);
+    }
+    if (maxentropy >= 0) {
+        if (entropy_prefix_len < 0) entropy_prefix_len+= fla[0].num;
+        score_calculator_set_low_entropy_domain(&new->calculator,entropy_prefix_len,maxentropy);
+    }
+    init_spade_enviro(&new->enviro,thresh,&self->total_pkts);
+    init_score_mgr(&new->mgr, new, &new->enviro, self,
+                threshold_was_exceeded, threshold_was_adjusted,self->msg_callback);
+    
+    process_detector_xargs(new,xsips,xdips,xsports,xdports);
+                
+    if (id[0] == '\0' || detector_for_id(self,id)) {
+        if (id[0] != '\0') formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,self->msg_callback,"Detector with id=%s already exists; using id=%s instead on: %s",id,defaultid,str);
+        new->id= strdup(defaultid);
+    } else {
+        new->id= strdup(id);
+    }
+    new->last_adj_stats.scored= 0;
+    new->last_adj_stats.reported= 0;
+    
+    /* append new detector to the list */
+    new->next= NULL;
+    if (self->detectors == NULL) { /* first entry */
+        self->detectors= new;
+    } else {
+        self->detectors_tail->next= new;
+    }
+    self->detectors_tail= new;
+    
+    netspade_detector_scope_str(self,new->id);
+                
+    free(strcopy);
+    return new->id;
+}
+
+int netspade_set_detector_scaling(netspade *self,char *detectorid,int scale_freq,double scale_factor,double prune_threshold) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_calculator_set_scaling(&detector->calculator,scale_freq,scale_factor,prune_threshold);
+    return 1;
+}
+
+char *netspade_setup_detector_adapt_from_str(netspade *self,int adaptmode,char *str) {
+    char *strcopy= strdup(str);
+    char *detectorid= extract_str_arg_space_sep(strcopy,"id");
+    netspade_detector *detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_adapt_from_str(&detector->mgr,adaptmode,strcopy);
+    free(strcopy);
+    return detector->id;
+}
+
+int netspade_setup_detector_adapt1(netspade *self,char *detectorid,int adapttarget, time_t period, float new_obs_weight, int by_count) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_adapt1(&detector->mgr,adapttarget,period,new_obs_weight,by_count);
+    return 1;
+}
+
+int netspade_setup_detector_adapt2(netspade *self,char *detectorid,double targetspec, double obsper, int NS, int NM, int NL) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_adapt2(&detector->mgr,targetspec,obsper,NS,NM,NL);
+    return 1;
+}
+
+int netspade_setup_detector_adapt3(netspade *self,char *detectorid,double targetspec, double obsper, int NO) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_adapt3(&detector->mgr,targetspec,obsper,NO);
+    return 1;
+}
+
+int netspade_setup_detector_advise(netspade *self,char *detectorid,int obs_size, int obs_secs) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_advise(&detector->mgr,obs_size,obs_secs);
+    return 1;
+}
+
+char *netspade_setup_detector_advise_from_str(netspade *self,char *str) {
+    char *strcopy= strdup(str);
+    char *detectorid= extract_str_arg_space_sep(strcopy,"id");
+    netspade_detector *detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_advise_from_str(&detector->mgr,strcopy);
+    free(strcopy);
+    return detector->id;
+}
+
+int netspade_setup_detector_survey(netspade *self,char *detectorid,char *filename,float interval) {
+    netspade_detector *detector;
+    detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_survey(&detector->mgr,filename,interval);
+    return 1;
+}
+
+char *netspade_setup_detector_survey_from_str(netspade *self,char *str) {
+    char *strcopy= strdup(str);
+    char *detectorid= extract_str_arg_space_sep(strcopy,"id");
+    netspade_detector *detector= acquire_detector_for_id(self,detectorid);
+    score_mgr_setup_survey_from_str(&detector->mgr,strcopy);
+    free(strcopy);
+    return detector->id;
+}
+
+/* called frequently, should be efficient esp for packets we don't care about */
+void netspade_new_pkt(netspade *self,spade_event *pkt) {
+    event_condition_set pkt_conds=0;
+    int write_log= 0;
+    int ip_in_homenet;
+    features orig_sip,orig_dip,orig_sport,orig_dport;
+    netspade_detector *detector;
+    int new_sec= (self->last_time_forwarded < (time_t)pkt->time);
+
+    if (self->last_time_forwarded == 0) { /* first packet */
+        if (self->detectors == NULL)
+            netspade_new_detector(self,"relscore=0 corrscore=0");
+        for (detector= self->detectors; detector != NULL; detector=detector->next) {
+            score_calculator_init_complete(&detector->calculator); /* make sure calculator is all set up */
+        }
+    }
+
+//printf("packet time is %.4f\n",pkt->time);
+
+    /* update packet counts and tell detector of new time */
+    self->total_pkts++;
+    if (new_sec) {
+        for (detector= self->detectors; detector != NULL; detector=detector->next) {
+            if (score_mgr_new_time(&detector->mgr,pkt->time)) write_log=1; /* advising completed */
+            if (detector->canceller != NULL)
+                packet_resp_canceller_new_time(detector->canceller,pkt->time);
+            detector->enviro.now= (time_t)pkt->time;
+        }
+        event_recorder_new_time(&self->recorder,(time_t)pkt->time);
+        self->last_time_forwarded= (time_t)pkt->time;
+    }
+    
+    /* calculate the conditions that this packet satisfies; no need to calculate any conditions we don't care about (i.e., not on recorder_needed_conds or nonstore_conds) */
+    if (!self->nonstore_conds || !self->recorder_needed_conds)
+        netspade_update_conds_to_calc(self);
+    if (pkt->origin == PKTORIG_UNRCH) {
+        orig_sip= DIP;
+        orig_dip= SIP;
+        orig_sport= DPORT;
+        orig_dport= SPORT;
+        if (pkt->fldval[IPPROTO] == IPPROTO_TCP) 
+             ADD_TO_CONDS(pkt_conds,IS_UNRCHTCP);
+        else if (pkt->fldval[IPPROTO] == IPPROTO_UDP) 
+            ADD_TO_CONDS(pkt_conds,IS_UNRCHUDP);
+        else if (pkt->fldval[IPPROTO] == IPPROTO_ICMP) 
+            ADD_TO_CONDS(pkt_conds,IS_UNRCHICMP);
+    } else {
+        orig_sip= SIP;
+        orig_dip= DIP;
+        orig_sport= SPORT;
+        orig_dport= DPORT;
+        if (pkt->fldval[IPPROTO] == IPPROTO_TCP) {
+            u8 tcpflags= pkt->fldval[TCPFLAGS] & 0x3F; /* strip off reserved bits */
+            ADD_TO_CONDS(pkt_conds,IS_TCP);
+            if (tcpflags == 0x02) {
+                ADD_TO_CONDS(pkt_conds,SYNONLY);
+            } else if (tcpflags == 0x12) {
+                ADD_TO_CONDS(pkt_conds,SYNACK);
+            } else {
+                if (!(tcpflags & 0x16)) { /* no syn, no ack, and no rst */
+                    ADD_TO_CONDS(pkt_conds,WEIRDFLAGS);
+                } else if (tcpflags & 0x10) { /* has ack */
+                    event_condition_set tmp= tcpflags & 0x07; /* now strip out A,P,U */
+                    if (tmp != 0x00 && tmp != 0x01 && tmp != 0x04) /* not more than one of F or R */
+                        ADD_TO_CONDS(pkt_conds,WEIRDFLAGS);
+                } else if (!((tcpflags == 0x01) || (tcpflags == 0x02) || (tcpflags == 0x04))) { /* no ack, but no S,F,or R */
+                    ADD_TO_CONDS(pkt_conds,WEIRDFLAGS);
+                }
+            }
+            if (!SOME_CONDS_MET(pkt_conds,WEIRDFLAGS)) {
+                event_condition_set tmp= (pkt->fldval[TCPFLAGS] & 0x07); /* strip off all but S,F,R */
+                switch (tmp) {
+                case 0x00: ADD_TO_CONDS(pkt_conds,ESTFLAGS); break;
+                case 0x02: ADD_TO_CONDS(pkt_conds,SETUPFLAGS); break;
+                case 0x01: ADD_TO_CONDS(pkt_conds,TEARDOWNFLAGS); break;
+                case 0x04: ADD_TO_CONDS(pkt_conds,CONDS_PLUS_CONDS(NORMAL_RST,TEARDOWNFLAGS)); break;
+                default:;
+                }
+            }
+        } else if (pkt->fldval[IPPROTO] == IPPROTO_UDP) {
+            ADD_TO_CONDS(pkt_conds,IS_UDP);
+        } else if (pkt->fldval[IPPROTO] == IPPROTO_ICMP) {
+            ADD_TO_CONDS(pkt_conds,IS_ICMP);
+            if ((pkt->fldval[ICMPTYPE] < 3 || pkt->fldval[ICMPTYPE] > 5) &&
+                pkt->fldval[ICMPTYPE] != 11 && pkt->fldval[ICMPTYPE] != 12) {
+                ADD_TO_CONDS(pkt_conds,ICMPNOTERR);
+            } else {
+                ADD_TO_CONDS(pkt_conds,ICMPERR);
+            }
+        }
+    }
+    if (SOME_CONDS_MET(pkt_conds,REPR_PKT_CONDS))
+        ADD_TO_CONDS(pkt_conds,REPR_PKT);
+    if (SOME_CONDS_MET(pkt_conds,UDPRESP_CONDS))
+        ADD_TO_CONDS(pkt_conds,UDPRESP);
+    if (SOME_CONDS_MET(pkt_conds,ICMPRESP_CONDS))
+        ADD_TO_CONDS(pkt_conds,ICMPRESP);
+    if (SOME_CONDS_MET(pkt_conds,ONLY_CONDS(self->conds_to_calc,CONDS_PLUS_3CONDS(SYNRESP_CONDS,ESTRESP_CONDS,TEARDOWNRESP_CONDS,SETUPRESP_CONDS)))) {
+        /* did that test so only TCP and ICMP unreachable will go in here */
+        if (SOME_CONDS_MET(pkt_conds,SYNRESP_CONDS))
+            ADD_TO_CONDS(pkt_conds,SYNRESP);
+        if (SOME_CONDS_MET(pkt_conds,ESTRESP_CONDS))
+            ADD_TO_CONDS(pkt_conds,ESTRESP);
+        if (SOME_CONDS_MET(pkt_conds,TEARDOWNRESP_CONDS))
+            ADD_TO_CONDS(pkt_conds,TEARDOWNRESP);
+        if (SOME_CONDS_MET(pkt_conds,SETUPRESP_CONDS))
+            ADD_TO_CONDS(pkt_conds,SETUPRESP);
+    }
+
+    
+    if (SOME_CONDS_MET(self->conds_to_calc,CONDS_PLUS_CONDS(DIP_IN_HOMENET,DIP_NOT_IN_HOMENET))) {
+        PKT_IP_IN_HOMENET_LIST(pkt,orig_dip,self->homelist_head,ip_in_homenet);
+        ADD_TO_CONDS(pkt_conds,(ip_in_homenet ? DIP_IN_HOMENET : DIP_NOT_IN_HOMENET));
+    }
+    if (SOME_CONDS_MET(self->conds_to_calc,CONDS_PLUS_CONDS(SIP_IN_HOMENET,SIP_NOT_IN_HOMENET))) {
+        PKT_IP_IN_HOMENET_LIST(pkt,orig_sip,self->homelist_head,ip_in_homenet);
+        ADD_TO_CONDS(pkt_conds,(ip_in_homenet ? SIP_IN_HOMENET : SIP_NOT_IN_HOMENET));
+    }
+    
+    if (SOME_CONDS_MET(pkt_conds,self->nonstore_conds)) { /* might match something to calculate or cancel */
+        /* check for scoring and cancelling in each detector */
+        int portless= (pkt->fldval[IPPROTO] != IPPROTO_TCP) && (pkt->fldval[IPPROTO] != IPPROTO_UDP);
+        for (detector= self->detectors; detector != NULL; detector=detector->next) {
+            if (ALL_CONDS_MET(pkt_conds,detector->scorecalc_conds) && (!detector->exclude_broadcast_dip || ((pkt->fldval[DIP] & 0xFF) != 0xFF))) {
+                score_info score;
+                int enoughobs;
+                score_info *res= score_calculator_calc_event_score(&detector->calculator,pkt,&score,&enoughobs);
+                if (!enoughobs || res != NULL) { // ignore events we decided not to apply this detector to */
+                    detector->enviro.pkt_stats.scored++;
+                    if (enoughobs) { // res != NULL
+                        score_mgr_new_event(&detector->mgr,&score,pkt);
+                    } else {  // !enoughobs
+                        detector->enviro.pkt_stats.insuffobsed++;
+                    }
+                }
+            }
+            if (ALL_CONDS_MET(pkt_conds,detector->cancel_open_conds)) {
+                detector->enviro.pkt_stats.respchecked++;
+                packet_resp_canceller_note_response(detector->canceller,PORT_OPEN,
+                    pkt->fldval[orig_dip],pkt->fldval[orig_dport],
+                    pkt->fldval[orig_sip],pkt->fldval[orig_sport],portless);
+            }
+            if (ALL_CONDS_MET(pkt_conds,detector->cancel_closed_conds)) {
+                detector->enviro.pkt_stats.respchecked++;
+                packet_resp_canceller_note_response(detector->canceller,PORT_CLOSED,
+                    pkt->fldval[orig_dip],pkt->fldval[orig_dport],
+                    pkt->fldval[orig_sip],pkt->fldval[orig_sport],portless);
+            }
+        }
+    }
+    if (SOME_CONDS_MET(pkt_conds,self->recorder_needed_conds)) { /* might match something to record */
+        self->records_since_checkpoint+=
+            event_recorder_new_event(&self->recorder,pkt,pkt_conds);
+    }
+    
+    if (write_log) { /* time to write the log */
+        netspade_write_log(self);
+    }
+    if ((self->checkpoint_freq > 0) && (self->records_since_checkpoint >= self->checkpoint_freq)) { // see if its time to checkpoint
+        do_checkpointing(self); // should report err if returns 0
+        self->records_since_checkpoint= 0;
+    }
+}
+
+
+void netspade_dump(netspade *self) 
+{
+    netspade_detector *detector;
+    netspade_write_log(self);
+    for (detector= self->detectors; detector != NULL; detector=detector->next) {
+        netspade_detector_dump(detector);
+    }
+    if (self->checkpoint_file != NULL) do_checkpointing(self);
+}
+
+void netspade_cleanup(netspade *self) 
+{
+    netspade_detector *detector;
+    netspade_write_log(self);
+    for (detector= self->detectors; detector != NULL; detector=detector->next) {
+        netspade_detector_cleanup(detector);
+    }
+    if (self->checkpoint_file != NULL) do_checkpointing(self);
+}
+
+char *netspade_detector_scope_str(netspade *self,char *id) {
+    int i;
+    char *str,*tail;
+    int numconds= 0;
+    netspade_detector *d= detector_for_id(self,id);
+    if (d == NULL) return NULL;
+    if (d->report_scope_str != NULL) return d->report_scope_str;
+    
+    for (i=0; i < 31; i++)
+        if (SOME_CONDS_MET(d->scorecalc_conds,EVENT_CONDITION_NUM(i))) numconds++;
+    
+    str= (char *)malloc(sizeof(char)*(numconds*(15+2)+1));
+    if (str == NULL) return NULL;
+    
+    tail= str;
+    for (i=31; i >= 0; i--)
+        if (SOME_CONDS_MET(d->scorecalc_conds,EVENT_CONDITION_NUM(i))) {
+            char* new= scope_str_for_cond(EVENT_CONDITION_NUM(i));
+            if (new == NULL) continue; /* nothing to add */
+            if (tail != str) {
+                *tail= ',';
+                *(tail+1)= ' ';
+                tail+= 2;
+            }
+            strcpy(tail,new);
+            tail+= strlen(new);
+        }
+
+   d->report_scope_str= str;
+   return str;         
+}
+
+static void condprinter(FILE *file,event_condition_set conds) {
+    int i,first=1;
+    for (i=31; i >= 0; i--)
+        if (SOME_CONDS_MET(conds,EVENT_CONDITION_NUM(i))) {
+            if (first) {
+                first= 0;
+            } else {
+                fprintf(file,", ");
+            }
+            fprintf(file,"%s",scope_str_for_cond(EVENT_CONDITION_NUM(i)));
+        }
+}
+
+static char *scope_str_for_cond(event_condition_set cond) {
+    switch (cond) {
+        case IS_TCP: return "tcp";
+        case IS_UDP: return "udp";
+        case IS_ICMP: return "icmp";
+        case ICMPNOTERR: return "non-err icmp";
+        case ICMPERR: return "error icmp";
+        case IS_UNRCHTCP: return "returned tcp";
+        case IS_UNRCHUDP: return "returned udp";
+        case IS_UNRCHICMP: return "returned icmp";
+        case SYNONLY: return "syn";
+        case NORMAL_RST: return "rst";
+        case SYNACK: return "synack";
+        case WEIRDFLAGS: return "weird flags";
+        case SETUPFLAGS: return "setup flags";
+        case ESTFLAGS: return "est. flags";
+        case TEARDOWNFLAGS: return "teardown flags";
+        case SIP_IN_HOMENET: return "local source";
+        case SIP_NOT_IN_HOMENET: return "nonlocal source";
+        case DIP_IN_HOMENET: return "local dest";
+        case DIP_NOT_IN_HOMENET: return "nonlocal dest";
+        case UDPRESP: return "udp response";
+        case ICMPRESP: return "icmp response";
+        case SYNRESP: return "syn response";
+        case ESTRESP: return "est. response";
+        case TEARDOWNRESP: return "teardown response";
+        case SETUPRESP: return "setup response";
+        case REPR_PKT: return "representative";
+        default: return NULL;
+    }
+}
+
+static netspade_detector *acquire_detector_for_id(netspade *self,char *id) {
+    netspade_detector *detector;
+    if (id == NULL) {
+        if (self->detectors == NULL) netspade_new_detector(self,"id=default");
+        return self->detectors_tail; /* return most recent detector */
+    }
+    detector= detector_for_id(self,id);
+    if (detector == NULL) {
+        char detect_str[45];
+        sprintf(detect_str,"id=%s",id);
+        netspade_new_detector(self,detect_str);
+        detector= detector_for_id(self,id);
+    }
+    return detector;
+}
+
+static netspade_detector *detector_for_id(netspade *self,char *id) {
+    netspade_detector *detector;
+    for (detector= self->detectors; detector != NULL; detector=detector->next) {
+        if (!strcmp(detector->id,id)) {
+            return detector;
+        }
+    }
+    return NULL;
+}
+
+static void netspade_detector_dump(netspade_detector *detector) {
+    score_mgr_dump(&detector->mgr);
+}
+static void netspade_detector_cleanup(netspade_detector *detector) {
+    score_mgr_cleanup(&detector->mgr);
+}
+
+static void netspade_update_conds_to_calc(netspade *self) {
+    if (!self->recorder_needed_conds)
+        self->recorder_needed_conds= event_recorder_needed_conds(&self->recorder);
+    if (!self->nonstore_conds)
+        self->nonstore_conds= netspade_nonstore_conds(self);
+        
+    self->conds_to_calc= CONDS_PLUS_CONDS(self->recorder_needed_conds,self->nonstore_conds);
+}
+
+static event_condition_set netspade_nonstore_conds(netspade *self) {
+    netspade_detector *detector;
+    event_condition_set nonstore_conds= 0;
+    for (detector= self->detectors; detector != NULL; detector=detector->next) {
+        ADD_TO_CONDS(nonstore_conds,CONDS_PLUS_2CONDS(detector->scorecalc_conds,detector->cancel_open_conds,detector->cancel_closed_conds));
+    }
+    return nonstore_conds;
+}
+
+static event_condition_set flipped_homenet_conds(event_condition_set orig) {
+    event_condition_set flipped=0;
+    if (SOME_CONDS_MET(orig,SIP_IN_HOMENET)) {
+        ADD_TO_CONDS(flipped,DIP_IN_HOMENET);
+    }
+    if (SOME_CONDS_MET(orig,SIP_NOT_IN_HOMENET)) {
+        ADD_TO_CONDS(flipped,DIP_NOT_IN_HOMENET);
+    }
+    if (SOME_CONDS_MET(orig,DIP_IN_HOMENET)) {
+        ADD_TO_CONDS(flipped,SIP_IN_HOMENET);
+    }
+    if (SOME_CONDS_MET(orig,DIP_NOT_IN_HOMENET)) {
+        ADD_TO_CONDS(flipped,SIP_NOT_IN_HOMENET);
+    }
+    return flipped;
+}
+
+
+static int do_checkpointing(netspade *self) {
+    statefile_ref *ref= spade_state_begin_checkpointing(self->checkpoint_file,"netspade",2);
+    if (ref == NULL) return 0;
+    
+    return event_recorder_checkpoint(&self->recorder,ref)
+        /* could checkpoint detectors in here */
+        && spade_state_end_checkpointing(ref);
+}
+
+static int do_recovery(netspade *self,char *statefile) {
+    char *appname;
+    u8 file_app_fvers;
+    
+    statefile_ref *ref= spade_state_begin_recovery(statefile,2,&appname,&file_app_fvers);
+    if (ref == NULL) return 0;
+    if (strcmp(appname,"netspade")) return 0;
+    
+    return event_recorder_merge_recover(&self->recorder,ref)
+        /* would checkpoint detectors in here; if we checkpointed that */
+        && spade_state_end_recovery(ref);
+}
+
+static void threshold_was_exceeded(void *context,void *mgrref,spade_event *pkt,score_info *score) {
+    netspade *self= (netspade *)context;
+    netspade_detector *detector= (netspade_detector *)mgrref;
+    char *id= detector->id;
+    port_status_t port_status= detector->thresh_exc_port_impl;
+    
+    /* first check if this report should be excluded */
+    if (pkt_is_excluded(self->rpt_exclude_list,pkt) ||
+            pkt_is_excluded(detector->rpt_exclude_list,pkt)) {
+        detector->enviro.pkt_stats.excluded++;
+        return;
+    } else {
+        detector->enviro.pkt_stats.nonexcluded++;
+    }
+    
+    if (PS_IN_SET(detector->port_report_criterea,port_status)) {
+        spade_report *rpt= new_spade_report(pkt,score,detector->detect_type,id,SPADE_DN_TYPE_MEDDESCR4NUM(detector->report_detection_type),netspade_detector_scope_str(self,id),&detector->enviro.pkt_stats,port_status);
+        (*(self->exc_callback))(self->callback_context,rpt);
+        free_spade_report(rpt);
+        detector->enviro.pkt_stats.reported++;
+    } else if (detector->canceller != NULL) {
+        /* we didn't meet criterea for reporting yet, and we have a canceller avail, so use it */
+        spade_event *newpkt= spade_event_clone(pkt,self->pkt_native_copier_callback,self->pkt_native_freer_callback);
+        score_info *newscore= score_info_clone(score);
+        spade_report *rpt= new_spade_report(newpkt,newscore,detector->detect_type,id,SPADE_DN_TYPE_MEDDESCR4NUM(detector->report_detection_type),netspade_detector_scope_str(self,id),&detector->enviro.pkt_stats,port_status);
+        packet_resp_canceller_add_report(detector->canceller,rpt);
+        detector->enviro.pkt_stats.waited++;
+    } else {
+        /* drop the report since no canceller available to strengthen it; that was silly */
+    }
+}
+
+static void canceller_status_report(void *context,spade_report *rpt,port_status_t status) {
+    netspade_detector *d= (netspade_detector *)context;
+    netspade *self= d->parent;
+    if (self->debug_level > 1) formatted_spade_msg_send(SPADE_MSG_TYPE_DEBUG,self->msg_callback,"canceller_status_report(%p,%p %8x:%d %8x:%d,%s)\n",d,rpt,rpt->pkt->fldval[SIP],rpt->pkt->fldval[SPORT],rpt->pkt->fldval[DIP],rpt->pkt->fldval[DPORT],PORT_STATUS_AS_STR(status));
+    if (PS_IN_SET(d->port_report_criterea,status)) {
+        /* met one of the critea so report it */
+        rpt->port_status= status;
+        (*(self->exc_callback))(self->callback_context,rpt);
+        if (rpt->stream_stats) {
+            rpt->stream_stats->reported++;
+        }
+    }
+    /* free report and pkt */
+    free_score_info(rpt->score);
+    free_spade_event(rpt->pkt);
+    free_spade_report(rpt);
+}
+
+static void threshold_was_adjusted(void *context,void *mgrref) {
+    char message[85];
+    spade_pkt_stats adj_period_stats;
+    netspade *self= (netspade *)context;
+    netspade_detector *detector= (netspade_detector *)mgrref;
+    int using_corrscore;
+    
+    adj_period_stats.scored= detector->enviro.pkt_stats.scored - detector->last_adj_stats.scored;
+    adj_period_stats.reported= detector->enviro.pkt_stats.reported - detector->last_adj_stats.reported;
+    detector->last_adj_stats= detector->enviro.pkt_stats; // copy over current stats for reference on next call
+    
+    sprintf(message,"Threshold adjusted to %.4f after %d alerts (of %d)",detector->enviro.thresh,adj_period_stats.reported,adj_period_stats.scored);
+
+    using_corrscore= score_calculator_using_corrscore(&detector->calculator);
+    (*(self->adj_callback))(self->callback_context,detector->id,message,using_corrscore);
+}
+
+
+static void netspade_add_net_to_homenet(netspade *self,char *net_str) {
+    ll_net *cur=NULL;
+
+    cur= (ll_net *)malloc(sizeof(ll_net));
+    cur->next= NULL;
+    if (self->homelist_head == NULL) {
+        self->homelist_head= cur;
+    } else {
+        self->homelist_tail->next= cur;
+    }
+    self->homelist_tail= cur;
+    
+    if (!cidr_to_netmask(net_str,&cur->netaddr,&cur->netmask)) {
+        formatted_spade_msg_send(SPADE_MSG_TYPE_FATAL,self->msg_callback,"Could not interpret homenet network: %s",net_str);
+    }
+}
+
+
+
+void netspade_write_log(netspade *self) {
+    FILE *file;
+    netspade_detector *detector;
+
+    if (!strcmp(self->outfile,"-")) {
+        file= stdout;
+    } else {
+        file = fopen(self->outfile, "w");
+        if (!file) formatted_spade_msg_send(SPADE_MSG_TYPE_FATAL,self->msg_callback,"netspade: unable to open %s",self->outfile);
+    }
+
+    fprintf(file,"%ld total packets were processed by spade in this run\n\n",self->total_pkts);
+    for (detector= self->detectors; detector != NULL; detector=detector->next) {
+        spade_pkt_stats *stats= &detector->enviro.pkt_stats;
+        int scored= stats->scored;
+        int was_anom= stats->nonexcluded + stats->excluded;
+        fprintf(file,"** %s: %s (id=%s) **\n",SPADE_DN_TYPE_MEDDESCR4NUM(detector->report_detection_type),detector->report_scope_str,detector->id);
+        fprintf(file,"%d packets were evaluated\n",stats->scored);
+        fprintf(file,"  %d (%.2f%%) packets were considered anomalous\n",was_anom,((was_anom/(float)scored)*100));
+        if (stats->excluded > 0) 
+            fprintf(file,"    %d (%.2f%%) packets were dropped due to configured exclusion\n",stats->excluded,((stats->excluded/(float)scored)*100));
+        if (stats->waited > 0) 
+            fprintf(file,"    %d (%.2f%%) packets were inserted in the wait queue\n",stats->waited,((stats->waited/(float)scored)*100));
+        fprintf(file,"    %d (%.2f%%) packets were reported as alerts\n",stats->reported,((stats->reported/(float)scored)*100));
+        if (stats->insuffobsed > 0) 
+            fprintf(file,"  %d (%.2f%%) packets did not have enough observations\n",stats->insuffobsed,((stats->insuffobsed/(float)scored)*100));
+        if (stats->respchecked > 0) 
+            fprintf(file,"  %d packets were checked against the wait queue\n",stats->respchecked);
+        fprintf(file,"%d observations were stored\n",score_calculator_get_store_count(&detector->calculator));
+        fprintf(file,"%.4f observations are remembered\n",score_calculator_get_obs_count(&detector->calculator));
+        score_mgr_file_print_log(&detector->mgr,file);
+        fprintf(file,"\n");
+    }
+    fflush(file);
+    
+    if (self->stats_to_print != STATS_NONE)
+        event_recorder_write_stats(&self->recorder,file,self->stats_to_print,condprinter);
+        
+    if (file != stdout) {
+        fclose(file);
+    }
+}
+
+void print_conds_line(event_condition_set conds) {
+    file_print_conds(stdout,conds);
+    printf("\n");
+}
+
+void print_conds(event_condition_set conds) {
+    file_print_conds(stdout,conds);
+}
+
+static void file_print_conds(FILE *f,event_condition_set conds) {
+    int first= 1;
+    if (SOME_CONDS_MET(conds,EVENT_CONDITION_FALSE)) {
+        fprintf(f,"FALSE");
+        return;
+    }
+    fprintf(f,"{");
+    if (SOME_CONDS_MET(conds,IS_TCP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"TCP");
+    }
+    if (SOME_CONDS_MET(conds,IS_UDP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"UDP");
+    }
+    if (SOME_CONDS_MET(conds,IS_ICMP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"ICMP");
+    }
+    if (SOME_CONDS_MET(conds,ICMPNOTERR)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"ICMPNOTERR");
+    }
+    if (SOME_CONDS_MET(conds,ICMPERR)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"ICMPERR");
+    }
+    if (SOME_CONDS_MET(conds,IS_UNRCHTCP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"IS_UNRCHTCP");
+    }
+    if (SOME_CONDS_MET(conds,IS_UNRCHUDP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"IS_UNRCHUDP");
+    }
+    if (SOME_CONDS_MET(conds,IS_UNRCHICMP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"IS_UNRCHICMP");
+    }
+    if (SOME_CONDS_MET(conds,NORMAL_RST)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"NORMAL_RST");
+    }
+    if (SOME_CONDS_MET(conds,SYNACK)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"SYNACK");
+    }
+    if (SOME_CONDS_MET(conds,WEIRDFLAGS)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"WEIRDFLAGS");
+    }
+    if (SOME_CONDS_MET(conds,SETUPFLAGS)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"SETUP");
+    }
+    if (SOME_CONDS_MET(conds,ESTFLAGS)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"EST");
+    }
+    if (SOME_CONDS_MET(conds,TEARDOWNFLAGS)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"TEARDOWN");
+    }
+    if (SOME_CONDS_MET(conds,SIP_IN_HOMENET)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"SIP_IS_HOME");
+    }
+    if (SOME_CONDS_MET(conds,SIP_NOT_IN_HOMENET)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"!SIP_IS_HOME");
+    }
+    if (SOME_CONDS_MET(conds,DIP_IN_HOMENET)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"DIP_IS_HOME");
+    }
+    if (SOME_CONDS_MET(conds,DIP_NOT_IN_HOMENET)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"!DIP_IS_HOME");
+    }
+    if (SOME_CONDS_MET(conds,REPR_PKT)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"REPR_PKT");
+    }
+    if (SOME_CONDS_MET(conds,UDPRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"UDPRESP");
+    }
+    if (SOME_CONDS_MET(conds,ICMPRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"ICMPRESP");
+    }
+    if (SOME_CONDS_MET(conds,SYNRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"SYNRESP");
+    }
+    if (SOME_CONDS_MET(conds,ESTRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"ESTRESP");
+    }
+    if (SOME_CONDS_MET(conds,TEARDOWNRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"TEARDOWNRESP");
+    }
+    if (SOME_CONDS_MET(conds,SETUPRESP)) {
+        if (!first) { fprintf(f,","); } first=0;
+        fprintf(f,"SETUPRESP");
+    }
+    fprintf(f,"}");
+}
+
+int netspade_print_detector_config_details(netspade *self,FILE *f,char *id) {
+    netspade_detector *d= detector_for_id(self,id);
+    if (d == NULL) return 0;
+    
+    fprintf(f,"id=%s; detect_type=%s\n",d->id,SPADE_DR_TYPE_SHORT4NUM(d->detect_type));
+    fprintf(f,"scorecalc_conds= ");
+    file_print_conds(f,d->scorecalc_conds);
+    fprintf(f,"; store_conds= ");
+    file_print_conds(f,d->store_conds);
+    fprintf(f,"\n");
+
+    fprintf(f,"calculator=\n");
+    score_calculator_print_config_details(&d->calculator,f,"  ");
+    fprintf(f,"mgr=\n");
+    score_mgr_print_config_details(&d->mgr,f,"  ");
+    
+    fprintf(f,"port_report_criterea=");
+    port_status_set_file_print(d->port_report_criterea,f);
+    fprintf(f,"\n");
+    if (d->canceller != NULL) {
+        fprintf(f,"canceller=\n");
+        packet_resp_canceller_print_config_details(d->canceller,f,"  ");
+        fprintf(f,"cancel_open_conds= ");
+        file_print_conds(f,d->cancel_open_conds);
+        fprintf(f,"; cancel_closed_conds= ");
+        file_print_conds(f,d->cancel_closed_conds);
+        fprintf(f,"\n");
+    }
+    
+    fprintf(f,"report_detection_type=%d\n",d->report_detection_type);
+    return 1;
+}
+
+static void process_netspade_xarg(netspade *self,char *str,features feat,xarg_type_t type) {
+    xfeatval_link *list,*list_tail;
+
+    list= process_xarg(str,feat,type,self->msg_callback,&list_tail);
+    if (list == NULL) return;
+    
+    /* prepend this list onto the detector */
+    list_tail->next= self->rpt_exclude_list;
+    self->rpt_exclude_list= list;
+}
+
+static void process_detector_xargs(netspade_detector *d,char *xsips,char *xdips,char *xsports,char *xdports) {
+    d->rpt_exclude_list= NULL;
+    process_detector_xarg(d,xsports,SPORT,XARG_TYPE_UINT);
+    process_detector_xarg(d,xdips,DIP,XARG_TYPE_CIDR);
+    process_detector_xarg(d,xsips,SIP,XARG_TYPE_CIDR);
+    process_detector_xarg(d,xdports,DPORT,XARG_TYPE_UINT);
+}
+
+static void process_detector_xarg(netspade_detector *d,char *str,features feat,xarg_type_t type) {
+    xfeatval_link *list,*list_tail;
+
+    list= process_xarg(str,feat,type,d->parent->msg_callback,&list_tail);
+    if (list == NULL) return;
+    
+    /* prepend this list onto the detector */
+    list_tail->next= d->rpt_exclude_list;
+    d->rpt_exclude_list= list;
+}
+
+static xfeatval_link *process_xarg(char *str,features feat,xarg_type_t type,spade_msg_fn msg_callback,xfeatval_link **tail) {
+    xfeatval_link *list=NULL,*new;
+    char *val;
+    
+    *tail= NULL;
+
+    if (str == NULL || str[0] == '\0') return NULL;
+    val= strtok(str,",");
+    while (val != NULL) {
+        new= new_xfeatval_link(feat,type,val);
+        if (new == NULL) {
+            if (type == XARG_TYPE_CIDR)
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,msg_callback,"could not parse %s as a IP or network to exclude for detector %s; skipping it");
+            else
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,msg_callback,"could not parse %s as an unsigned integer to exclude for detector %s; skipping it");
+            continue;
+        }
+        
+        /* append */
+        if (list == NULL) {
+            list= new;
+        } else {
+            (*tail)->next= new;
+        }
+        *tail= new;
+        
+        val= strtok(NULL,",");
+    }
+    return list;
+}
+
+static xfeatval_link *new_xfeatval_link(features feat,xarg_type_t type,char *val) {
+    xfeatval_link *new= (xfeatval_link *)malloc(sizeof(xfeatval_link));
+    if (new == NULL) return NULL;
+    
+    new->feat= feat;
+    new->type= type;
+    new->next= NULL;
+    
+    if (type == XARG_TYPE_CIDR) {
+        if (!cidr_to_netmask(val,&new->val.cidr.netip,&new->val.cidr.netmask)) {
+            free(new);
+            return NULL;
+        }
+    } else { // XARG_TYPE_UINT
+        if (val[0] < '0' || val[0] > '9') {
+            free(new);
+            return NULL;
+        }
+        new->val.i= atoi(val);
+    }
+    return new;
+}
+
+static int pkt_is_excluded(xfeatval_link *list,spade_event *pkt) {
+    xfeatval_link *x;
+    for (x= list; x != NULL; x= x->next) {
+        u32 pktval= pkt->fldval[x->feat];
+        if ((x->type == XARG_TYPE_UINT)
+            ? (x->val.i == pktval)
+            : ((pktval & x->val.cidr.netmask) == x->val.cidr.netip)) { /* found one to exclude */
+            return 1; 
+        }
+    }
+    return 0;
+}
+
+static int cidr_to_netmask(char *str,u32 *netip,u32 *netmask) {
+    char *sep;
+    int masklen;
+    struct in_addr net;
+    char *strcopy= strdup(str);
+    
+    if ((sep= strchr(strcopy,'/')) == NULL) {
+        masklen= 32;
+    } else { 
+        *sep= '\0'; // null terminate IP
+        masklen = atoi(sep+1);
+    }
+
+    if ((masklen >= 0) && (masklen <= 32)) {
+        *netmask = (~((u32)0))<<(32-masklen);
+    } else {
+        free(strcopy);
+        return 0;
+    }
+
+    /* convert the IP addr into its 32-bit value */
+    if ((net.s_addr = inet_addr(strcopy)) ==-1) {
+        if (!strcmp(strcopy,"any")) {
+            *netmask= 0;
+            *netip= 0;
+        } else {
+            free(strcopy);
+            return 0;
+        }
+    } else {
+        *netip = (ntohl((u_long)net.s_addr) & *netmask);
+    }
+    free(strcopy);
+    return 1;
+}
+
+/*@}*/
+
+/* Id: netspade.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+packet_resp_canceller.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+packet_resp_canceller.c implements the "class" packet_resp_canceller which
+  buffers spade reports for a period of time, awaiting information that
+  the port is open
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file packet_resp_canceller.c
+ * \ingroup netspade_layer
+ * \brief 
+ *  packet_resp_canceller.c implements the "class" packet_resp_canceller
+ *  which buffers spade reports for a period of time, awaiting information
+ *  that the port is open
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <netinet/in.h>
+
+//static void lt_extract(packet_resp_canceller *self, prc_link *todel, prc_link *prev, u16 hash1, u32 hash2);
+static void ltl_extract(prc_lookup_table *lt, prc_link *todel, prc_link *prev, u16 hash1, u32 hash2);
+static int lt_delete_report(prc_lookup_table *lt, spade_report *rpt);
+static prc_link *new_prc_link(spade_report *rpt);
+static void free_prc_ttl_list(prc_link *head);
+//static void free_prc_link(prc_link *l);
+static prc_lookup_table2 *new_prc_lookup_table2(void);
+static void init_prc_lookup_table2(prc_lookup_table2 *t);
+static void free_prc_lookup_table2(prc_lookup_table2 *t);
+static void free_prc_lookup_table2_clean(prc_lookup_table2 *t);
+
+#define u8_right_rotate(i,bits) ((i >> bits) | ((i & ((1 << bits)-1)) << (8-bits)))
+
+#define calc_hash1(sport,dport) ((sport ^ dport) & LOOKUP_TABLE1_MASK)
+#define calc_hash2(sip,dip,hash) { \
+    u32 _tmp= sip ^ dip; \
+    u8 _tmp1= _tmp & LOOKUP_TABLE2_MASK; \
+    u8 _tmp2= (_tmp & LOOKUP_TABLE2_MASK) >> 8; \
+    u8 _tmp3= (_tmp & LOOKUP_TABLE2_MASK) >> 16; \
+    u8 _tmp4= (_tmp & LOOKUP_TABLE2_MASK) >> 24; \
+    hash= _tmp1 \
+        ^  u8_right_rotate(_tmp2,2) \
+        ^  u8_right_rotate(_tmp3,4) \
+        ^  u8_right_rotate(_tmp4,6); \
+}
+
+/// free list of allocated prc_lookup_table2s
+prc_lookup_table2 *prc_lookup_table2_freelist= NULL;
+/// free list of allocated prc_links
+prc_link *prc_link_freelist= NULL;
+
+//int disp_hashinfo= 0;
+
+void init_packet_resp_canceller(packet_resp_canceller *self,int wait_secs,prc_report_status_fn status_callback,void *callback_context,port_status_t timeout_implication) {
+    int i;
+    
+    self->tt.num_buckets= wait_secs+1;
+    self->tt.last_timeout= (time_t)0;
+    self->tt.arr= (prc_list *)malloc(sizeof(prc_list)*self->tt.num_buckets);
+    for (i= 0; i <= wait_secs; i++) {
+        self->tt.arr[i].head= NULL;
+        self->tt.arr[i].tail= NULL;
+    }
+    
+    for (i= 0; i < LOOKUP_TABLE1_SIZE; i++) self->lt.arr[i]= NULL;
+    
+    self->status_callback= status_callback;
+    self->callback_context= callback_context;
+    self->timeout_implication= timeout_implication;
+}
+
+packet_resp_canceller *new_packet_resp_canceller(int wait_secs,prc_report_status_fn status_callback,void *callback_context,port_status_t timeout_implication) {
+    packet_resp_canceller *new= (packet_resp_canceller *)malloc(sizeof(packet_resp_canceller));
+    init_packet_resp_canceller(new,wait_secs,status_callback,callback_context,timeout_implication);
+    return new;
+}
+
+void free_packet_resp_canceller(packet_resp_canceller *self) {
+    int i;
+    /* free all the prc_link's */
+    for (i=0; i < self->tt.num_buckets; i++)
+        if (self->tt.arr[i].head != NULL)
+            free_prc_ttl_list(self->tt.arr[i].head);
+    
+    /* free the timeout table's array */
+    free(self->tt.arr);
+    
+    /* free all the prc_lookup_table2's */
+    for (i=0; i < LOOKUP_TABLE1_SIZE; i++)
+        if (self->lt.arr[i] != NULL)
+            free_prc_lookup_table2(self->lt.arr[i]);
+
+    /* free ourself */
+    free(self);
+}
+
+void packet_resp_canceller_new_time(packet_resp_canceller *self,time_t now) {
+    int i;
+    prc_link *l;
+    int count= now - self->tt.last_timeout;
+    //if (self->debug_level > 1) printf("packet_resp_canceller_new_time(%p,%d)\n",self,(int)now);
+    if (count > self->tt.num_buckets) count= self->tt.num_buckets;
+    for (i=1; i <= count; i++) {
+        int slot= (self->tt.last_timeout+i) % self->tt.num_buckets;
+        if (self->tt.arr[slot].head != NULL) {
+            for (l= self->tt.arr[slot].head; l != NULL; l= l->ttl_next) {
+                if (l->rpt != NULL) {
+                    /* send the report as closed and delete this from the lookup table */
+                    (*self->status_callback)(self->callback_context,l->rpt,self->timeout_implication);
+                    lt_delete_report(&self->lt,l->rpt);
+                }
+            }
+            free_prc_ttl_list(self->tt.arr[slot].head);
+            self->tt.arr[slot].head= NULL;
+            self->tt.arr[slot].tail= NULL;
+        }
+    }
+    self->tt.last_timeout= now;
+}
+
+void packet_resp_canceller_add_report(packet_resp_canceller *self,spade_report *rpt) {
+    spade_event *pkt= rpt->pkt;
+    u16 hash1;
+    u32 hash2;
+    prc_lookup_table2 *t2;
+    prc_link *new;
+    int slot;
+    /*if (self->debug_level) printf("packet_resp_canceller_add_report(%p,%p %.2f %8x:%d %8x:%d)\n",self,rpt,rpt->pkt->time,rpt->pkt->fldval[SIP],rpt->pkt->fldval[SPORT],rpt->pkt->fldval[DIP],rpt->pkt->fldval[DPORT]);*/
+    
+    if ((pkt->fldval[IPPROTO] == IPPROTO_TCP) || (pkt->fldval[IPPROTO] == IPPROTO_UDP))
+        hash1= calc_hash1(pkt->fldval[SPORT],pkt->fldval[DPORT]);
+    else
+        hash1= calc_hash1(pkt->fldval[SIP],pkt->fldval[DIP]);
+    //if (disp_hashinfo) printf(": addrep hash1(%d,%d) => %d\n",pkt->fldval[SPORT],pkt->fldval[DPORT],hash1);
+    if (self->lt.arr[hash1] == NULL) self->lt.arr[hash1]= new_prc_lookup_table2();
+    t2= self->lt.arr[hash1];
+    calc_hash2(pkt->fldval[SIP],pkt->fldval[DIP],hash2);
+    //if (disp_hashinfo) printf(": addrep hash2(%08x,%08x) => %d\n",pkt->fldval[SIP],pkt->fldval[DIP],hash2);
+    new= new_prc_link(rpt);
+    if (t2->arr[hash2] == NULL) { // first entry here
+        t2->num_used++;
+    } else {
+        new->ltl_next= t2->arr[hash2];
+    }
+    t2->arr[hash2]= new;
+    
+    // append in time table
+    slot= ((int)pkt->time) % self->tt.num_buckets;
+    if (self->tt.arr[slot].tail == NULL) {
+        self->tt.arr[slot].head= new;
+    } else {
+        self->tt.arr[slot].tail->ttl_next= new;
+    }
+    self->tt.arr[slot].tail= new;
+    //fflush(stdout);
+}
+
+void packet_resp_canceller_note_response(packet_resp_canceller *self,port_status_t implied_status,u32 sip,u16 sport,u32 dip,u16 dport,int portless) {
+    prc_link *l,*prev,*next,*newprev;
+    u32 hash2;
+    prc_lookup_table2 *t2;
+    u16 hash1= portless ? calc_hash1(sip,dip) : calc_hash1(sport,dport);
+    //if (disp_hashinfo) printf(": noteresp hash1(%d,%d) => %d\n",sport,dport,hash1);
+    /*if (self->debug_level) printf("packet_resp_canceller_note_response(%p,%s,%8x:%d %8x:%d,%d)\n",self,PORT_STATUS_AS_STR(implied_status),sip,sport,dip,dport,portless);*/
+    
+    if (self->lt.arr[hash1] == NULL) return;
+    t2= self->lt.arr[hash1];
+    calc_hash2(sip,dip,hash2);
+    //if (disp_hashinfo) printf(": noteresp hash2(%08x,%08x) => %d\n",sip,dip,hash2);
+    if (t2->arr[hash2] == NULL) return;
+    for (l= t2->arr[hash2], prev=NULL; l != NULL; prev=newprev,l=next) {
+        next= l->ltl_next; /* in case this link is removed */
+        newprev= l;
+        if (l->rpt == NULL) continue; /* shouldn't happen */
+        if (l->rpt->pkt->fldval[SIP] != sip) continue;
+        if (l->rpt->pkt->fldval[DIP] != dip) continue;
+        if (l->rpt->pkt->fldval[SPORT] != sport) continue;
+        if (l->rpt->pkt->fldval[DPORT] != dport) continue;
+        /* found a match */
+        ltl_extract(&self->lt,l,prev,hash1,hash2);
+        (*self->status_callback)(self->callback_context,l->rpt,implied_status);
+        l->rpt= NULL; /* mark as deleted from lookup table */
+        newprev= prev;
+        /* check for more matches */
+    }
+    //fflush(stdout);
+}
+
+#if 0 // not currently needed
+static void lt_extract(packet_resp_canceller *self,prc_link *todel,prc_link *prev,u16 hash1,u32 hash2) {
+    ltl_extract(&self->lt,todel,prev,hash1,hash2);
+}
+#endif
+
+static void ltl_extract(prc_lookup_table *lt,prc_link *todel,prc_link *prev,u16 hash1,u32 hash2) {
+    if (prev == NULL) {
+        if (todel->ltl_next == NULL) {
+            lt->arr[hash1]->arr[hash2]= NULL;
+            lt->arr[hash1]->num_used--;
+            if (lt->arr[hash1]->num_used == 0) {
+                free_prc_lookup_table2_clean(lt->arr[hash1]);
+                lt->arr[hash1]= NULL;
+            }
+        } else {
+            lt->arr[hash1]->arr[hash2]= todel->ltl_next;
+        }
+    } else {
+        prev->ltl_next= todel->ltl_next;
+    }
+}
+
+static int lt_delete_report(prc_lookup_table *lt,spade_report *rpt) {
+    prc_link *l,*prev;
+    u32 hash2;
+    prc_lookup_table2 *t2;
+    spade_event *pkt= rpt->pkt;
+    u16 hash1;
+    if ((pkt->fldval[IPPROTO] == IPPROTO_TCP) || (pkt->fldval[IPPROTO] == IPPROTO_UDP))
+        hash1= calc_hash1(pkt->fldval[SPORT],pkt->fldval[DPORT]);
+    else
+        hash1= calc_hash1(pkt->fldval[SIP],pkt->fldval[DIP]);
+    
+    if (lt->arr[hash1] == NULL) return 0;
+    t2= lt->arr[hash1];
+    calc_hash2(pkt->fldval[SIP],pkt->fldval[DIP],hash2);
+    if (t2->arr[hash2] == NULL) return 0;
+    for (l= t2->arr[hash2], prev=NULL; l != NULL && l->rpt != rpt; prev=l,l=l->ltl_next);
+    if (l == NULL) return 0; /* no match */
+    ltl_extract(lt,l,prev,hash1,hash2);
+    return 1;
+}
+
+static prc_link *new_prc_link(spade_report *rpt) {
+    prc_link *new;
+    if (prc_link_freelist == NULL) {
+        new= (prc_link *)malloc(sizeof(prc_link));
+        if (new == NULL) return NULL;
+    } else {
+        new= prc_link_freelist;
+        prc_link_freelist= prc_link_freelist->ttl_next;
+    }
+    new->rpt= rpt;
+    new->ltl_next= NULL;    
+    new->ttl_next= NULL;    
+    return new;
+}
+
+static void free_prc_ttl_list(prc_link *head) {
+    prc_link *tail;
+    if (head == NULL) return;
+    for (tail= head; tail->ttl_next != NULL; tail= tail->ttl_next);
+    tail->ttl_next= prc_link_freelist;
+    prc_link_freelist= head;  
+}
+
+#if 0 // not currently needed
+static void free_prc_link(prc_link *l) {
+    if (l == NULL) return;
+    l->ttl_next= prc_link_freelist;
+    prc_link_freelist= l;  
+}
+#endif 
+
+static prc_lookup_table2 *new_prc_lookup_table2() {
+    prc_lookup_table2 *new;
+    
+    if (prc_lookup_table2_freelist == NULL) {
+        new= (prc_lookup_table2 *)malloc(sizeof(prc_lookup_table2));
+        if (new == NULL) return NULL;
+        init_prc_lookup_table2(new);
+    } else {
+        new= prc_lookup_table2_freelist;
+        prc_lookup_table2_freelist= (prc_lookup_table2 *)prc_lookup_table2_freelist->arr[0];
+        /* items on freelist are pre-inited for efficiency except for arr[0] */
+        new->arr[0]= NULL;
+    }
+    return new;
+}
+
+static void init_prc_lookup_table2(prc_lookup_table2 *t) {
+    int i;
+    t->num_used= 0;
+    for (i= 0; i < LOOKUP_TABLE2_SIZE; i++) t->arr[i]= NULL;
+}
+
+static void free_prc_lookup_table2(prc_lookup_table2 *t) {    
+    init_prc_lookup_table2(t);
+    free_prc_lookup_table2_clean(t);
+}
+
+/* t is expected to be cleaned up to to an empty state */
+static void free_prc_lookup_table2_clean(prc_lookup_table2 *t) {    
+    if (t == NULL) return;
+    t->arr[0]= (prc_link *)prc_lookup_table2_freelist;
+    prc_lookup_table2_freelist= t;  
+}
+
+void packet_resp_canceller_print_config_details(packet_resp_canceller *self,FILE *f,char *indent) {
+    fprintf(f,"%swait=%d; timeout_implication=%s\n",indent,self->tt.num_buckets,PORT_STATUS_AS_STR(self->timeout_implication));
+}
+
+/*@}*/
+
+/* Id: packet_resp_canceller.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+/*********************************************************************
+spade_report.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+
+#include <stdlib.h>
+#include <string.h>
+
+/*! \file spade_report.c
+ * \ingroup netspade_layer
+ * \brief 
+ *  spade_report.c contains routines for spade_report allocation, initing, and
+ *  recycling; spade_report reprents a report that Spade is making
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+/* creation and recycling routines for spade_report's */
+spade_report *spade_report_freelist=NULL;
+
+spade_report *new_spade_report(spade_event *pkt,score_info *score, int detect_type, char *detectorid,const char *detect_type_str,char *scope_str,spade_pkt_stats *stream_stats,port_status_t port_status) {
+    spade_report *new;
+    if (spade_report_freelist != NULL) {
+        new= spade_report_freelist;
+        spade_report_freelist= new->next;
+    } else {
+        new= (spade_report *)malloc(sizeof(spade_report));
+    }
+    
+    new->pkt= pkt;
+    new->score=score;
+    new->detect_type= detect_type;
+    new->detectorid= detectorid;
+    new->stream_stats= stream_stats;
+    new->port_status= port_status;
+    new->detect_type_str= detect_type_str;
+    if (scope_str != NULL)
+        strncpy(new->scope_str,scope_str,200);
+    else
+        new->scope_str[0]= '\0';
+    new->next= NULL;
+    return new;
+}
+
+void free_spade_report(spade_report *rpt) {
+    rpt->next= spade_report_freelist;
+    spade_report_freelist= rpt;
+}
+
+void free_spade_reports(spade_report *start) {
+    spade_report *end,*next;
+    for (end= start, next=start->next; next != NULL; end=next,next=next->next);
+    end->next= spade_report_freelist;
+    spade_report_freelist= start;
+}
+
+void port_status_set_file_print(port_status_set_t set,FILE *f) {
+    int first= 1;
+    int i;
+    fprintf(f,"{");
+    if ((set & 0xFFF) == 0xFFF)
+        fprintf(f,"*ALL*");
+    else {
+        for (i=0; i < 16; i++) {
+            if (PS_IN_SET(set,i)) {
+                if (!first) { fprintf(f,","); }
+                first=0;
+                fprintf(f,"%s",PORT_STATUS_AS_STR(i));
+            }
+        }
+    }
+    fprintf(f,"}");
+}
+
+/*@}*/
+
+/* Id: spade_report.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+score_mgr.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+
+/*! \file score_mgr.c
+ * \brief 
+ *  score_mgr.c contains the "class" score_mgr which is a spade
+ *  probability table along with a reporting threshold and the
+ *  other accompaniments of applying the Spade approach to somewhere.
+ * \ingroup stmgr
+ */
+
+/*! \addtogroup stmgr Score and threshold management
+ * \brief this group contains objects to manaage anomaly scores and reporting thresholds
+ * \ingroup libspade
+    @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+score_mgr *new_score_mgr(void *mgrref,spade_enviro *enviro,void *callback_context,spade_thresh_exceeded_fn_t threshexceeded_callback,spade_thresh_changed_fn_t threshchanged_callback,spade_msg_fn msg_callback) {
+    score_mgr *new= (score_mgr *)malloc(sizeof(score_mgr));
+    init_score_mgr(new,mgrref,enviro,callback_context,threshexceeded_callback,threshchanged_callback,msg_callback);
+    return new;
+}
+
+/* caller must set enviro->thresh already; we'll keep a pointer to the enviro */
+void init_score_mgr(score_mgr *self,void *mgrref,spade_enviro *enviro, void *callback_context, spade_thresh_exceeded_fn_t threshexceeded_callback, spade_thresh_changed_fn_t threshchanged_callback,spade_msg_fn msg_callback) {
+    self->mgrref= mgrref;
+    self->enviro= enviro;
+
+    self->threshexceeded_callback= threshexceeded_callback;
+    self->threshchanged_callback= threshchanged_callback;
+    self->callback_context= callback_context != NULL ? callback_context : self;
+    
+    self->msg_callback= msg_callback;
+   
+    self->adapt_active= 0;
+    self->advise_status= ADVISING_OFF;
+    self->survey_active= 0;
+}
+
+void score_mgr_setup_adapt_from_str(score_mgr *self,int adaptmode,char *str) {
+    self->adapt_active= 1;
+    init_thresh_adapter(&self->adapter,self->msg_callback);
+    thresh_adapter_setup_from_str(&self->adapter,adaptmode,str);
+}
+
+void score_mgr_setup_adapt1(score_mgr *self,int target, time_t period, float new_obs_weight, int by_count) {
+    self->adapt_active= 1;
+    init_thresh_adapter(&self->adapter,self->msg_callback);
+    thresh_adapter_setup_1(&self->adapter,target,period,new_obs_weight,by_count);
+}
+
+void score_mgr_setup_adapt2(score_mgr *self,double targetspec, double obsper, int NS, int NM, int NL) {
+    self->adapt_active= 2;
+    init_thresh_adapter(&self->adapter,self->msg_callback);
+    thresh_adapter_setup_2(&self->adapter,targetspec,obsper,NS,NM,NL);
+}
+
+void score_mgr_setup_adapt3(score_mgr *self,double targetspec, double obsper, int NO) {
+    self->adapt_active= 3;
+    init_thresh_adapter(&self->adapter,self->msg_callback);
+    thresh_adapter_setup_3(&self->adapter,targetspec,obsper,NO);
+}
+
+void score_mgr_setup_adapt4(score_mgr *self,double thresh, double obsper) {
+    self->adapt_active= 4;
+    init_thresh_adapter(&self->adapter,self->msg_callback);
+    thresh_adapter_setup_4(&self->adapter,thresh,obsper);
+}
+
+void score_mgr_setup_advise(score_mgr *self,int obs_size, int obs_secs) {
+    self->advise_status= ADVISING_RUNNING;
+    init_thresh_adviser(&self->adviser,obs_size,obs_secs,self->msg_callback);
+}
+
+void score_mgr_setup_advise_from_str(score_mgr *self,char *str) {
+    self->advise_status= ADVISING_RUNNING;
+    init_thresh_adviser_from_str(&self->adviser,str,self->msg_callback);
+}
+
+void score_mgr_setup_survey(score_mgr *self,char *filename,float interval) {
+    self->survey_active= 1;
+    init_anomscore_surveyer(&self->surveyer,filename,interval,self->msg_callback);
+}
+
+void score_mgr_setup_survey_from_str(score_mgr *self,char *str) {
+    self->survey_active= 1;
+    init_anomscore_surveyer_from_str(&self->surveyer,str,self->msg_callback);
+}
+
+
+
+int score_mgr_new_time(score_mgr *self,time_t time) {
+    int advising_completed= 0;
+    // a new second
+    self->enviro->now= time;
+
+    // tell our helpers
+    if (self->adapt_active) {
+        double new_thresh;
+        if (thresh_adapter_new_time(&self->adapter,self->enviro,&new_thresh)) {
+            // there is a new threshold
+            self->enviro->thresh= new_thresh;
+            if (self->threshchanged_callback != NULL)
+                (*(self->threshchanged_callback))(self->callback_context,self->mgrref);
+        }
+    }
+    if (self->advise_status == ADVISING_RUNNING) {
+        if (thresh_adviser_new_time(&self->adviser,self->enviro)) {
+            // advising period has completed
+            self->advise_status= ADVISING_DONE;
+            advising_completed= 1;
+        }
+    }
+    if (self->survey_active) anomscore_surveyer_new_time(&self->surveyer,self->enviro);
+    return advising_completed;
+}
+
+void score_mgr_new_event(score_mgr *self,score_info *score,spade_event *event) {
+    double mainscore= score_info_mainscore(score);
+
+    //if (self->debug_level > 1) printf("%p: packet #%d: %.4f\n",self,self->enviro->pkt_stats.scored,mainscore);
+    if (self->enviro->thresh >= 0.0 && mainscore >= self->enviro->thresh) {
+        if (self->threshexceeded_callback != NULL)
+            (*(self->threshexceeded_callback))(self->callback_context,self->mgrref,event,score);
+    }
+
+    if (self->adapt_active) thresh_adapter_new_score(&self->adapter,mainscore);
+    if (self->advise_status == ADVISING_RUNNING) thresh_adviser_new_score(&self->adviser,mainscore);
+    if (self->survey_active) anomscore_surveyer_new_score(&self->surveyer,mainscore);
+}
+
+void score_mgr_dump(score_mgr *self) 
+{
+    if (self->survey_active) anomscore_surveyer_flush(&self->surveyer);
+}
+
+void score_mgr_cleanup(score_mgr *self) 
+{
+    score_mgr_dump(self);
+}
+
+void score_mgr_file_print_log(score_mgr *self,FILE *file) {
+    if (self->advise_status != ADVISING_OFF) thresh_adviser_write_advice(&self->adviser,file);
+}
+
+void score_mgr_print_config_details(score_mgr *self, FILE *f, char *indent) {
+    char indent2[100];
+    sprintf(indent2,"%s  ",indent);
+    fprintf(f,"%scurrent thresh=%.4f\n",indent,self->enviro->thresh);
+    if (self->adapt_active) {
+        fprintf(f,"%sadapt_active=%d:\n",indent,self->adapt_active);
+        thresh_adapter_print_config_details(&self->adapter,f,indent2);
+    }
+    if (self->advise_status != ADVISING_OFF) {
+        fprintf(f,"%sadvise_status=%s:\n",indent,self->adapt_active == ADVISING_RUNNING ? "ADVISING_RUNNING" : "ADVISING_DONE");
+        thresh_adviser_print_config_details(&self->adviser,f,indent2);
+    }
+    if (self->survey_active) {
+        fprintf(f,"%ssurvey_active=\n",indent);
+        anomscore_surveyer_print_config_details(&self->surveyer,f,indent2);
+    }
+}
+
+/*@}*/
+/* Id: score_mgr.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+score_calculator.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file score_calculator.c
+ * \brief 
+ *  score_calculator.c contains a module to store the details about how
+ *  to calculate an anomaly score
+ * \ingroup scoreprod
+ */
+
+/*! \addtogroup scoreprod Anomaly score production
+ * \brief this group contains objects to produce and represent anomaly scores
+ * \ingroup libspade
+    @{
+*/
+
+#include <stdlib.h>
+#include <math.h>
+
+/*#define LOG10 2.30258509299 */
+#define LOG2 0.69314718056
+
+static table_use_specs *new_evfiles_specs(void);
+
+score_calculator *new_score_calculator(int prodcount,feature_list feats[],const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold,event_recorder *recorder,feature_list *calc_feats) {
+    score_calculator *new= (score_calculator *)malloc(sizeof(score_calculator));
+    init_score_calculator(new,prodcount,feats,featurenames,conds,scale_freq,scale_factor,prune_threshold,recorder,calc_feats);
+    return new;
+}
+
+void init_score_calculator(score_calculator *self,int prodcount,feature_list feats[],const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold,event_recorder *recorder,feature_list *calc_feats) {
+    init_score_calculator_clear(self,recorder);
+    self->prodcount= prodcount;
+    if (prodcount == 1) {
+        self->evfile= event_recorder_new_event_file(self->recorder,&feats[0],featurenames,conds,scale_freq,scale_factor,prune_threshold,0,calc_feats);
+    } else {
+        self->evfiles= event_recorder_new_event_files(self->recorder,prodcount,feats,featurenames,conds,scale_freq,scale_factor,prune_threshold,0);
+    }
+}
+
+score_calculator *new_score_calculator_clear(event_recorder *recorder) {
+    score_calculator *new= (score_calculator *)malloc(sizeof(score_calculator));
+    init_score_calculator_clear(new,recorder);
+    return new;
+}
+
+void init_score_calculator_clear(score_calculator *self,event_recorder *recorder) {
+    self->prodcount= -1;
+    self->evfile= NULL;
+    self->evfiles= NULL;
+    self->cond_prefix_len= 0;
+    self->use_corrscore= 1;
+    self->calc_relscore= 0;
+    self->calc_rawscore= 0;
+    self->mainpref= PREF_NOSCORE;
+    self->min_obs_prefix_len= 0;
+    self->min_obs_count= 0.0;
+    self->max_entropy= -1;
+    self->recorder= recorder;
+    self->evfiles_data= NULL;
+}
+
+void score_calculator_set_features(score_calculator *self,int prodcount,feature_list feats[],feature_list *calc_feats,const char **featurenames) {
+    int i;
+    if (self->evfiles_data == NULL) self->evfiles_data= new_evfiles_specs();
+    self->evfiles_data->prodcount= prodcount;
+    self->evfiles_data->feats= (feature_list*)malloc(sizeof(feature_list)*prodcount);
+    for (i= 0; i < prodcount; i++)
+        self->evfiles_data->feats[i]= feats[i];
+    if (calc_feats == NULL)
+        self->evfiles_data->calc_feats.num= 0;
+    else
+        self->evfiles_data->calc_feats= *calc_feats; /* copy over */
+    self->evfiles_data->featurenames= featurenames;
+}
+
+void score_calculator_set_storage_conditions(score_calculator *self,event_condition_set conds) {
+    if (self->evfiles_data == NULL) self->evfiles_data= new_evfiles_specs();
+    self->evfiles_data->conds= conds;
+}
+
+void score_calculator_set_scaling(score_calculator *self,int scale_freq,double scale_factor,double prune_threshold) {
+    if (self->evfiles_data == NULL) self->evfiles_data= new_evfiles_specs();
+    self->evfiles_data->scale_freq= scale_freq;
+    self->evfiles_data->scale_factor= scale_factor;
+    self->evfiles_data->prune_threshold= prune_threshold;
+}
+
+void score_calculator_init_complete(score_calculator *self) {
+    table_use_specs *d;
+    
+    if (self->evfiles_data == NULL) return; /* nothing to do */
+    d= self->evfiles_data;
+    if (d->feats== NULL) { /* no feature lists provided */
+        d->feats= (feature_list *)malloc(1*sizeof(feature_list));
+        d->feats[0].num= 1;
+        d->feats[0].feat[0]= 0;
+        d->prodcount= 1;
+    }
+    
+    self->prodcount= d->prodcount;
+    if (d->prodcount == 1) {
+        self->evfile= event_recorder_new_event_file(self->recorder,&d->feats[0],d->featurenames,d->conds,d->scale_freq,d->scale_factor,d->prune_threshold,0,(d->calc_feats.num==0 ?NULL:&d->calc_feats));
+    } else {
+        self->evfiles= event_recorder_new_event_files(self->recorder,d->prodcount,d->feats,d->featurenames,d->conds,d->scale_freq,d->scale_factor,d->prune_threshold,0);
+    }
+    free(self->evfiles_data->feats);
+    free(self->evfiles_data);
+    self->evfiles_data= NULL;
+}
+
+void score_calculator_set_condcutoff(score_calculator *self,int cond_prefix_len)
+{
+    self->cond_prefix_len= cond_prefix_len;
+}
+
+void score_calculator_set_relscore(score_calculator *self, int calc_relscore, int rel_is_main) {
+    self->calc_relscore= calc_relscore;
+    if (rel_is_main) self->mainpref= PREF_RELSCORE;
+}
+
+void score_calculator_set_rawscore(score_calculator *self, int calc_rawscore, int raw_is_main) {
+    self->calc_rawscore= calc_rawscore;
+    if (raw_is_main) self->mainpref= PREF_RAWSCORE;
+}
+
+void score_calculator_set_corrscore(score_calculator *self, int use_corrscore) {
+    self->use_corrscore= use_corrscore;
+}
+
+void score_calculator_set_min_obs(score_calculator *self,int featlist_prefix_len,int min_obs_count) {
+    self->min_obs_prefix_len= featlist_prefix_len;
+    self->min_obs_count= (double)min_obs_count;
+}
+
+void score_calculator_set_low_entropy_domain(score_calculator *self, int val_prefix_len, double max_entropy) {
+    self->max_entropy= max_entropy;
+    self->entropy_prefix_len= val_prefix_len;
+}
+
+void score_calculator_cleanup(score_calculator *self) {
+    if (self->prodcount > 0 && self->evfiles != NULL) free(self->evfiles);
+    self->prodcount= -1;
+}
+
+int score_calculator_using_corrscore(score_calculator *self) {
+    return self->use_corrscore || (self->prodcount > 0) || !self->calc_rawscore;
+}
+
+score_info *score_calculator_calc_event_score(score_calculator *self,spade_event *event,score_info* storage,int *enoughobs) {
+    int prodidx;
+    double prob;
+    double rawscore= NO_SCORE;
+    double relscore= NO_SCORE;
+    *enoughobs= 1;
+    
+    if (self->prodcount < 0) score_calculator_init_complete(self);
+            
+    if (self->prodcount > 1) { /* multiply together the straight maximally conditioned probabilities and return absolute score */
+        prob= 1;
+        for (prodidx= 0; prodidx < self->prodcount; prodidx++)
+            prob*= event_recorder_get_condprob(self->recorder,self->evfiles[prodidx],event,-1,1);
+        rawscore= -1*(log(prob)/LOG2);
+    } else {
+        if (self->min_obs_count > 0) {
+            double count= event_recorder_get_count(self->recorder,self->evfile,event,self->min_obs_prefix_len);
+            if ((count+1) < self->min_obs_count) {
+                *enoughobs= 0;
+                return NULL;
+            }
+        }
+        if (self->max_entropy > 0) {
+            double entropy;
+            entropy= event_recorder_get_entropy(self->recorder,self->evfile,event,self->entropy_prefix_len);
+            if (entropy > self->max_entropy) return NULL;
+        }
+        prob= event_recorder_get_condprob(self->recorder,self->evfile,event,self->cond_prefix_len,1);
+        if (self->calc_rawscore) { // calculate raw anomaly score
+            if (self->use_corrscore) { // use the scores that are computed as adverstised
+                rawscore= -1.0*(log(prob)/LOG2);
+            } else { // use the old, incorrectly computed joint score
+                rawscore= -1.0*log(prob/LOG2);
+            }
+        }
+        if (self->calc_relscore) { // calculate relative anomaly score
+            double basecount= event_recorder_get_count(self->recorder,self->evfile,event,self->cond_prefix_len)+1;
+            double ratio= log(prob)/log(1/basecount);
+            relscore= ratio; /* *ratio; */
+        }
+    }
+    if (storage == NULL)
+        return new_score_info(self->mainpref,relscore,rawscore,self->use_corrscore);
+    else {
+        init_score_info(storage,self->mainpref,relscore,rawscore,self->use_corrscore);
+        return storage;
+    }
+}
+
+
+int score_calculator_get_store_count(score_calculator *self) {
+    evfile_ref f= (self->prodcount > 1) ? self->evfiles[0] : self->evfile;
+    return event_recorder_get_store_count(self->recorder,f);
+}
+
+double score_calculator_get_obs_count(score_calculator *self) {
+    evfile_ref f= (self->prodcount > 1) ? self->evfiles[0] : self->evfile;
+    return event_recorder_get_obs_count(self->recorder,f);
+}
+
+static table_use_specs *new_evfiles_specs() {
+    table_use_specs *new= (table_use_specs *)malloc(sizeof(table_use_specs));
+    new->prodcount= 1;
+    new->feats= NULL;
+    new->calc_feats.num= 0;
+    new->featurenames= NULL;
+    new->conds= 0;
+    new->scale_freq= -1;
+    new->scale_factor= 1;
+    new->prune_threshold= 0;
+    return new;
+}
+
+void score_calculator_print_config_details(score_calculator *self,FILE *f,char *indent) {
+    char indent2[100],indent3[100];
+    sprintf(indent2,"%s  ",indent);
+    sprintf(indent3,"%s  ",indent2);
+    if (self->prodcount < 0) score_calculator_init_complete(self);
+
+    fprintf(f,"%sprodcount=%d:\n",indent,self->prodcount);
+    if (self->prodcount == 1) {
+        fprintf(f,"%sevfile:\n",indent2);
+        evfile_print_config_details(self->evfile,f,indent3);
+        
+        fprintf(f,"%scond_prefix_len=%d\n",indent2,self->cond_prefix_len);
+        fprintf(f,"%smainpref=%s; calc_rawscore=%d; calc_relscore=%d; use_corrscore=%d\n",indent2,scorepref_str(self->mainpref),self->calc_rawscore,self->calc_relscore,self->use_corrscore);
+        
+        if (self->min_obs_count > 0)
+            fprintf(f,"%smin_obs_count=%.4f; min_obs_prefix_len=%d\n",indent2,self->min_obs_count,self->min_obs_prefix_len);
+    } else {
+        int i;
+        for (i=0; i < self->prodcount; i++) {
+            fprintf(f,"%sevfiles[%d]:\n",indent2,i);
+            evfile_print_config_details(self->evfiles[i],f,indent3);
+        }
+    }
+}
+
+/*@}*/
+/* Id: score_calculator.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+spade_prob_table.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <limits.h>
+#include <stdlib.h>
+#include <math.h>
+
+/*! \file spade_prob_table.c,
+ * \brief 
+ *  spade_prob_table.c contains all the routines to build and maintain the
+ *  tree structure that Spade uses to maintain its probability tables.  It
+ *  also contains the access functions.
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+/* return the standard wait time for an interior node given the counts on 
+   its children */
+#define wait_time(c1,c2) (min_int(max_int(10,ceil(c1>c2?(2*c2-c1):(2*c1-c2))),MAX_U16))
+
+// static mindex find_nexttree_of_type(mindex leaf,features type) {
+#define find_nexttree_of_type_macro(_leaf,_type,_res) { \
+    mindex _t; \
+    _res= TNULL; \
+    for (_t=leafnexttree(_leaf); _t != TNULL; _t=treenext(_t)) { /* make common case quick */ \
+        if (treetype(_t) == _type) { \
+            _res=_t; \
+            break; \
+        } \
+    } \
+}
+
+/* return the leaf below this interior or leaf [encoded] node else TNULL */
+//static mindex find_leaf_in_subtree(dmindex encchild,valtype val) {
+#define find_leaf_in_subtree_macro(_encchild,_val,_res) { \
+    mindex _child; \
+    \
+    _res= TNULL; \
+    while (_encchild != TNULL) { \
+        if (isleaf(_encchild)) { \
+            _child= encleaf2mindex(_encchild); \
+            if (_val == leafvalue(_child)) { /* found the leaf */ \
+                _res= _child; \
+                break; \
+            } else { /* leaf not present */ \
+                break; \
+            } \
+        } else { \
+            _child= _encchild; \
+        } \
+        \
+        if (_val <= intsortpt(_child)) { /* go left */ \
+            _encchild= intleft(_child); \
+        } else { /* go right */ \
+            _encchild= intright(_child); \
+        } \
+    } \
+}
+
+//static mindex find_leaf(mindex tree,valtype val) {
+#define find_leaf_macro(_tree,_val,_res) { \
+    mindex _leaf; \
+    mindex _root=treeroot(_tree); \
+    _res= TNULL; \
+    if (_root != TNULL) { \
+        find_leaf_in_subtree_macro(_root,_val,_leaf); \
+        _res= _leaf; \
+    } \
+}
+
+
+static int min_int(int a, int b);
+static int max_int(int a, int b);
+static double tree_value_prob(mindex tree, valtype val);
+static mindex find_nexttree_of_type(mindex leaf, features type);
+static mindex get_nexttree_of_type(mindex leaf, features type);
+static mindex incr_tree_value_count(mindex tree, valtype newval);
+static mindex increment_value_count(mindex node, valtype val);
+static mindex add_node_above_to_right(mindex node, valtype val);
+static mindex add_node_above_to_left(mindex node, valtype val);
+static mindex add_node_between(mindex node, valtype val);
+static void rebalance_subtree(mindex encnode);
+static int out_of_balance(mindex node);
+static void free_all_in_tree(mindex tree);
+static void free_all_in_subtree(dmindex encnode);
+static void scale_and_prune_tree(mindex tree, double factor, double threshold);
+static dmindex scale_and_prune_subtree(dmindex encnode, double factor, double threshold, double *change, valtype *newrightmost);
+static valtype largest_val(mindex node);
+static mindex dup_intnode(mindex node);
+static mindex find_leaf(mindex tree, valtype val);
+static unsigned int feature_tree_stats(mindex tree, features f, unsigned int *smind, unsigned int *smaxd, float *saved, float *swaved, unsigned int *snum_leaves);
+static unsigned int feature_subtree_stats(mindex encnode, features f, unsigned int *smind, unsigned int *smaxd, float *saved, float *swaved, unsigned int *snum_leaves);
+static unsigned int tree_stats(mindex tree, unsigned int *mind, unsigned int *maxd, float *aved, float *waved);
+static double tree_count(mindex tree);
+static unsigned int num_leaves(mindex tree);
+static unsigned int num_subtree_leaves(mindex encnode);
+static unsigned int tree_depth_total(mindex tree);
+static unsigned int subtree_depth_total(mindex encnode, unsigned int depth);
+static double weighted_tree_depth_total(mindex tree);
+static double weighted_subtree_depth_total(mindex encnode, unsigned int depth);
+static void tree_min_max_depth(mindex tree, unsigned int *mind, unsigned int *maxd);
+static void subtree_min_max_depth(mindex encnode, unsigned int *mind, unsigned int *maxd, unsigned int depth);
+static void write_all_tree_uncond_probs(spade_prob_table *self,FILE *f, mindex tree, int depth, features feats[], valtype vals[], double treesum);
+static void write_all_subtree_uncond_probs(spade_prob_table *self,FILE *f, dmindex encnode, int depth, features feats[], valtype vals[], double treesum);
+static void write_all_tree_cond_probs(spade_prob_table *self,FILE *f, mindex tree, int depth, features feats[], valtype vals[]);
+static void write_all_subtree_cond_probs(spade_prob_table *self,FILE *f, dmindex encnode, int depth, features feats[], valtype vals[], double treesum);
+static void inc_featurecomb(featcomb C, double val, int depth, features feats[]);
+static featcomb create_featurecomb(int depth, double val);
+static void scale_all_featurecomb(featcomb c, double factor);
+static void add_all_tree_entrsum(featcomb c, mindex tree, int depth, features feats[], double totsum);
+static void add_all_subtree_entrsum(featcomb c, dmindex encnode, int depth, features feats[], double treesum, double totsum);
+static void write_all_entropies2(spade_prob_table *self,FILE *f, featcomb c, int depth, features feats[]);
+static void write_feature_names(spade_prob_table *self,FILE *f, int depth, features feats[]);
+static void printtree(spade_prob_table *self,mindex tree, char *ind);
+static void printtree2(spade_prob_table *self,dmindex encnode, char *ind);
+static void printtree2_shallow(dmindex encnode);
+static int sanity_check_tree(mindex tree);
+static int sanity_check_subtree(dmindex encnode);
+static mindex find_leaf2(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2);
+static mindex find_leaf3(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2, features type3, valtype val3);
+static double calc_tree_entropy(mindex tree);
+static double calc_subtree_entropy(mindex node,double prob_base);
+
+
+#ifndef LOG2
+/*#define LOG2 log(2);*/
+#define LOG2 ((double)0.693147180559945)
+#endif
+
+void init_spade_prob_table(spade_prob_table *self,const char **featurenames,int recovering) {
+    int i;
+    if (!recovering) {
+        init_mem();
+    
+        for (i=0; i < MAX_NUM_FEATURES; i++) {
+            self->root[i]= TNULL;
+        }
+    }
+    self->featurenames= featurenames;
+}
+
+spade_prob_table *new_spade_prob_table(const char **featurenames) {
+    spade_prob_table *new= (spade_prob_table *)malloc(sizeof(spade_prob_table));
+    init_spade_prob_table(new,featurenames,0);
+    return new;
+}
+
+int spade_prob_table_is_empty(spade_prob_table *self) {
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) return 0;
+    }
+    return 1;
+}
+
+static int min_int(int a,int b) {
+    return a < b ? a : b;
+}
+
+static int max_int(int a,int b) {
+    return a > b ? a : b;
+}
+
+void increment_simple_count(spade_prob_table *self,features type1,valtype val1) {
+    if (self->root[type1] == TNULL) {
+        self->root[type1]= new_treeinfo(type1);
+    }
+    incr_tree_value_count(self->root[type1],val1);
+}
+
+/* assumes type1 and type2 are in a consistant order */
+void increment_2joint_count(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2,int skip) {
+    mindex leaf1,tree2;
+    
+    if (skip >= 1) {
+        /* this should always find something and self->root[type1] should be non-NULL since has been marked before */
+        leaf1= find_leaf(self->root[type1],val1);
+    } else {
+        if (self->root[type1] == TNULL) {
+            self->root[type1]= new_treeinfo(type1);
+        }
+        leaf1= incr_tree_value_count(self->root[type1],val1);
+    }
+    tree2= get_nexttree_of_type(leaf1,type2);
+    incr_tree_value_count(tree2,val2);
+}
+
+void increment_3joint_count(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2,features type3,valtype val3,int skip) {
+    mindex leaf1,leaf2,tree2,tree3;
+    
+    if (skip >= 1) {
+        /* this should always find something and self->root[type1] should be non-NULL since has been marked before */
+        leaf1= find_leaf(self->root[type1],val1);
+    } else {
+        if (self->root[type1] == TNULL) {
+            self->root[type1]= new_treeinfo(type1);
+        }
+        leaf1= incr_tree_value_count(self->root[type1],val1);
+    }
+    tree2= get_nexttree_of_type(leaf1,type2);
+    /* skip case: find_leaf should always find something since has been marked before */
+    leaf2= skip >= 2 ? find_leaf(tree2,val2) : incr_tree_value_count(tree2,val2);
+    tree3= get_nexttree_of_type(leaf2,type3);
+    incr_tree_value_count(tree3,val3);
+}
+
+void increment_4joint_count(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2,features type3,valtype val3,features type4,valtype val4,int skip) {
+    mindex leaf1,leaf2,leaf3,tree2,tree3,tree4;
+    
+    if (skip >= 1) {
+        /* this should always find something and self->root[type1] should be non-NULL since has been marked before */
+        leaf1= find_leaf(self->root[type1],val1);
+    } else {
+        if (self->root[type1] == TNULL) {
+            self->root[type1]= new_treeinfo(type1);
+        }
+        leaf1= incr_tree_value_count(self->root[type1],val1);
+    }
+    tree2= get_nexttree_of_type(leaf1,type2);
+    /* skip case: find_leaf should always find something since has been marked before */
+    leaf2= skip >= 2 ? find_leaf(tree2,val2) : incr_tree_value_count(tree2,val2);
+    tree3= get_nexttree_of_type(leaf2,type3);
+    /* skip case: find_leaf should always find something since has been marked before */
+    leaf3= skip >= 3 ? find_leaf(tree3,val3) : incr_tree_value_count(tree3,val3);
+    tree4= get_nexttree_of_type(leaf3,type4);
+    incr_tree_value_count(tree4,val4);
+}
+
+void increment_Njoint_count(spade_prob_table *self,int size,features type[],valtype val[],int skip) {
+    mindex leaf,tree;
+    int i;
+    
+    if (self->root[type[0]] == TNULL) {
+        self->root[type[0]]= new_treeinfo(type[0]);
+    }
+    tree= self->root[type[0]];
+    for (i= 1; i < size; i++) {
+        /* skip case: find_leaf should always find something since has been here before */
+        if (skip >= i) 
+            find_leaf_macro(tree,val[i-1],leaf)
+        else 
+            leaf= incr_tree_value_count(tree,val[i-1]);
+        tree= get_nexttree_of_type(leaf,type[i]);
+    }
+    incr_tree_value_count(tree,val[size-1]);
+}
+
+/*****************************************************/
+
+double prob_simple(spade_prob_table *self,features type1,valtype val1) {
+    if (self->root[type1] == TNULL) return PROBRESULT_NO_RECORD; /* this feature was not counted */
+    return tree_value_prob(self->root[type1],val1);
+}
+
+/* return the probabilty of the value in the tree; assumes tree is not TNULL */
+static double tree_value_prob(mindex tree,valtype val) {
+    mindex root=treeroot(tree);
+    mindex leaf;
+    find_leaf_in_subtree_macro(root,val,leaf);
+    if (leaf == TNULL) return PROBRESULT_NO_RECORD;
+    return leafcount(leaf)/count_or_sum(root);
+}
+
+double prob_cond1(spade_prob_table *self,features type,valtype val,features ctype,valtype cval) {
+    mindex condleaf,tree,leaf;
+    if (self->root[ctype] == TNULL) {
+        return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    }
+    condleaf= find_leaf(self->root[ctype],cval);
+    if (condleaf == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    find_nexttree_of_type_macro(condleaf,type,tree);
+    if (tree == TNULL) {
+        return 0.0; /* numerator would be 0 */
+    }
+    leaf= find_leaf(tree,val);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/leafcount(condleaf);
+}
+
+double prob_cond2(spade_prob_table *self,features type,valtype val,features ctype1,valtype cval1,features ctype2,valtype cval2) {
+    mindex condleaf,leaf,tree;
+    condleaf= find_leaf2(self,ctype1,cval1,ctype2,cval2);
+    if (condleaf == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    find_nexttree_of_type_macro(condleaf,type,tree);
+    if (tree == TNULL) {
+        return 0.0; /* numerator would be 0 */
+    }
+    leaf= find_leaf(tree,val);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/leafcount(condleaf);
+}
+
+double prob_cond3(spade_prob_table *self,features type,valtype val,features ctype1,valtype cval1,features ctype2,valtype cval2,features ctype3,valtype cval3) {
+    mindex condleaf,leaf,tree;
+    condleaf= find_leaf3(self,ctype1,cval1,ctype2,cval2,ctype3,cval3);
+    if (condleaf == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    find_nexttree_of_type_macro(condleaf,type,tree);
+    if (tree == TNULL) {
+        return 0.0; /* numerator would be 0 */
+    }
+    leaf= find_leaf(tree,val);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/leafcount(condleaf);
+}
+
+
+double prob_2joint(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2) {
+    mindex tree,leaf;
+    double totcount;
+    if (self->root[type1] == TNULL) {
+        return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    }
+    totcount= tree_count(self->root[type1]);
+    leaf= find_leaf(self->root[type1],val1);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    find_nexttree_of_type_macro(leaf,type2,tree);
+    if (tree == TNULL) {
+        return 0.0; /* numerator would be 0 */
+    }
+    leaf= find_leaf(tree,val2);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/totcount;
+}
+
+double prob_Njoint(spade_prob_table *self,int size,features type[],valtype val[]) {
+    mindex tree=self->root[type[0]],leaf;
+    double totcount;
+    int i;
+    if (tree == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    totcount= tree_count(tree);
+    for (i=1;i < size; i++) {
+        leaf= find_leaf(tree,val[i-1]);
+        if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+        tree= find_nexttree_of_type(leaf,type[i]);
+        if (tree == TNULL) return 0.0; /* numerator would be 0 */
+    }
+    leaf= find_leaf(tree,val[size-1]);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/totcount;
+}
+
+double prob_Njoint_Ncond(spade_prob_table *self,int size,features type[],valtype val[],int condbase) {
+    mindex tree=self->root[type[0]],leaf;
+    double basecount=1; /* initialized to keep compiler happy */
+    int i;
+    if (tree == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    if (condbase == 0) basecount= tree_count(tree);
+    for (i=1;i < size; i++) {
+        find_leaf_macro(tree,val[i-1],leaf);
+        if (condbase == i) basecount= leafcount(leaf);
+        if (leaf == TNULL) {
+            if (condbase < i) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+            else return 0.0; /* numerator would be 0 */
+        }
+        tree= find_nexttree_of_type(leaf,type[i]);
+        if (tree == TNULL) {
+            if (condbase < i) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+            else return 0.0; /* numerator would be 0 */
+        }
+    }
+    find_leaf_macro(tree,val[size-1],leaf);
+    if (leaf == TNULL) return 0.0; /* numerator would be 0 */
+    return leafcount(leaf)/basecount;
+}
+
+double prob_Njoint_Ncond_plus_one(spade_prob_table *self,int size,features type[],valtype val[],int condbase) {
+    mindex tree=self->root[type[0]],leaf;
+    double basecount=-1;
+    int i;
+    /* pretend the table has one more observation for numerator and numerator */
+    if (tree == TNULL) return 1; /* natural denominator is 0 */
+    if (condbase == 0) basecount= tree_count(tree)+1;
+    for (i=1;i < size; i++) {
+        find_leaf_macro(tree,val[i-1],leaf);
+        if (condbase == i) basecount= leafcount(leaf)+1;
+        if (leaf == TNULL) {
+            if (condbase < i) return 1; /* natural denominator is 0  */
+            else return 1/basecount; /* natural numerator is 0 */
+        }
+        tree= find_nexttree_of_type(leaf,type[i]);
+        if (tree == TNULL) {
+            if (condbase < i) return 1; /* natural denominator is 0  */
+            else return 1/basecount; /* natural numerator is 0 */
+        }
+    }
+    find_leaf_macro(tree,val[size-1],leaf);
+    if (leaf == TNULL) return 1/basecount; /* natural numerator is 0 */
+    return (leafcount(leaf)+1)/basecount;
+}
+
+/* return what the probability would be if some instance of the indicated feature had a count of 1 */
+double one_prob_simple(spade_prob_table *self,features type1) {
+    mindex root;
+    if (self->root[type1] == TNULL) return PROBRESULT_NO_RECORD; /* denominator would be 0 */
+    root= treeroot(self->root[type1]);
+    return 1/count_or_sum(root);
+}
+
+/*****************************************************/
+
+double jointN_count(spade_prob_table *self,int size,features type[], valtype val[]) {
+    mindex tree=self->root[type[0]],leaf;
+    int i;
+    if (tree == TNULL || treeroot(tree) == TNULL) {
+        return 0.0;
+    }
+    if (size == 0) {
+        return count_or_sum(treeroot(tree));
+    }
+    for (i=1;i < size; i++) {
+        find_leaf_macro(tree,val[i-1],leaf);
+        if (leaf == TNULL) return 0.0;
+        tree= find_nexttree_of_type(leaf,type[i]);
+        if (tree == TNULL) {
+            return 0.0;
+        }
+    }
+    find_leaf_macro(tree,val[size-1],leaf);
+    if (leaf == TNULL) return 0.0;
+    return leafcount(leaf);
+}
+
+/*****************************************************/
+
+double spade_prob_table_entropy(spade_prob_table *self,int depth,features type[], valtype val[]) {
+    mindex tree=self->root[type[0]],leaf;
+    int i;
+    //printf("H(%s",self->featurenames[type[0]]);
+    if (tree == TNULL) {
+        return 0.0;
+    }
+    for (i=1;i <= depth; i++) {
+        find_leaf_macro(tree,val[i-1],leaf);
+        if (leaf == TNULL) return 0.0;
+        tree= find_nexttree_of_type(leaf,type[i]);
+        if (tree == TNULL) {
+            return 0.0;
+        }
+        //printf("=%d,%s",val[i-1],self->featurenames[type[i]]);
+    }
+    //printf(")= ");
+    if (treeH(tree) < 0 || treeH_wait(tree) == 0) {
+        /* need to recalculate entropy */
+        int wait= count_or_sum(treeroot(tree)) * 0.1;
+        treeH_wait(tree)= wait > 10000 ? 10000 : (wait < 100 ? 100 : wait);
+        treeH(tree)= calc_tree_entropy(tree);
+        //printf("*");
+    }
+    //printf("%.4f\n",treeH(tree));
+    return treeH(tree);
+}
+
+static double calc_tree_entropy(mindex tree) {
+    mindex root= treeroot(tree);
+    return calc_subtree_entropy(root,count_or_sum(root));
+}
+
+static double calc_subtree_entropy(mindex node,double prob_base) {
+    double prob;
+    if (isleaf(node)) {
+        prob= leafcount(encleaf2mindex(node))/prob_base;
+        return -1*prob*(log(prob)/LOG2);
+    } else { /* recurse */
+        return calc_subtree_entropy(intleft(node),prob_base) +
+               calc_subtree_entropy(intright(node),prob_base);
+    }
+}
+
+/*****************************************************/
+static mindex find_nexttree_of_type(mindex leaf,features type) {
+    mindex t;
+    for (t=leafnexttree(leaf); t != TNULL; t=treenext(t)) { /* make common case quick */
+        if (treetype(t) == type) {
+            return t;
+        }
+    }
+    return TNULL;
+}
+
+static mindex get_nexttree_of_type(mindex leaf,features type) {
+    mindex t;
+    for (t=leafnexttree(leaf); t != TNULL; t=treenext(t)) { /* make common case quick */
+        if (treetype(t) == type) {
+            return t;
+        }
+    }
+    t= leafnexttree(leaf);
+    if (t == TNULL) {
+        leafnexttree(leaf)= new_treeinfo(type);
+        return leafnexttree(leaf);
+    }
+    for (; t != TNULL; t=treenext(t)) {
+        if (treenext(t) == TNULL) { /* we are at end */
+            treenext(t)= new_treeinfo(type);
+            return treenext(t);
+        }
+    }
+    return TNULL; /* just to keep cc -Wall from complaining :) */
+}
+
+/* increment the count of instance of val in the tree and return the leaf updated */
+static mindex incr_tree_value_count(mindex tree,valtype newval) {
+    mindex root=treeroot(tree);
+    if (treeH_wait(tree)) treeH_wait(tree)--;
+    if (root == TNULL) {
+        mindex newleaf=new_leaf(newval);
+        treeroot(tree)= asleaf(newleaf);
+        return newleaf;
+    }
+    if (isleaf(root)) {
+        mindex leaf= encleaf2mindex(root);
+        valtype curval= leafvalue(leaf);
+        
+        if (curval == newval) {
+            leafcount(leaf)++;
+            return leaf;
+        } else {
+            mindex newleaf= new_leaf(newval); /* count is 1 */
+            mindex node= new_int();
+            intsum(node)= leafcount(leaf)+1;
+            
+            if (curval < newval) {
+                intleft(node)= asleaf(leaf);
+                intright(node)= asleaf(newleaf);
+                intsortpt(node)= curval;
+            } else {
+                intleft(node)= asleaf(newleaf);
+                intright(node)= asleaf(leaf);
+                intsortpt(node)= newval;
+            }
+            /* no rebalancing possible now, so just set wait time to standard */
+            intwait(node)= wait_time(1,leafcount(leaf));
+            treeroot(tree)= node;
+            return newleaf;
+        }
+    } else {
+        return increment_value_count(root,newval);
+    }
+}
+
+/* increment the sum for this interior node and the counts and sums for subtrees containing the given value and return the leaf node for the value */
+static mindex increment_value_count(mindex node,valtype val) {
+    mindex child,res;
+    dmindex encchild;
+
+    /* TODO: optimize by making non-recursive (note: not tail-recursive) */
+    if (val <= intsortpt(node)) { /* going left */
+        encchild= intleft(node);
+    } else { /* going right */
+        encchild= intright(node);
+    }
+    
+    if (isleaf(encchild)) {
+        child= encleaf2mindex(encchild);
+        if (val == leafvalue(child)) { /* found the leaf */
+            intsum(node)++;
+            leafcount(child)++; 
+            res= child;
+        } else { /* need to add the leaf */
+            if (val > leafvalue(child)) { /* higher than right node */
+                res= add_node_above_to_right(node,val);
+            } else if (val <= intsortpt(node)) { /* lower than left node */
+                res= add_node_above_to_left(node,val);
+            } else { /* in between */
+                res= add_node_between(node,val);
+            }
+            /* note: "node" may have different children now */
+        }
+    } else { /* recurse */
+        child= encchild;
+        intsum(node)++;
+        res= increment_value_count(child,val);
+    }
+    
+    intwait(node)--;
+    if (intwait(node) == 0) {/*printf("** rebalancing %X since got to 0 **\n",node);*/rebalance_subtree(node);}
+    
+    return res;
+}
+
+/* conceptually add a node 'node' and with a new leaf for val to right; return new leaf */
+static mindex add_node_above_to_right(mindex node,valtype val) {
+    mindex leaf= new_leaf(val); /* count is 1 */
+    /* to keep things local (esp since don't have parent node), make the new intnode like 'node' */
+    mindex newint= dup_intnode(node);
+    
+    /* now reshape 'node' to have newint on left and leaf on right */
+    intleft(node)= newint;
+    intright(node)= asleaf(leaf);
+    intsum(node)++; /* sum on newint + count on leaf */
+    intsortpt(node)= largest_val(newint);
+
+    rebalance_subtree(node);
+    
+    return leaf;
+}
+
+/* conceptually add a node 'node' and with a new leaf for val to left; return new leaf */
+static mindex add_node_above_to_left(mindex node,valtype val) {
+    mindex leaf= new_leaf(val); /* count is 1 */
+    /* to keep things local (esp since don't have parent node), make the new intnode like 'node' */
+    mindex newint= dup_intnode(node);
+    
+    /* now reshape 'node' to have newint on right and leaf on left */
+    intright(node)= newint;
+    intleft(node)= asleaf(leaf);
+    intsum(node)++; /* sum on newint + count on leaf */
+    intsortpt(node)= val; /* val is largest value on left side */
+
+    rebalance_subtree(node);
+    
+    return leaf;
+}
+
+/*  */
+static mindex add_node_between(mindex node,valtype val) {
+    mindex leaf= new_leaf(val); /* count is 1 */
+
+    mindex newint= new_int();
+    intsortpt(newint)= val; /* val is largest value on left side */
+    intleft(newint)= asleaf(leaf);
+    intright(newint)= intright(node);
+    intsum(newint)= count_or_sum(intright(node))+1;
+    intright(node)= newint;
+    intsum(node)++; /* counts stayed the same except adding 1 */
+    
+    rebalance_subtree(newint);
+    
+    return leaf;
+}
+
+#if 0 /* not currently needed, prob not tested */
+/* regardless of wait counts, start rebalancing this tree from the root */
+static void rebalance_tree(mindex tree) {
+    mindex root=treeroot(tree);
+    if (root == TNULL) return;
+    rebalance_subtree(root);
+}
+#endif
+
+/* if given a leaf, do nothing.  Otherwise consider it time to try to rebalance this tree and recurse on new or moved interior nodes; reset the wait count on the node */
+static void rebalance_subtree(mindex encnode) {
+    mindex node,left,right;
+    int changed;
+
+    if (isleaf(encnode)) return;
+    node= encnode;
+
+    do {
+#ifdef NO_REBALANCE
+break;
+#endif
+/*printf("rebalance_subtree(%X):",encnode);printtree2_shallow(encnode);
+printf("\n",encnode);*/
+        changed= 0;
+        left= intleft(node);
+        right= intright(node);
+        
+        if ((left != TNULL) && (right != TNULL) && out_of_balance(node)) {
+            double lct=count_or_sum(left);
+            double rct=count_or_sum(right);
+            mindex left2,right2,newright,newleft;
+            double l2ct,r2ct,newsum;
+            double unbalanced_amount;
+            if (lct > rct) {
+                if (!isleaf(left)) {
+                    left2= intleft(left);
+                    right2= intright(left);
+                    l2ct= count_or_sum(left2);
+                    r2ct= count_or_sum(right2);
+                    newsum= r2ct+rct; /* sum for right interior node */
+                    unbalanced_amount= lct-rct;
+                    if (fabs(l2ct-newsum) < unbalanced_amount*0.999) { /* if improves balance */
+/*printf("[rotating %X right improves balance (%f,%f) [%f]",node,l2ct,newsum,fabs(l2ct-newsum));
+printf(" < (%f,%f)*0.999 [%f]\n",lct,rct,unbalanced_amount*0.999);*/
+                        /* rotate right */
+                        /* recycle "left" interior node into one for right */ 
+                        newright= left;
+                        intsortpt(newright)= largestval(right2);
+                        intleft(newright)= right2;
+                        intright(newright)= right;
+                        intsum(newright)= newsum;
+                        /* update "node" */
+                        intsortpt(node)= largestval(left2);
+                        intleft(node)= left2;
+                        intright(node)= newright;
+                        /* count stays the same */
+                        rebalance_subtree(newright);
+                        changed= 1;
+                    } else {
+                        mindex pprl,prl,rl,lrl,n;
+                        double rlct;
+                        valtype prl_largest;
+                        /*printf("rotating %X right would not improve balance (%.2f,%.2f) vs (%.2f,%.2f)\n",node,l2ct,newsum,lct,rct);*/
+                        /* find first node on the right edge of the "right2" tree that is smaller than unbalanced_amount (if any); also the parent (plr) and grandparent (pplr) */
+                        for (pprl= left,prl= right2; !isleaf(prl) && count_or_sum(intright(prl)) >= unbalanced_amount; pprl= prl,prl=intright(prl));
+                        if (!isleaf(prl)) {
+                            rl= intright(prl);
+                            /*printf("  so moving right of %X (%X) to left side\n",prl,rl);*/
+                            prl_largest= intsortpt(prl);
+                            rlct= count_or_sum(rl);
+                            lrl= intleft(prl);
+                            
+                            /* intsortpt(pprl) remains same */
+                            intright(pprl)= lrl;
+                            /* rl is now out of right of tree and prl can be recycled */
+                            /* use prl for node on right of "node", containing rl and "right" */
+                            newright= prl;
+                            intsortpt(newright)= largestval(rl);
+                            intleft(newright)= rl;
+                            intright(newright)= right;
+                            intsum(newright)= rct+count_or_sum(rl);
+                            intright(node)= newright;
+                            intsortpt(node)= prl_largest;
+                            /* update sums from left to pprl (inclusive) to reflect loss (rlct) of the node rl */
+                            for (n=left; 1; n=intright(n)) {
+                                intsum(n)-= rlct;
+                                if (n == pprl) break;
+                            }
+                            rebalance_subtree(newright);
+                            changed= 1;
+                        } /*else { printf("  and hit leaf (%X) before hitting node smaller than %.2f\n",encleaf2mindex(prl),unbalanced_amount);}*/
+                    }
+                } /*else {printf("%X cannot be rotated right since left is a leaf node\n",node);}*/
+            } else {
+                if (!isleaf(right)) {
+                    left2= intleft(right);
+                    right2= intright(right);
+                    l2ct= count_or_sum(left2);
+                    r2ct= count_or_sum(right2);
+                    newsum= lct+l2ct; /* sum for right interior node */
+                    unbalanced_amount= rct-lct;
+                    if (fabs(r2ct-newsum) < unbalanced_amount*0.999) { /* if improves balance */
+/*printf("[rotating %X left improves balance (%f,%f) [%f]",node,r2ct,newsum,fabs(r2ct-newsum));
+printf(" < (%f,%f)*0.999 [%f]]\n",rct,lct,unbalanced_amount*0.999);*/
+                        /* rotate left */
+                        /* transform "right" interior node into one for left */
+                        newleft= right;
+                        intsortpt(newleft)= largestval(left);
+                        intleft(newleft)= left;
+                        intright(newleft)= left2;
+                        intsum(newleft)= newsum;
+                        /* update "node" */
+                        intsortpt(node)= largestval(left2);
+                        intleft(node)= newleft;
+                        intright(node)= right2;
+                        /* count stays the same */
+                        rebalance_subtree(newleft);
+                        changed= 1;
+                    } else {
+                        mindex pplr,plr,lr,rlr,n;
+                        double lrct;
+                        valtype lr_largest;
+                        /*printf("rotating %X left would not improve balance (%.2f,%.2f) vs (%.2f,%.2f)\n",node,r2ct,newsum,rct,lct);*/
+                        /* find first node on the left edge of the "left2" tree that is smaller than unbalanced_amount (if any); also the parent (plr) and grandparent (pplr) */
+                        for (pplr= right,plr= left2; !isleaf(plr) && count_or_sum(intleft(plr)) >= unbalanced_amount; pplr= plr,plr=intleft(plr));
+                        if (!isleaf(plr)) {
+                            lr= intleft(plr);
+                            /*printf("  so moving left of %X (%X) to right side\n",plr,lr);*/
+                            lr_largest= intsortpt(plr);
+                            lrct= count_or_sum(lr);
+                            rlr= intright(plr);
+                            
+                            intsortpt(pplr)= largestval(rlr);
+                            intleft(pplr)= rlr;
+                            /* lr is now out of right of tree and plr can be recycled */
+                            /* use plr for node on left of node, containing left and lr */
+                            newleft= plr;
+                            intsortpt(newleft)= largestval(left);
+                            intleft(newleft)= left;
+                            intright(newleft)= lr;
+                            intsum(newleft)= lct+count_or_sum(lr);
+                            intleft(node)= newleft;
+                            intsortpt(node)= lr_largest;
+                            /* update sums from right to pplr (inclusive) to reflect loss (lrct) of the node lr */
+                            for (n=right; 1; n=intleft(n)) {
+                                intsum(n)-= lrct;
+                                if (n == pplr) break;
+                            }
+                            rebalance_subtree(newleft);
+                            changed= 1;
+                        }/* else { printf("  and hit leaf (%X) before hitting node smaller than %.2f\n",encleaf2mindex(plr),unbalanced_amount);}*/
+                    }
+                }/* else {printf("%X cannot be rotated left since right is a leaf node\n",node);}*/
+            }
+        }/* else {printf("%X is not out of balance\n",node);}*/
+    } while (changed);
+    
+    /* note: right and left of node may have changed */
+
+    /* reset the wait count */
+    intwait(node)= wait_time(count_or_sum(intleft(node)),count_or_sum(intright(node)));
+}
+
+static int out_of_balance(mindex node) {
+    double lct=count_or_sum(intleft(node));
+    double rct=count_or_sum(intright(node));
+    return (fabs(lct-rct) > 1) && (((rct>lct)?rct/lct:lct/rct)>=2.0);
+}
+
+static void free_all_in_tree(mindex tree) {
+/*printf("free_all_in_tree(%X)\n",tree);*/
+    if (tree != TNULL) {
+        if (treeroot(tree) != TNULL) free_all_in_subtree(treeroot(tree));
+        free_treeinfo(tree);
+    }
+}
+
+static void free_all_in_subtree(dmindex encnode) {
+    mindex node,t,next;
+/*printf("free_all_in_subtree(%X)\n",encnode);*/
+    if (isleaf(encnode)) {
+        node= encleaf2mindex(encnode);
+        for (t=leafnexttree(node); t != TNULL; t=next) {
+            next= treenext(t);
+            free_all_in_tree(t);
+        }
+        free_leaf(node);
+    } else {
+        node= encnode;
+        if (intleft(node) != TNULL) free_all_in_subtree(intleft(node));
+        if (intright(node) != TNULL) free_all_in_subtree(intright(node));
+        free_int(node);
+    }   
+}
+
+void scale_and_prune_table(spade_prob_table *self,double factor,double threshold) {
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) scale_and_prune_tree(self->root[i],factor,threshold);
+    }
+}
+
+static void scale_and_prune_tree(mindex tree,double factor,double threshold) {
+    double change;
+    valtype newrightmost;
+    if (treeroot(tree) != TNULL) treeroot(tree)= scale_and_prune_subtree(treeroot(tree),factor,threshold,&change,&newrightmost);
+}
+
+static dmindex scale_and_prune_subtree(dmindex encnode,double factor,double threshold,double *change,valtype *newrightmost) {
+    mindex node,t;
+    int a_leaf= isleaf(encnode);
+
+    /* scale ourselves */
+    if (a_leaf) {
+        node= encleaf2mindex(encnode);
+        leafcount(node)*= factor;
+    } else {
+        node= encnode;
+        intsum(node)*= factor; /* should really get this by adding otherwise there is some drift */
+    }
+    
+    /* if we get too small, delete us and return TNULL and how much weight we had */
+    if (count_or_sum(encnode) < threshold) {
+/*printf("Deleting %X:\n",encnode);printtree2(encnode,"");printf("\n");*/
+        *change= count_or_sum(encnode);
+        *newrightmost= NOT_A_SORTPT; /* we don't have the info */
+        free_all_in_subtree(encnode);
+        return TNULL;
+    }
+    
+    /* scale below us and react to reported changes */
+    if (a_leaf) {
+        *change= 0.0;
+        *newrightmost= NOT_A_SORTPT;
+                
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            scale_and_prune_tree(t,factor,threshold);
+        }
+    } else {
+        dmindex left,right;
+        double mychange,reduced=0.0;
+        left= intleft(node);
+        right= intright(node);
+        
+        if (left != TNULL) {
+            valtype leftnewrightmost; /* we want this to update our sortpt, if there is a change, and the rightmost has changed */
+            intleft(node)= scale_and_prune_subtree(left,factor,threshold,change,&leftnewrightmost);
+            if (*change > 0.0) {
+                reduced+= *change;
+                if (leftnewrightmost != NOT_A_SORTPT) intsortpt(node)= leftnewrightmost; /* there is a new rightmost on left side */
+            }
+        }
+        if (right != TNULL) {
+            intright(node)= scale_and_prune_subtree(right,factor,threshold,&mychange,newrightmost);
+            if (mychange > 0.0) {
+                reduced+= mychange;
+            }
+        } else {
+            *newrightmost= NOT_A_SORTPT;
+        }
+        *change= reduced;
+        
+        left= intleft(node);
+        right= intright(node);
+        if (right == TNULL && left != TNULL) *newrightmost= largestval(left);
+        
+        if (left == TNULL || right == TNULL) { /* at least one child is gone, so delete self and return whats left */
+            free_int(node);
+            if (left == TNULL) {
+                return right; /* might be TNULL */
+            } else {
+                return left;
+            }
+        } else { /* nothing deleted at this level */
+            intsum(node)-= reduced;
+        }
+    }
+    return encnode;
+}
+
+
+/* return the largest value found below this interior node */
+/* note: sometimes called from the macro function largestval(node) */
+static valtype largest_val(mindex node) {
+    dmindex encright= intright(node);
+    if (isleaf(encright)) {
+        return eleafval(encright);
+    } else {
+        return largest_val(encright);
+    }
+}
+
+/* make a new intermediate node identical to the give one */
+static mindex dup_intnode(mindex node) {
+    mindex newint= new_int();
+    intsortpt(newint)= intsortpt(node);
+    intleft(newint)= intleft(node);
+    intright(newint)= intright(node);
+    intsum(newint)= intsum(node);
+    intwait(newint)= intwait(node);
+    return newint;
+}
+
+
+/* return the leaf representing val in the tree else TNULL */
+static mindex find_leaf(mindex tree,valtype val) {
+    mindex leaf;
+    mindex root=treeroot(tree);
+    if (root == TNULL) {
+        return TNULL;
+    }
+    find_leaf_in_subtree_macro(root,val,leaf);
+    return leaf;
+}
+
+/* return the leaf representing val2 in the tree of type2 below the leaf representing val1 top level tree of type1 else TNULL */
+static mindex find_leaf2(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2) {
+    mindex leaf,tree;
+    if (self->root[type1] == TNULL) {
+        return TNULL; /* actually this is an undefined case; this feature was not counted */
+    }
+    leaf= find_leaf(self->root[type1],val1);
+    if (leaf == TNULL) return TNULL;
+    find_nexttree_of_type_macro(leaf,type2,tree);
+    if (tree == TNULL) return TNULL; /* actually this is an undefined case; this feature was not counted */
+    return find_leaf(tree,val2);
+}
+
+/* return the leaf representing val3 in the tree of type3 below the leaf representing val2 in the tree of type2 below the leaf representing val1 top level tree of type1 else TNULL */
+static mindex find_leaf3(spade_prob_table *self,features type1,valtype val1,features type2,valtype val2,features type3,valtype val3) {
+    mindex leaf,tree;
+    if (self->root[type1] == TNULL) {
+        return TNULL; /* actually this is an undefined case; this feature was not counted */
+    }
+    leaf= find_leaf(self->root[type1],val1);
+    if (leaf == TNULL) return TNULL;
+    find_nexttree_of_type_macro(leaf,type2,tree);
+    if (tree == TNULL) return TNULL; /* actually this is an undefined case; this feature was not counted */
+    leaf= find_leaf(tree,val2);
+    if (leaf == TNULL) return TNULL;
+    find_nexttree_of_type_macro(leaf,type3,tree);
+    if (tree == TNULL) return TNULL; /* actually this is an undefined case; this feature was not counted */
+    return find_leaf(tree,val3);
+}
+
+
+/*****************************************************/
+
+float feature_trees_stats(spade_prob_table *self,features f,float *amind,float *amaxd,float *aaved,float *awaved) {
+    unsigned int tot_num_leaves=0,tot_mind=0,tot_maxd=0,tree_count=0;
+    float tot_aved=0.0,tot_waved=0.0;
+    unsigned int sum_num_leaves,sum_mind,sum_maxd;
+    float sum_aved,sum_waved;
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) {
+            tree_count+= feature_tree_stats(self->root[i],f,&sum_mind,&sum_maxd,&sum_aved,&sum_waved,&sum_num_leaves);
+            tot_num_leaves+= sum_num_leaves;
+            tot_mind+= sum_mind;
+            tot_maxd+= sum_maxd;
+            tot_aved+= sum_aved;
+            tot_waved+= sum_waved;
+        }
+    }
+    if (tree_count == 0) return 0; /* no non-empty trees of this type */
+    *amind= tot_mind/((float)tree_count);
+    *amaxd= tot_maxd/((float)tree_count);
+    *aaved= tot_aved/((float)tree_count);
+    *awaved= tot_waved/((float)tree_count);
+    return tot_num_leaves/((float)tree_count);
+}
+
+static unsigned int feature_tree_stats(mindex tree,features f,unsigned int *smind,unsigned int *smaxd,float *saved,float *swaved,unsigned int *snum_leaves) {
+    unsigned int tree_count= 0;
+    dmindex root= treeroot(tree);
+    if (root != TNULL) {
+        tree_count= feature_subtree_stats(root,f,smind,smaxd,saved,swaved,snum_leaves);
+        if (treetype(tree) == f) {
+            /* gather stats from this tree */
+            unsigned int mind,maxd;
+            float aved,waved;
+            *snum_leaves+= tree_stats(tree,&mind,&maxd,&aved,&waved);
+            *smind+= mind;
+            *smaxd+= maxd;
+            *saved+= aved;
+            *swaved+= waved;
+            tree_count++;
+        }
+    }
+    return tree_count;
+}
+
+static unsigned int feature_subtree_stats(mindex encnode,features f,unsigned int *smind,unsigned int *smaxd,float *saved,float *swaved,unsigned int *snum_leaves) {
+    mindex node,t;
+    unsigned int new_smind,new_smaxd,new_snum_leaves;
+    float new_saved,new_swaved;
+    
+    unsigned int tree_count= 0;
+    *smind= *smaxd= *snum_leaves= 0;
+    *saved= *swaved= 0.0;
+    
+    if (isleaf(encnode)) {
+        node= encleaf2mindex(encnode);
+
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            tree_count+= feature_tree_stats(t,f,&new_smind,&new_smaxd,&new_saved,&new_swaved,&new_snum_leaves);
+            *smind+= new_smind;
+            *smaxd+= new_smaxd;
+            *saved+= new_saved;
+            *swaved+= new_swaved;
+            *snum_leaves+= new_snum_leaves;
+        }
+    } else {
+        node= encnode;
+        if (intleft(node) != TNULL) {
+            tree_count+= feature_subtree_stats(intleft(node),f,&new_smind,&new_smaxd,&new_saved,&new_swaved,&new_snum_leaves);
+            *smind+= new_smind;
+            *smaxd+= new_smaxd;
+            *saved+= new_saved;
+            *swaved+= new_swaved;
+            *snum_leaves+= new_snum_leaves;
+        }
+        if (intright(node) != TNULL) {
+            tree_count+= feature_subtree_stats(intright(node),f,&new_smind,&new_smaxd,&new_saved,&new_swaved,&new_snum_leaves);
+            *smind+= new_smind;
+            *smaxd+= new_smaxd;
+            *saved+= new_saved;
+            *swaved+= new_swaved;
+            *snum_leaves+= new_snum_leaves;
+        }
+    }
+    return tree_count;
+}
+
+static unsigned int tree_stats(mindex tree,unsigned int *mind,unsigned int *maxd,float *aved,float *waved) {
+    unsigned int num_leafs= num_leaves(tree);
+    unsigned int tot= tree_depth_total(tree);
+    double wtot= weighted_tree_depth_total(tree);
+    tree_min_max_depth(tree,mind,maxd);
+    *aved= (float)tot/num_leafs;    
+    *waved= wtot/tree_count(tree);  
+/*printf("tree_stats results for tree %X: min depth=%u; max depth=%u; ave depth=%.2f; w. ave depth=%.2f; # vals repr=%u\n",tree,*mind,*maxd,*aved,*waved,num_leafs);*/
+    return num_leafs;
+}
+
+static double tree_count(mindex tree) {
+    mindex root=treeroot(tree);
+    if (root == TNULL) {
+        return 0.0;
+    }
+    return count_or_sum(root);
+}
+
+static unsigned int num_leaves(mindex tree) {
+    mindex root=treeroot(tree);
+    if (root == TNULL) {
+        return 0;
+    }
+    return num_subtree_leaves(root);
+}
+
+static unsigned int num_subtree_leaves(mindex encnode) {
+    if (isleaf(encnode)) {
+        return 1;
+    } else {
+        int count= 0;
+        if (intleft(encnode) != TNULL) count+=num_subtree_leaves(intleft(encnode));
+        if (intright(encnode) != TNULL) count+=num_subtree_leaves(intright(encnode));
+        return count;
+    }
+}
+
+static unsigned int tree_depth_total(mindex tree) {
+    mindex root=treeroot(tree);
+    if (root == TNULL) {
+        return 0;
+    }
+    return subtree_depth_total(root,0);
+}
+
+static unsigned int subtree_depth_total(mindex encnode,unsigned int depth) {
+    depth++;
+    if (isleaf(encnode)) {
+        return depth;
+    } else {
+        int count= 0;
+        if (intleft(encnode) != TNULL) count+=subtree_depth_total(intleft(encnode),depth);
+        if (intright(encnode) != TNULL) count+=subtree_depth_total(intright(encnode),depth);
+        return count;
+    }
+}
+
+static double weighted_tree_depth_total(mindex tree) {
+    mindex root=treeroot(tree);
+    if (root == TNULL) {
+        return 0;
+    }
+    return weighted_subtree_depth_total(root,0);
+}
+
+static double weighted_subtree_depth_total(mindex encnode,unsigned int depth) {
+    depth++;
+    if (isleaf(encnode)) {
+        return depth*leafnode(encleaf2mindex(encnode)).count;
+    } else {
+        double count= 0;
+        if (intleft(encnode) != TNULL) count+=weighted_subtree_depth_total(intleft(encnode),depth);
+        if (intright(encnode) != TNULL) count+=weighted_subtree_depth_total(intright(encnode),depth);
+        return count;
+    }
+}
+
+
+static void tree_min_max_depth(mindex tree,unsigned int *mind,unsigned int *maxd) {
+    mindex root=treeroot(tree);
+    
+    if (root == TNULL) {
+        *mind= *maxd= 0;
+    } else {
+        *mind= MAX_U32; /* this is the num of leaf vals, so a safe min */
+        *maxd= 0;
+        subtree_min_max_depth(root,mind,maxd,0);
+    }
+}
+
+static void subtree_min_max_depth(mindex encnode,unsigned int *mind,unsigned int *maxd,unsigned int depth) {
+    depth++;
+    if (isleaf(encnode)) {
+        if (*mind > depth) {
+            *mind= depth;
+        }
+        if (*maxd < depth) {
+            *maxd= depth;
+        }
+    } else {
+        if (intleft(encnode) != TNULL) subtree_min_max_depth(intleft(encnode),mind,maxd,depth);
+        if (intright(encnode) != TNULL) subtree_min_max_depth(intright(encnode),mind,maxd,depth);
+    }
+}
+
+/*****************************************************/
+/*****************************************************/
+void spade_prob_table_write_stats(spade_prob_table *self,FILE *file,u8 stats_to_print) {
+    featcomb H;
+
+    if (stats_to_print & STATS_ENTROPY) {
+        H= calc_all_entropies(self);
+        write_all_entropies(self,file,H);
+    }
+    if (stats_to_print & STATS_UNCONDPROB) write_all_uncond_probs(self,file);
+    if (stats_to_print & STATS_CONDPROB) write_all_cond_probs(self,file);
+}
+
+/* print to the given FILE the given features and values in the form <self->featurenames>=<value>, separated by commas; depth is the depth to look in the arrays */
+void write_feat_val_list(spade_prob_table *self,FILE *f,int depth,features feats[],valtype vals[]) {
+    int i;
+    if (depth == 0) return;
+    fprintf(f,"%s=%u",self->featurenames[feats[0]],vals[0]);
+    for (i=1; i < depth; i++) {
+        fprintf(f,",%s=%d",self->featurenames[feats[i]],vals[i]);
+    }
+}
+
+/* write a display of all unconditional probabilities to the given FILE */
+void write_all_uncond_probs(spade_prob_table *self,FILE *f) {
+    int i;
+    features feats[MAX_NUM_FEATURES];
+    valtype vals[MAX_NUM_FEATURES];
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) write_all_tree_uncond_probs(self,f,self->root[i],0,feats,vals,count_or_sum(tree(self->root[i]).root));
+    }
+}
+
+/* write a display of all uncond probabilities rooted at this tree to the given FILE; depth is the last depth completed */
+static void write_all_tree_uncond_probs(spade_prob_table *self,FILE *f,mindex tree,int depth,features feats[],valtype vals[],double treesum) {
+    dmindex root= treeroot(tree);
+    if (root == TNULL) return;
+    feats[depth]= treetype(tree);
+    depth++;
+    write_all_subtree_uncond_probs(self,f,root,depth,feats,vals,treesum);
+}
+
+/* write a display of all uncond probabilities below this interior or leaf node (as encoded) to the given FILE; depth is the depth that we are at */
+static void write_all_subtree_uncond_probs(spade_prob_table *self,FILE *f,dmindex encnode,int depth,features feats[],valtype vals[],double treesum) {
+    mindex node,t;
+
+    if (isleaf(encnode)) {
+        node= encleaf2mindex(encnode);
+        vals[depth-1]= leafvalue(node);
+        fprintf(f,"P(");
+        write_feat_val_list(self,f,depth,feats,vals);
+        fprintf(f,")= %.12f\n",leafcount(node)/treesum);
+        
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            write_all_tree_uncond_probs(self,f,t,depth,feats,vals,treesum);
+        }
+    } else {
+        node= encnode;
+        if (intleft(node) != TNULL) write_all_subtree_uncond_probs(self,f,intleft(node),depth,feats,vals,treesum);
+        if (intright(node) != TNULL) write_all_subtree_uncond_probs(self,f,intright(node),depth,feats,vals,treesum);
+    }
+}
+
+/*****************************************************/
+
+/* write a display of all conditional probabilities to the given FILE */
+void write_all_cond_probs(spade_prob_table *self,FILE *f) {
+    int i;
+    features feats[MAX_NUM_FEATURES];
+    valtype vals[MAX_NUM_FEATURES];
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) write_all_tree_cond_probs(self,f,self->root[i],0,feats,vals);
+    }
+}
+
+/* write a display of all conditional probabilities rooted at this tree to the given FILE; depth is the last depth completed */
+static void write_all_tree_cond_probs(spade_prob_table *self,FILE *f,mindex tree,int depth,features feats[],valtype vals[]) {
+    dmindex root= treeroot(tree);
+    if (root == TNULL) return;
+    feats[depth]= treetype(tree);
+    depth++;
+    write_all_subtree_cond_probs(self,f,root,depth,feats,vals,count_or_sum(root));
+}
+
+/* write a display of all conditional probabilities below this interior or leaf node (as encoded) to the given FILE; depth is the depth that we are at */
+static void write_all_subtree_cond_probs(spade_prob_table *self,FILE *f,dmindex encnode,int depth,features feats[],valtype vals[],double treesum) {
+    mindex node,t;
+
+    if (isleaf(encnode)) {
+        node= encleaf2mindex(encnode);
+        vals[depth-1]= leafvalue(node);
+        if (depth > 1) {
+            fprintf(f,"P(%s=%u|",self->featurenames[feats[depth-1]],vals[depth-1]);
+            write_feat_val_list(self,f,depth-1,feats,vals);
+            fprintf(f,")= %.12f\n",leafcount(node)/treesum);
+        }
+        
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            write_all_tree_cond_probs(self,f,t,depth,feats,vals);
+        }
+    } else {
+        node= encnode;
+        if (intleft(node) != TNULL) write_all_subtree_cond_probs(self,f,intleft(node),depth,feats,vals,treesum);
+        if (intright(node) != TNULL) write_all_subtree_cond_probs(self,f,intright(node),depth,feats,vals,treesum);
+    }
+}
+
+/*****************************************************/
+
+#if 0 /* not currently needed, prob not tested */
+static void write_featurecomb(featcomb C,double val,int depth,features feats[]) {
+    int i;
+    featcomb c= C;
+    for (i=0; i < (depth-1); i++) {
+        c= c->next[feats[i]];
+    }
+    c->val[feats[depth-1]]= val;
+}
+#endif
+
+static void inc_featurecomb(featcomb C,double val,int depth,features feats[]) {
+    int i;
+    featcomb c= C;
+    for (i=0; i < (depth-1); i++) {
+        c= c->next[feats[i]];
+    }
+    c->val[feats[depth-1]]+= val;
+}
+
+static featcomb create_featurecomb(int depth,double val) {
+    int i;
+    featcomb root= (featcomb)malloc(sizeof(struct _featcomb));
+    if (root == NULL) return NULL;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        root->val[i]= val;
+        if (depth > 1) {
+            root->next[i]= create_featurecomb(depth-1,val);
+        } else {
+            root->next[i]= NULL;
+        }
+    }
+    return root;
+}
+
+static void scale_all_featurecomb(featcomb c,double factor) {
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        c->val[i]*= factor;
+        if (c->next[i] != NULL) scale_all_featurecomb(c->next[i],factor);
+    }
+}
+
+featcomb calc_all_entropies(spade_prob_table *self) {
+    features feats[MAX_NUM_FEATURES];
+    featcomb H= create_featurecomb(MAX_NUM_FEATURES,0.0);
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) {
+            add_all_tree_entrsum(H,self->root[i],0,feats,tree_count(self->root[i]));
+        }
+    }
+    return H;
+}
+
+static void add_all_tree_entrsum(featcomb c,mindex tree,int depth,features feats[],double totsum) {
+    dmindex root= treeroot(tree);
+    if (root == TNULL) return;
+    feats[depth]= treetype(tree);
+    depth++;
+    add_all_subtree_entrsum(c,root,depth,feats,count_or_sum(root),totsum);
+}
+
+static void add_all_subtree_entrsum(featcomb c,dmindex encnode,int depth,features feats[],double treesum,double totsum) {
+    mindex node,t;
+
+    if (isleaf(encnode)) {
+        double mysumcomp,myprob,condprob;
+        node= encleaf2mindex(encnode);
+        myprob= leafcount(node)/totsum;
+        if (depth > 1) {
+            condprob= leafcount(node)/treesum;
+            mysumcomp= -1*myprob*(log(condprob)/LOG2);
+            /*printf("H[");
+            write_feature_names(stdout,depth,feats);
+            printf("]+=%f (-%f*(log(%f)/log2); myprob=%f/%f\n",mysumcomp,myprob,condprob,leafcount(node),totsum);*/
+        } else {
+            mysumcomp= -1*myprob*(log(myprob)/LOG2);
+        }
+        inc_featurecomb(c,mysumcomp,depth,feats);
+        
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            add_all_tree_entrsum(c,t,depth,feats,totsum);
+        }
+    } else {
+        node= encnode;
+        if (intleft(node) != TNULL) add_all_subtree_entrsum(c,intleft(node),depth,feats,treesum,totsum);
+        if (intright(node) != TNULL) add_all_subtree_entrsum(c,intright(node),depth,feats,treesum,totsum);
+    }
+}
+
+void write_all_entropies(spade_prob_table *self,FILE *f,featcomb c) {
+    int i;
+    features feats[MAX_NUM_FEATURES];
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (c->val[i] > 0) {
+            fprintf(f,"H(%s)=%.8f\n",self->featurenames[i],c->val[i]);
+        }
+    }
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (c->next[i] != NULL) {
+            feats[0]= i;
+            write_all_entropies2(self,f,c->next[i],1,feats);
+        }
+    }
+}
+
+static void write_all_entropies2(spade_prob_table *self,FILE *f,featcomb c,int depth,features feats[]) {
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (c->val[i] > 0) {
+            fprintf(f,"H(%s|",self->featurenames[i]);
+            write_feature_names(self,f,depth,feats);
+            fprintf(f,")=%.8f\n",c->val[i]);
+        }
+    }
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (c->next[i] != NULL) {
+            feats[depth]= i;
+            write_all_entropies2(self,f,c->next[i],depth+1,feats);
+        }
+    }
+}
+
+/* print to the given FILE the given features separated by commas; depth is the depth to look in the array */
+static void write_feature_names(spade_prob_table *self,FILE *f,int depth,features feats[]) {
+    int i;
+    if (depth == 0) return;
+    fprintf(f,"%s",self->featurenames[feats[0]]);
+    for (i=1; i < depth; i++) {
+        fprintf(f,",%s",self->featurenames[feats[i]]);
+    }
+}
+
+/*****************************************************/
+
+void print_spade_prob_table(spade_prob_table *self) {
+    int i;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) {
+            printtree(self,self->root[i],"");
+        }
+    }
+}
+
+static void printtree(spade_prob_table *self,mindex tree,char *ind) {
+    mindex t;
+    for (t=tree; t != TNULL; t=treenext(t)) {
+        printf("%sTree %X of %s: ",ind,t,self->featurenames[treetype(t)]);
+        printtree2(self,treeroot(t),ind);
+        printf("\n");
+    }
+}
+
+static void printtree2(spade_prob_table *self,dmindex encnode,char *ind) {
+    mindex node;
+    char myind[4*MAX_NUM_FEATURES+1];
+    if (encnode == TNULL) {
+        printf("NULL");
+    } else if (isleaf(encnode)) {
+        node=encleaf2mindex(encnode);
+        printf("{%X: %dx%.2f",node,leafvalue(node),leafcount(node));
+        if (leafnexttree(node) != TNULL) {
+            sprintf(myind,"    %s",ind);
+            printf(" ->{{\n");
+            printtree(self,leafnexttree(node),myind);
+            printf("%s}}",ind);
+        }
+        printf("}");
+    } else {
+        node= encnode;
+        printf("[%X: <=%d (%.2f) W=%d ",node,intsortpt(node),intsum(node),intwait(node));
+        printtree2(self,intleft(node),ind);
+        printf(" ");
+        printtree2(self,intright(node),ind);
+        printf("]");
+    }
+}
+
+#if 0 /* not currently needed, prob not tested */
+static void printtree_shallow(spade_prob_table *self,mindex tree) {
+    printf("Tree %X of %s: ",tree,self->featurenames[treetype(tree)]);
+    printtree2_shallow(treeroot(tree));
+    printf("\n");
+}
+#endif
+
+static void printtree2_shallow(dmindex encnode) {
+    mindex node;
+    if (encnode == TNULL) {
+        printf("NULL");
+    } else if (isleaf(encnode)) {
+        node=encleaf2mindex(encnode);
+        printf("{%X: %dx%.2f",node,leafvalue(node),leafcount(node));
+        printf("}");
+    } else {
+        node= encnode;
+        printf("[%X: <=%d (%.2f) ",node,intsortpt(node),intsum(node));
+        printtree2_shallow(intleft(node));
+        printf(" ");
+        printtree2_shallow(intright(node));
+        printf("]");
+    }
+}
+
+/*****************************************************/
+
+int sanity_check_spade_prob_table(spade_prob_table *self) {
+    int i,numerrs=0;
+    for (i=0; i < MAX_NUM_FEATURES; i++) {
+        if (self->root[i] != TNULL) {
+            numerrs+= sanity_check_tree(self->root[i]);
+        }
+    }
+    return numerrs;
+}
+
+static int sanity_check_tree(mindex tree) {
+    dmindex root= treeroot(tree);
+    int numerrs= 0;
+    if (treetype(tree) >= MAX_NUM_FEATURES) {
+        fprintf(stderr,"*** integrity check failure: type of %X is not valid (%d)\n",tree,treetype(tree));
+        numerrs++;
+    }
+    if (treeroot(tree) != TNULL) {
+        numerrs+= sanity_check_subtree(root);
+    }
+    return numerrs;
+}
+
+static int sanity_check_subtree(dmindex encnode) {
+    int numerrs= 0;
+    mindex node,t;
+    double count,sum;
+    
+    if (isleaf(encnode)) {
+        node= encleaf2mindex(encnode);
+        count= leafcount(node);
+        if (count <= 0.0) {
+            fprintf(stderr,"*** integrity check failure: count on leaf %X is negative or 0 (%f)\n",node,count);
+            numerrs++;
+        }
+        for (t=leafnexttree(node); t != TNULL; t=treenext(t)) {
+            /* can check if our count is approx that of the root's child */
+            numerrs+= sanity_check_tree(t);
+        }
+    }  else {
+        dmindex left,right;
+        node= encnode;
+        sum= intsum(node);
+        left= intleft(node);
+        right= intright(node);
+        if ((left != TNULL) && (right != TNULL)) {
+            double lct= count_or_sum(left);
+            double rct= count_or_sum(right);
+            double ratio= (lct+rct)/sum;
+            if (ratio < 0.999 || ratio > 1.001) {
+                fprintf(stderr,"*** integrity check failure: sum on interior node %X (%f) does not match sum/counts on leaves (%f+%f)\n",node,sum,lct,rct);
+                numerrs++;
+            }
+        }
+        if (left == TNULL) {
+            fprintf(stderr,"*** integrity check failure: left of interior node %X is TNULL\n",node);
+            numerrs++;
+        } else {
+            numerrs+= sanity_check_subtree(left);
+        }
+        if (right == TNULL) {
+            fprintf(stderr,"*** integrity check failure: right of interior node %X is TNULL\n",node);
+            numerrs++;
+        } else {
+            numerrs+= sanity_check_subtree(right);
+        }
+        if ((left != TNULL) && (right != TNULL)) {
+            if (largestval(left) != intsortpt(node)) {
+                fprintf(stderr,"*** integrity check failure: sortpoint on interior node %X (%d) does not match largest value on left (%d)\n",node,intsortpt(node),largestval(left));
+                numerrs++;
+            }
+        }   
+    }
+    return numerrs;
+}
+
+
+int spade_prob_table_checkpoint(statefile_ref *s,spade_prob_table *self) {
+    return spade_state_checkpoint_arr(s,self->root,MAX_NUM_FEATURES,sizeof(mindex));
+}
+
+int spade_prob_table_recover(statefile_ref *s,spade_prob_table *self) {
+    return spade_state_recover_arr(s,&self->root,MAX_NUM_FEATURES,sizeof(mindex));
+}
+
+/* Id: spade_prob_table.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+spade_prob_table_types.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file spade_prob_table_types.c
+ * \brief 
+ *  spade_prob_table_types.c is a module containing the memory management
+ *  for the main 3 data types used by the spade_prob_table "class".
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+treeroot **ROOT_M;
+intnode **INT_M;
+leafnode **LEAF_M;
+
+mindex root_freelist;
+mindex int_freelist;
+mindex leaf_freelist;
+
+unsigned char ROOT_BLOCK_BITS;
+unsigned char INT_BLOCK_BITS;
+unsigned char LEAF_BLOCK_BITS;
+unsigned int MAX_ROOT_BLOCKS;
+unsigned int MAX_INT_BLOCKS;
+unsigned int MAX_LEAF_BLOCKS;
+
+static void reset_mem();
+
+/* initialize the memory manager */
+void init_mem() {
+    static int spade_prob_table_mem_inited= 0;
+    reset_mem();
+
+    if (spade_prob_table_mem_inited) return; /* already inited */
+    spade_prob_table_mem_inited= 1;
+    
+    allocate_mem_blocks();
+}
+
+static void reset_mem() {
+    ROOT_BLOCK_BITS= DEFAULT_ROOT_BLOCK_BITS;
+    INT_BLOCK_BITS= DEFAULT_INT_BLOCK_BITS;
+    LEAF_BLOCK_BITS= DEFAULT_LEAF_BLOCK_BITS;
+    MAX_ROOT_BLOCKS= DEFAULT_MAX_ROOT_BLOCKS;
+    MAX_INT_BLOCKS= DEFAULT_MAX_INT_BLOCKS;
+    MAX_LEAF_BLOCKS= DEFAULT_MAX_LEAF_BLOCKS;
+
+    root_freelist=TNULL;
+    int_freelist=TNULL;
+    leaf_freelist=TNULL;
+}
+
+void allocate_mem_blocks() {
+    unsigned int i;
+
+    ROOT_M=(treeroot **)malloc(sizeof(treeroot *)*MAX_ROOT_BLOCKS);
+    for (i=0; i < MAX_ROOT_BLOCKS; i++) ROOT_M[i]= NULL;
+    INT_M=  (intnode **)malloc(sizeof(intnode *)*MAX_INT_BLOCKS);
+    for (i=0; i < MAX_INT_BLOCKS; i++) INT_M[i]= NULL;
+    LEAF_M=(leafnode **)malloc(sizeof(leafnode *)*MAX_LEAF_BLOCKS);
+    for (i=0; i < MAX_LEAF_BLOCKS; i++) LEAF_M[i]= NULL;
+}
+
+int reallocate_ptr_array(void ***arrptr,int oldsize,int newsize) {
+    unsigned int i;
+    void **arr= NULL;
+
+    arr= (void **)realloc(arr,sizeof(void *)*newsize);
+    if (arr == NULL) return 0;
+    for (i=oldsize; i < newsize; i++) arr[i]= NULL;
+    *arrptr= arr;
+    return 1;
+}
+
+/* allocate a new treeroot node with the give feature type and return it */
+mindex new_treeinfo(features type) {
+    mindex root;
+    int i,p;
+    if (root_freelist == TNULL) { /* need to allocate a new block */
+        /* find first unused block */
+        for (p=0; p < MAX_ROOT_BLOCKS && (ROOT_M[p] != NULL); p++) {}
+        if (p == MAX_ROOT_BLOCKS) {
+            fprintf(stderr,"exhausted all %d blocks of %d treeroots; exiting; you might want to increase DEFAULT_MAX_ROOT_BLOCKS or DEFAULT_ROOT_BLOCK_BITS in spp_spade.h or wherever it is defined\n",MAX_ROOT_BLOCKS,ROOT_BLOCK_SIZE);
+            printf("next free root: %X; int: %X, leaf: %X\n",root_freelist,int_freelist,leaf_freelist);
+            exit(1);
+        }
+        ROOT_M[p]= (treeroot *)calloc(ROOT_BLOCK_SIZE,sizeof(treeroot));
+        if (ROOT_M[p] == NULL) {
+            fprintf(stderr,"Out of memory! in allocation of new treeroot block; exiting");
+            exit(2);
+        }
+        /* add new slots to freelist */
+        root_freelist= root_index(p,0);
+        for (i=0; i < (ROOT_BLOCK_SIZE-1); i++) {
+#ifdef EXTRA_MARK_FREE
+            ROOT_M[p][i].root= TNULL;
+#endif
+            rfreenext(ROOT_M[p][i])= root_index(p,i+1);
+        }
+#ifdef EXTRA_MARK_FREE
+        ROOT_M[p][ROOT_BLOCK_SIZE-1].root= TNULL;
+#endif
+        rfreenext(ROOT_M[p][ROOT_BLOCK_SIZE-1])= TNULL;
+    }
+    /* give out the head and make its next the new head */
+    root= root_freelist;
+    root_freelist= rfreenext(tree(root_freelist));
+    treetype(root)= type;
+    treeroot(root)= TNULL;
+    treenext(root)= TNULL;
+    treeH(root)= -1;
+    treeH_wait(root)= 0;
+    return root;
+}
+
+/* free the treeroot node given */
+void free_treeinfo(mindex f) {
+#ifdef EXTRA_MARK_FREE
+    treeroot(f)= TNULL;
+#endif
+    /* add it to the start of the list */
+    rfreenext(tree(f))= root_freelist;
+    root_freelist= f;
+}
+
+
+/* allocate a new intnode node and return it */
+mindex new_int() {
+    mindex res;
+    int i,p;
+    if (int_freelist == TNULL) { /* need to allocate a new block */
+        /* find first unused block */
+        for (p=0; p < MAX_INT_BLOCKS && (INT_M[p] != NULL); p++) {}
+        if (p == MAX_INT_BLOCKS) {
+            fprintf(stderr,"exhausted all %d blocks of %d intnodes; exiting; you might want to increase DEFAULT_MAX_INT_BLOCKS or DEFAULT_INT_BLOCK_BITS in spp_spade.h or wherever it is defined\n",MAX_INT_BLOCKS,INT_BLOCK_SIZE);
+            printf("next free root: %X; int: %X, leaf: %X\n",root_freelist,int_freelist,leaf_freelist);
+            exit(1);
+        }
+        INT_M[p]= (intnode *)calloc(INT_BLOCK_SIZE,sizeof(intnode));
+        if (INT_M[p] == NULL) {
+            fprintf(stderr,"Out of memory! in allocation of new intnode block; exiting");
+            exit(2);
+        }
+        /* add new slots to freelist */
+        int_freelist= intnode_index(p,0);
+        for (i=0; i < (INT_BLOCK_SIZE-1); i++) {
+#ifdef EXTRA_MARK_FREE
+            INT_M[p][i].sum= -1;
+#endif
+            ifreenext(INT_M[p][i])= intnode_index(p,i+1);
+        }
+#ifdef EXTRA_MARK_FREE
+        INT_M[p][INT_BLOCK_SIZE-1].sum= -1;
+#endif
+        ifreenext(INT_M[p][INT_BLOCK_SIZE-1])= TNULL;
+    }
+    /* give out the head and make its next the new head */
+    res= int_freelist;
+    int_freelist= ifreenext(intnode(int_freelist));
+    intleft(res)= intright(res)= TNULL;
+    intsum(res)=0;
+    intsortpt(res)= NOT_A_SORTPT;
+    intwait(res)= 999;
+    return res;
+}
+
+/* free the intnode node given */
+void free_int(mindex f) {
+#ifdef EXTRA_MARK_FREE
+    intsum(f)= -1;
+#endif
+    /* add it to the start of the list */
+    ifreenext(intnode(f))= int_freelist;
+    int_freelist= f;
+}
+
+/* allocate a new leafnode node and return it */
+mindex new_leaf(valtype val) {
+    mindex res;
+    int i,p;
+    if (leaf_freelist == TNULL) { /* need to allocate a new block */
+        /* find first unused block */
+        for (p=0; p < MAX_LEAF_BLOCKS && (LEAF_M[p] != NULL); p++) {}
+        if (p == MAX_LEAF_BLOCKS) {
+            fprintf(stderr,"exhausted all %d blocks of %d leafnodes; exiting; you might want to increase DEFAULT_LEAF_ROOT_BLOCKS or DEFAULT_LEAF_BLOCK_BITS in spp_spade.h or wherever it is defined\n",MAX_LEAF_BLOCKS,LEAF_BLOCK_SIZE);
+            printf("next free root: %X; int: %X, leaf: %X\n",root_freelist,int_freelist,leaf_freelist);
+            exit(1);
+        }
+        LEAF_M[p]= (leafnode *)calloc(LEAF_BLOCK_SIZE,sizeof(leafnode));
+        if (LEAF_M[p] == NULL) {
+            fprintf(stderr,"Out of memory! in allocation of new leafnode block; exiting");
+            exit(2);
+        }
+        /* add new slots to freelist */
+        leaf_freelist= leafnode_index(p,0);
+        for (i=0; i < (LEAF_BLOCK_SIZE-1); i++) {
+#ifdef EXTRA_MARK_FREE
+            LEAF_M[p][i].count= -1;
+#endif
+            lfreenext(LEAF_M[p][i])= leafnode_index(p,i+1);
+        }
+#ifdef EXTRA_MARK_FREE
+        LEAF_M[p][LEAF_BLOCK_SIZE-1].count= -1;
+#endif
+        lfreenext(LEAF_M[p][LEAF_BLOCK_SIZE-1])= TNULL;
+    }
+    /* give out the head and make its next the new head */
+    res= leaf_freelist;
+    leaf_freelist= lfreenext(leafnode(leaf_freelist));
+    leafvalue(res)= val;
+    leafcount(res)= 1;
+    leafnexttree(res)= TNULL;
+    return res;
+}
+
+/* free the leafnode node given */
+void free_leaf(mindex f) {
+#ifdef EXTRA_MARK_FREE
+    leafcount(f)= -1;
+#endif
+    /* add it to the start of the list */
+    lfreenext(leafnode(f))= leaf_freelist;
+    leaf_freelist= f;
+}
+
+/* Id: spade_prob_table_types.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+spade_state.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file spade_state.c
+ * \brief 
+ *  spade_state.c contains a module to assist with checkpoint and recovery
+ *  of a Spade application; it is intimate with the spade_prob_table_types
+ *  module
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+#define CUR_FVERS 5
+
+/// treeroot structure used in file checkpoint version 4 and earlier
+typedef struct {
+    mindex next;  ///< the next tree root in a list
+    dmindex root; ///< root node of the tree, if top bit is 1, it is a leafnode, otherwise it is a interior node
+    features type;///< the feature that is being represented in this tree
+} upto_v4_treeroot;
+
+
+statefile_ref *spade_state_begin_checkpointing(char *filename,char *appname,u8 app_cur_fvers) {
+    statefile_ref *s= (statefile_ref *)malloc(sizeof(statefile_ref));
+    char v='v';
+    u8 fvers= CUR_FVERS,uc;
+    double d= 1234.56789;
+    u32 l= 0x01020304;
+    u32 i,blocks_used;
+    u8 numfeat= MAX_NUM_FEATURES;
+
+    errno=0;
+    s->f= fopen(filename,"wb");
+    if (errno) {
+        perror(filename);
+        free(s);
+        return NULL;
+    }
+
+    fwrite(&v,sizeof(v),1,s->f);
+    fwrite(&fvers,1,1,s->f);
+    spade_state_checkpoint_str(s,appname);
+    fwrite(&app_cur_fvers,1,1,s->f);
+    
+    uc= sizeof(u16);
+    fwrite(&uc,sizeof(uc),1,s->f);
+    uc= sizeof(u32);
+    fwrite(&uc,sizeof(uc),1,s->f);
+    uc= sizeof(double);
+    fwrite(&uc,sizeof(uc),1,s->f);
+    
+    /* + the integer 0x01020304 (16,909,060) as a 4 byte unsigned int, to indicate the endianness of this file */
+    fwrite(&l,4,1,s->f);
+    /* + the number 1234.56789 as a double (sizeof(double)) [to verify that doubles are binary compatable] */
+    fwrite(&d,sizeof(d),1,s->f);
+
+    fwrite(&numfeat,sizeof(numfeat),1,s->f);
+
+    /* write out tree library state */
+        /* treeroot type state */
+    fwrite(&ROOT_BLOCK_BITS,sizeof(ROOT_BLOCK_BITS),1,s->f);
+    for (blocks_used= 0; ROOT_M[blocks_used] != NULL; blocks_used++) {}
+    fwrite(&blocks_used,sizeof(blocks_used),1,s->f);
+    for (i= 0; i < blocks_used; i++) {
+        fwrite(ROOT_M[i],sizeof(treeroot),ROOT_BLOCK_SIZE,s->f);
+    }
+    fwrite(&root_freelist,sizeof(root_freelist),1,s->f);
+
+        /* intnode type state */
+    fwrite(&INT_BLOCK_BITS,sizeof(INT_BLOCK_BITS),1,s->f);
+    for (blocks_used= 0; INT_M[blocks_used] != NULL; blocks_used++) {}
+    fwrite(&blocks_used,sizeof(blocks_used),1,s->f);
+    for (i= 0; i < blocks_used; i++) {
+        fwrite(INT_M[i],sizeof(intnode),INT_BLOCK_SIZE,s->f);
+    }
+    fwrite(&int_freelist,sizeof(int_freelist),1,s->f);
+
+        /* leafnode type state */
+    fwrite(&LEAF_BLOCK_BITS,sizeof(LEAF_BLOCK_BITS),1,s->f);
+    for (blocks_used= 0; LEAF_M[blocks_used] != NULL; blocks_used++) {}
+    fwrite(&blocks_used,sizeof(blocks_used),1,s->f);
+    for (i= 0; i < blocks_used; i++) {
+        fwrite(LEAF_M[i],sizeof(leafnode),LEAF_BLOCK_SIZE,s->f);
+    }
+    fwrite(&leaf_freelist,sizeof(leaf_freelist),1,s->f);
+
+    return s;
+}
+
+int spade_state_end_checkpointing(statefile_ref *s) {
+    fclose(s->f);
+    free(s);
+    return 1;
+}
+
+int spade_state_checkpoint_str(statefile_ref *s,char *str) {
+    u16 len=strlen(str);
+    fwrite(&len,2,1,s->f);
+    fwrite(str,sizeof(char),strlen(str),s->f);
+    return 1;
+}
+
+int spade_state_checkpoint_arr(statefile_ref *s,void *arr,int len,int elsize) {
+    fwrite(arr,elsize,len,s->f);
+    return 1;
+}
+
+int spade_state_checkpoint_str_arr(statefile_ref *s,char **arr,int len) {
+    int i;
+    for (i=0; i < len; i++)
+        if (!spade_state_checkpoint_str(s,arr[i])) return 0;
+    return 1;
+}
+
+int spade_state_checkpoint_u32(statefile_ref *s,u32 val) {
+    fwrite(&val,4,1,s->f);
+    return 1;
+}
+
+int spade_state_checkpoint_u8(statefile_ref *s,u8 val) {
+    fwrite(&val,1,1,s->f);
+    return 1;
+}
+
+int spade_state_checkpoint_time_t(statefile_ref *s,time_t val) {
+    return spade_state_checkpoint_u32(s,val);
+}
+
+int spade_state_checkpoint_double(statefile_ref *s,double val) {
+    fwrite(&val,sizeof(double),1,s->f);
+    return 1;
+}
+
+int spade_state_end_section(statefile_ref *s) {
+    u16 nul= 0x0000;
+    fwrite(&nul,2,1,s->f);
+    return 1;
+}
+
+#define PREMATURE_END_CHECK(count,minsize) if (count < minsize) { \
+        fprintf(stderr,"Premature end in Spade recovery file %s; not recovering from it\n",filename); \
+        fclose(s->f); \
+        return NULL; \
+    }
+
+#define CORRUPT_FILE_CHECK(testres,whatwentwrong) \
+    if (testres) { \
+        fprintf(stderr,"Corrupt Spade recovery file %s: %s; not recovering from it\n",filename,whatwentwrong); \
+        fclose(s->f); \
+        return NULL; \
+    }
+
+
+statefile_ref *spade_state_begin_recovery(char *filename,int min_app_fvers,char **appname,u8 *file_app_fvers) {
+    statefile_ref *s= (statefile_ref *)malloc(sizeof(statefile_ref));
+    unsigned char uc,fvers;
+    char v;
+    unsigned int i,blocks_used;
+    int count;
+    u8 numfeat;
+    double d;
+    u32 l;
+    
+    init_mem();
+    
+    if (s == NULL) return NULL;
+    
+    errno=0;
+    s->f= fopen(filename,"rb");
+    if (errno) { /* file prob does not exist */
+        return NULL;
+    }
+    
+    count= fread(&v,sizeof(v),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (v == 'v') { /* format version # encoded */
+        count= fread(&fvers,1,1,s->f);
+        PREMATURE_END_CHECK(count,1);
+    } else { /* format version #0; only diff from version 1 is that the version # is listed */
+        fvers= 0;
+    }
+    if (fvers < 4) {
+        fprintf(stderr,"This version of the Spade state recover procedure cannot read file %s since has format version %d; this routine can recover version 4 onwards; sorry\n",filename,fvers);
+        fclose(s->f);
+        return NULL;
+    }
+    if (fvers > CUR_FVERS) {
+        fprintf(stderr,"This version of the Spade state recover procedure cannot read file %s since has format version %d; this routine can only handle up to version %d\n",filename,fvers,CUR_FVERS);
+        fclose(s->f);
+        return NULL;
+    }
+    spade_state_recover_str(s,appname);
+    count= fread(file_app_fvers,1,1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (*file_app_fvers < min_app_fvers) {
+        fprintf(stderr,"Spade state recover failed on file %s: application %s version was %d but at least version %d was required\n",filename,*appname,*file_app_fvers,min_app_fvers);
+        fclose(s->f);
+        return NULL;
+    }
+
+    count= fread(&uc,sizeof(uc),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (sizeof(u16) != uc) {
+        fprintf(stderr,"u16 type size from recovery file (%s) (%d bytes) does not match current size (%d bytes)\n",filename,uc,(int)sizeof(u16));
+        fclose(s->f);
+        return NULL;
+    }
+    count= fread(&uc,sizeof(uc),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (sizeof(u32) != uc) {
+        fprintf(stderr,"u32 type size from recovery file (%s) (%d bytes) does not match current size (%d bytes)\n",filename,uc,(int)sizeof(u32));
+        fclose(s->f);
+        return NULL;
+    }
+    count= fread(&uc,sizeof(uc),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (sizeof(double) != uc) {
+        fprintf(stderr,"double type size from recovery file (%s) (%d bytes) does not match current size (%d bytes)\n",filename,uc,(int)sizeof(double));
+        fclose(s->f);
+        return NULL;
+    }
+    
+    /* ========= read in encoding and sanity check things ========== */
+    /* + the integer 0x01020304 (16,909,060) as a 4 byte unsigned int, to indicate the endianness of this file */
+    count= fread(&l,sizeof(l),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (l != 0x01020304) {
+        fprintf(stderr,"recovery file (%s) was produced with a different byte ordering (got 0x%x where expecting 0x01020304); you will need to convert the file\n",filename,l);
+        return NULL;
+    }
+
+    /* + the number 1234.56789 as a double (sizeof(double)) [to verify that doubles are binary compatable] */
+    count= fread(&d,sizeof(d),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (d > 1234.58 || d < 1234.55) {
+        fprintf(stderr,"recovery file (%s) was produced with a different double representation (got %f where expecting something close to 1234.56789); you will need to convert the file\n",filename,d);
+        return NULL;
+    }
+
+    count= fread(&numfeat,1,1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (numfeat > MAX_NUM_FEATURES) {
+        fprintf(stderr,"recovery file (%s) has a higher number of features (%d) than we allow (%d); you will need to increase MAX_NUM_FEATURES\n",filename,numfeat,MAX_NUM_FEATURES);
+        return NULL;
+    }
+
+    count= fread(&ROOT_BLOCK_BITS,sizeof(ROOT_BLOCK_BITS),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    CORRUPT_FILE_CHECK(ROOT_BLOCK_BITS < 3,"stored ROOT_BLOCK_BITS is too small");
+    
+    /* use the max block size for this run unless there is more stored in the file */
+    count= fread(&blocks_used,sizeof(blocks_used),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (blocks_used > DEFAULT_MAX_ROOT_BLOCKS) {
+        reallocate_ptr_array((void ***)&ROOT_M,DEFAULT_MAX_ROOT_BLOCKS,blocks_used);
+        MAX_ROOT_BLOCKS= blocks_used;
+    }
+    
+    if (fvers >= 5) { // can read block of treeroots directly
+        for (i= 0; i < blocks_used; i++) {
+            ROOT_M[i]= (treeroot *)malloc(sizeof(treeroot)*ROOT_BLOCK_SIZE);
+            count= fread(ROOT_M[i],sizeof(treeroot),ROOT_BLOCK_SIZE,s->f);
+            PREMATURE_END_CHECK(count,ROOT_BLOCK_SIZE);
+        }
+    } else { // need to translate treeroot struct from treeroot_orig to treeroot
+        int j;
+        upto_v4_treeroot *origblock= (upto_v4_treeroot *)malloc(sizeof(upto_v4_treeroot)*ROOT_BLOCK_SIZE);
+        for (i= 0; i < blocks_used; i++) {
+            ROOT_M[i]= (treeroot *)malloc(sizeof(treeroot)*ROOT_BLOCK_SIZE);
+            count= fread(origblock,sizeof(upto_v4_treeroot),ROOT_BLOCK_SIZE,s->f);
+            PREMATURE_END_CHECK(count,ROOT_BLOCK_SIZE);
+            for (j=0; j < ROOT_BLOCK_SIZE; j++) {
+                // look at original structure and initialize new from it
+                ROOT_M[i][j].next= origblock[j].next;
+                ROOT_M[i][j].root= origblock[j].root;
+                ROOT_M[i][j].type= origblock[j].type;
+                ROOT_M[i][j].entropy= -1;
+            }
+        }
+        free(origblock);
+    }
+
+    count= fread(&root_freelist,sizeof(root_freelist),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    
+    
+    count= fread(&INT_BLOCK_BITS,sizeof(INT_BLOCK_BITS),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    CORRUPT_FILE_CHECK(INT_BLOCK_BITS < 3,"stored INT_BLOCK_BITS is too small");
+    
+    /* use the max block size for this run unless there is more stored in the file */
+    count= fread(&blocks_used,sizeof(blocks_used),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (blocks_used > DEFAULT_MAX_INT_BLOCKS) {
+        reallocate_ptr_array((void ***)&INT_M,DEFAULT_MAX_INT_BLOCKS,blocks_used);
+        MAX_INT_BLOCKS= blocks_used;
+    }
+    
+    for (i= 0; i < blocks_used; i++) {
+        INT_M[i]= (intnode *)malloc(sizeof(intnode)*INT_BLOCK_SIZE);
+        count= fread(INT_M[i],sizeof(intnode),INT_BLOCK_SIZE,s->f);
+        PREMATURE_END_CHECK(count,INT_BLOCK_SIZE);
+    }
+
+    count= fread(&int_freelist,sizeof(int_freelist),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    
+    
+    count= fread(&LEAF_BLOCK_BITS,sizeof(LEAF_BLOCK_BITS),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    CORRUPT_FILE_CHECK(LEAF_BLOCK_BITS < 3,"stored LEAF_BLOCK_BITS is too small");
+    
+    /* use the max block size for this run unless there is more stored in the file */
+    count= fread(&blocks_used,sizeof(blocks_used),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    if (blocks_used > DEFAULT_MAX_LEAF_BLOCKS) {
+        reallocate_ptr_array((void ***)LEAF_M,DEFAULT_MAX_LEAF_BLOCKS,blocks_used);
+        MAX_LEAF_BLOCKS= blocks_used;
+    }
+    
+    for (i= 0; i < blocks_used; i++) {
+        LEAF_M[i]= (leafnode *)malloc(sizeof(leafnode)*LEAF_BLOCK_SIZE);
+        count= fread(LEAF_M[i],sizeof(leafnode),LEAF_BLOCK_SIZE,s->f);
+        PREMATURE_END_CHECK(count,LEAF_BLOCK_SIZE);
+    }
+    
+    count= fread(&leaf_freelist,sizeof(leaf_freelist),1,s->f);
+    PREMATURE_END_CHECK(count,1);
+    
+    return s;
+}
+
+int spade_state_end_recovery(statefile_ref *s) {
+    fclose(s->f);
+    free(s);
+    return 1;
+}
+
+int spade_state_recover_check_end_of_section(statefile_ref *s,int *res) {
+    u16 c;
+    int count= fread(&c,2,1,s->f);
+    if (!count) return 0;
+    
+    *res= (c == 0x0000);
+    if (!*res) fseek(s->f,-2,SEEK_CUR);
+    return 1;
+}
+
+int spade_state_recover_arr(statefile_ref *s,void *arr,int len,int elsize) {
+    int count= fread(arr,elsize,len,s->f);
+    return count == len;
+}
+
+int spade_state_recover_str_arr(statefile_ref *s,char **arr,int len) {
+    int i;
+    for (i=0; i < len; i++)
+        if (!spade_state_recover_str(s,&arr[i])) return 0;
+    return 1;
+}
+
+int spade_state_recover_u32(statefile_ref *s,u32 *val) {
+    int count= fread(val,4,1,s->f);
+    return count == 1;
+}
+
+int spade_state_recover_u8(statefile_ref *s,u8 *val) {
+    int count= fread(val,1,1,s->f);
+    return count == 1;
+}
+
+int spade_state_recover_time_t(statefile_ref *s,time_t *val) {
+    return spade_state_recover_u32(s,(u32 *)val);
+}
+
+int spade_state_recover_double(statefile_ref *s,double *val) {
+    int count= fread(val,sizeof(double),1,s->f);
+    return count == 1;
+}
+
+
+int spade_state_recover_str(statefile_ref *s,char **str) {
+    u16 len;
+    int count= fread(&len,2,1,s->f);
+    if (!count) return 0;
+    *str= (char *)malloc(sizeof(char)*(len+1));
+    if (*str == NULL) return 0;
+    
+    count= fread(*str,sizeof(char),len,s->f);
+    (*str)[count]= '\0';
+    if (count < len) return 0;
+    return 1;
+}
+
+int spade_state_recover_str_to_buff(statefile_ref *s,char *buff,int maxlen) {
+    u16 len,readlen;
+    int count= fread(&len,2,1,s->f);
+    if (!count) return 0;
+    readlen= len > (maxlen-1) ? maxlen-1 : len;
+    count= fread(buff,sizeof(char),readlen,s->f);
+    if (count < readlen) return 0;
+    buff[readlen]= '\0';
+    
+    while (readlen < len) { /* discard extra */
+        char c;
+        count= fread(&c,sizeof(char),1,s->f);
+        if (!count) return 0;
+        readlen++;
+    }
+    return 1;
+}
+
+
+/* Id: spade_state.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+thresh_adapter.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file thresh_adapter.c
+ * \brief 
+ *  thresh_adapter.c contains a "class" thresh_adapter which implements
+ *  several ways to adapt a Spade threshold to hit a certain target
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+
+static void thresh_adapter_setup_1_from_str(thresh_adapter *self,char *str);
+static void thresh_adapter_setup_2_from_str(thresh_adapter *self,char *str);
+static void thresh_adapter_setup_3_from_str(thresh_adapter *self,char *str);
+static void thresh_adapter_setup_4_from_str(thresh_adapter *self,char *str);
+static void thresh_adapter_new_pkt_rate(thresh_adapter *self, spade_enviro *enviro);
+static void thresh_adapter_2_new_pkt_rate(thresh_adapter *self, spade_enviro *enviro);
+static void thresh_adapter_3_new_pkt_rate(thresh_adapter *self, spade_enviro *enviro);
+static float grab_new_thresh_1(thresh_adapter *self, spade_enviro *enviro);
+static float grab_new_thresh_2(thresh_adapter *self, spade_enviro *enviro);
+static float calc_new_thresh_2(thresh_adapter *self, spade_enviro *enviro);
+static double thresh_from_obslists(adapt2_data *data);
+static double anom_ave(double a[], int size);
+static void reset_obslist(adapt2_data *data, int slot);
+static float grab_new_thresh_3(thresh_adapter *self, spade_enviro *enviro);
+static float grab_new_thresh_4(thresh_adapter *self,spade_enviro *enviro);
+static void thresh_adapter_1_new_score(thresh_adapter *self, double anom_score);
+static void thresh_adapter_2_new_score(thresh_adapter *self, double anom_score);
+static void thresh_adapter_3_new_score(thresh_adapter *self, double anom_score);
+
+void init_thresh_adapter(thresh_adapter *self,spade_msg_fn msg_callback) {
+    self->adapt_mode= 0;
+    self->period_start= (time_t)0;
+    self->pkt_period_count= 0;
+    self->last_total_stats= 0;
+    self->period_pkt_rate= 100000000.0;
+    self->period_acc_rate= 100000000.0;
+    self->done= 0;
+    self->msg_callback= msg_callback;
+}
+
+thresh_adapter *new_thresh_adapter(spade_msg_fn msg_callback) {
+    thresh_adapter *new= (thresh_adapter *)malloc(sizeof(thresh_adapter));
+    init_thresh_adapter(new,msg_callback);
+    return new;
+}
+
+void thresh_adapter_setup_from_str(thresh_adapter *self,int adaptmode,char *str) {
+    switch (adaptmode) {
+        case 1: thresh_adapter_setup_1_from_str(self,str); break;
+        case 2: thresh_adapter_setup_2_from_str(self,str); break;
+        case 3: thresh_adapter_setup_3_from_str(self,str); break;
+        case 4: thresh_adapter_setup_4_from_str(self,str); break;
+    }
+}
+
+void thresh_adapter_setup_1(thresh_adapter *self,int target,time_t period,float new_obs_weight,int by_count) {
+    adapt1_data *data= &self->d.a1;
+
+    self->adapt_mode= 1;
+    self->adapt_period= period;
+    self->adapt_by_count= by_count;
+    
+    data->target= target;
+    data->period= period;
+    data->new_obs_weight= new_obs_weight;
+    data->by_count= by_count;
+    
+    /* init list to contain 0 and 0; this is to let us assume the list has a
+       bottom and runner-up elsewhere */
+    data->top_list= (ll_double *)malloc(sizeof(ll_double));
+    data->top_list->val= 0.0;
+    data->top_list->next= (ll_double *)malloc(sizeof(ll_double));
+    data->top_list->next->val= 0.0;
+    data->top_list->next->next= NULL;
+    data->top_list_size= 1;
+}
+
+static void thresh_adapter_setup_1_from_str(thresh_adapter *self,char *str) {
+    int target=20,by_count=1;
+    float hours=2,new_obs_weight=0.5;
+    void *args[4];
+    time_t period;
+
+    args[0]= &target;
+    args[1]= &hours;
+    args[2]= &new_obs_weight;
+    args[3]= &by_count;
+    fill_args_space_sep(str,"i:target;f:obsper;f:newweight;b:bycount",args,self->msg_callback);
+
+    period= (time_t)(hours*3600);
+    thresh_adapter_setup_1(self,target,period,new_obs_weight,by_count);
+}
+
+
+void thresh_adapter_setup_2(thresh_adapter *self,double targetspec,double obsper,int NS,int NM,int NL) {
+    int i;
+
+    adapt2_data *data= &self->d.a2;
+
+    self->adapt_mode= 2;
+    self->adapt_period= (time_t)(obsper+0.5);
+    self->adapt_by_count= 1;
+    
+    data->targetspec= targetspec;
+    data->obsper= obsper;
+    data->NS= NS;
+    data->NM= NM;
+    data->NL= NL;
+    
+    /* 10000000 packets per hour is an overestimate but ensures we keep enough during the first period */
+    data->target= (int) floor(0.5+ (targetspec >= 1 ? targetspec*(obsper/3600.0) : ((10000000/3600.0)*obsper)*targetspec));
+    if (data->target==0) data->target= 1; /* ensure at least 1 long */
+
+    data->obslists_head= (dll_double **)malloc(NS * sizeof(dll_double *));
+    data->obslists_tail= (dll_double **)malloc(NS * sizeof(dll_double *));
+    data->obslists_size= (int *)malloc(NS * sizeof(int));
+    for (i= 0; i < NS; i++) {
+        data->obslists_head[i]= new_dll_double(0.0);
+        data->obslists_tail[i]= new_dll_double(0.0);
+        data->obslists_head[i]->next= data->obslists_tail[i];
+        data->obslists_tail[i]->prev= data->obslists_head[i];
+        data->obslists_size[i]= 1;
+    }
+    data->obsper_count= 0;
+    data->recScomps= (double *)malloc(NM * sizeof(double));
+    data->recMcomps= (double *)malloc(NL * sizeof(double));
+    
+    data->mid_anom_comp= 0;
+    data->long_anom_comp= 0;
+
+    data->obslist_new_slot= 0;
+    
+    data->per2_count=0;
+    data->per3_count=0;
+}
+
+static void thresh_adapter_setup_2_from_str(thresh_adapter *self,char *str) {
+    double targetspec=0.01,obsper=15;
+    int NS=4,NM=24,NL=7;
+    void *args[4];
+
+    args[0]= &targetspec;
+    args[1]= &obsper;
+    args[2]= &NS;
+    args[3]= &NM;
+    args[4]= &NL;
+    fill_args_space_sep(str,"d:target;d:obsper;i:NS;i:NM;i:NL",args,self->msg_callback);
+
+    obsper*= 60;
+    thresh_adapter_setup_2(self,targetspec,obsper,NS,NM,NL);
+}
+
+void thresh_adapter_setup_3(thresh_adapter *self,double targetspec,double obsper,int NO) {
+    adapt3_data *data= &self->d.a3;
+
+    self->adapt_mode= 3;
+    self->adapt_period= (time_t)(obsper+0.5);
+    self->adapt_by_count= 1;
+    
+    data->targetspec= targetspec;
+    data->NO= NO;
+    
+    /* 10000 packets per hour is our pure guess as to the rate of packets.
+       Is there a better way to figure out how many packets to note for our
+       first interval when we want a percent of packets? */
+    data->target= (int) floor(0.5+ (targetspec >= 1 ? targetspec*(obsper/3600.0) : ((10000/3600.0)*obsper)*targetspec));
+    if (data->target==0) data->target= 1;
+
+    data->hist= (double *)malloc(sizeof(double)*NO);
+    
+    /* init list to contain 0 and 0; this is to let us assume the list
+       has a bottom and runner-up elsewhere */
+    data->anoms= (ll_double *)malloc(sizeof(ll_double));
+    data->anoms->val= 0.0;
+    data->anoms->next= (ll_double *)malloc(sizeof(ll_double));
+    data->anoms->next->val= 0.0;
+    data->anoms->next->next= NULL;
+    data->anoms_size= 1;
+    data->completed_obs_per= 0;
+    data->obssum= 0;
+}
+
+static void thresh_adapter_setup_3_from_str(thresh_adapter *self,char *str) {
+    double targetspec=0.01,obsper=60;
+    int NO=168;
+    void *args[3];
+
+    args[0]= &targetspec;
+    args[1]= &obsper;
+    args[2]= &NO;
+    fill_args_space_sep(str,"d:target;d:obsper;i:numper",args,self->msg_callback);
+    obsper*= 60;
+    thresh_adapter_setup_3(self,targetspec,obsper,NO);
+}
+
+void thresh_adapter_setup_4(thresh_adapter *self,double thresh,double obsper) {
+    adapt4_data *data= &self->d.a4;
+
+    self->adapt_mode= 4;
+    self->adapt_period= (time_t)(obsper+0.5);
+    self->adapt_by_count= 0;
+    
+    data->thresh= thresh;
+}
+
+static void thresh_adapter_setup_4_from_str(thresh_adapter *self,char *str) {
+    double thresh=0.8,obsper=60;
+    void *args[2];
+
+    args[0]= &thresh;
+    args[1]= &obsper;
+    fill_args_space_sep(str,"d:thresh;d:obsper",args,self->msg_callback);
+    obsper*= 60;
+    thresh_adapter_setup_4(self,thresh,obsper);
+}
+
+
+void thresh_adapter_start_time(thresh_adapter *self,time_t now) {
+    //self->obs_start_time= now;
+    self->period_start= now;
+}
+
+int thresh_adapter_new_time(thresh_adapter *self,spade_enviro *enviro,double *sugg_thresh) {
+    int adapt_now= 0;
+    int new_period= 0;
+    if (self->done) return 0;
+    
+    if (self->period_start == (time_t)0) { /* first time called and start time not given */
+        self->period_start= enviro->now;
+        return 0;
+    }
+
+    while (enviro->now > (self->period_start + self->adapt_period)) {
+        new_period= 1;
+        thresh_adapter_new_pkt_rate(self,enviro);
+    }
+
+    if (self->adapt_by_count && (self->pkt_period_count >= 1)) {
+        if ((*(enviro->total_pkts) - self->last_total_stats) >= self->period_pkt_rate) {
+            adapt_now= 1;
+        }
+    } else {
+        if (new_period) {
+            adapt_now= 1;
+        }
+    }
+    
+    if (adapt_now) {
+        self->last_total_stats= *(enviro->total_pkts);
+        switch (self->adapt_mode) {
+        case 1: *sugg_thresh= grab_new_thresh_1(self,enviro); break;
+        case 2: *sugg_thresh= grab_new_thresh_2(self,enviro); break;
+        case 3: *sugg_thresh= grab_new_thresh_3(self,enviro); break;
+        case 4: *sugg_thresh= grab_new_thresh_4(self,enviro); break;
+        }
+    
+        return 1;
+    }
+    return 0;
+}
+
+static void thresh_adapter_new_pkt_rate(thresh_adapter *self,spade_enviro *enviro) {
+    self->pkt_period_count++;
+    self->period_pkt_rate= *(enviro->total_pkts)/(float)self->pkt_period_count;
+    self->period_acc_rate= enviro->pkt_stats.scored/(float)self->pkt_period_count;
+    self->period_start+= self->adapt_period;
+
+    switch (self->adapt_mode) {
+    //case 1: thresh_adapter_1_new_pkt_rate(self,enviro); break;
+    case 2: thresh_adapter_2_new_pkt_rate(self,enviro); break;
+    case 3: thresh_adapter_3_new_pkt_rate(self,enviro); break;
+    }
+}
+
+static void thresh_adapter_2_new_pkt_rate(thresh_adapter *self,spade_enviro *enviro) {
+    adapt2_data *data= &self->d.a2;
+    dll_double *l;
+    
+    data->target= (int) floor(0.5+ (data->targetspec >= 1 ? data->targetspec*(self->adapt_period/3600.0) : data->targetspec*self->period_acc_rate));
+    if (data->target==0) data->target= 1; /* ensure at least 1 long */
+    
+    //if (self->debug_level) printf("new target is %d\n",data->target);
+    
+    if (data->obsper_count == 0) {
+        data->obsper_count++;
+        data->obslist_new_slot= data->obsper_count % data->NS;
+        if (data->obslists_size[0] > data->target) { /* remove excess */
+            int i;
+            for (i= data->target, l=data->obslists_head[0]; i < data->obslists_size[0]; i++,l=l->next);
+            l->prev->next= NULL;
+            l->prev= NULL;
+            free_dll_double_list(data->obslists_head[0]);
+            data->obslists_head[0]= l;
+        }
+    }
+}
+
+static void thresh_adapter_3_new_pkt_rate(thresh_adapter *self,spade_enviro *enviro) {
+    adapt3_data *data= &self->d.a3;
+    ll_double *prev,*newstart;
+    int i;
+
+    data->target= (int) floor(0.5+ (data->targetspec >= 1 ? data->targetspec*(data->obsper/3600.0) : data->targetspec*self->period_acc_rate));
+    if (data->target==0) data->target= 1;
+    //if (self->debug_level) printf("new target is %d\n",data->target);
+    
+    if (data->completed_obs_per == 0) {
+        if (data->anoms_size > data->target) { /* remove excess */
+            for (i= data->target, prev=data->anoms; (i+1) < data->anoms_size; i++,prev=prev->next);
+            newstart= prev->next;
+            prev->next= NULL;
+            free_ll_double_list(data->anoms);
+            data->anoms= newstart;
+        }
+    }
+}
+
+static float grab_new_thresh_1(thresh_adapter *self,spade_enviro *enviro) {
+    ll_double *l;
+    float new_thresh;
+    adapt1_data *data= &self->d.a1;
+    double obs_thresh= (data->top_list->val + data->top_list->next->val)/2;
+    //if (self->debug_level) printf("observed recent ideal threshold is %.4f\n",obs_thresh);
+    if (enviro->thresh < 0.0) { /* started up with no reporting */
+        new_thresh= obs_thresh;
+    } else {
+        new_thresh= (1-data->new_obs_weight)*enviro->thresh + data->new_obs_weight*obs_thresh;
+    }
+    
+    //if (self->debug_level) printf("new threshold is %.4f\n",new_thresh); 
+    
+    for (l=data->top_list; l != NULL; l=l->next)  l->val= 0.0;
+    
+    return new_thresh;
+}
+
+static float grab_new_thresh_2(thresh_adapter *self,spade_enviro *enviro) {
+    int new_thresh= calc_new_thresh_2(self,enviro);
+    adapt2_data *data= &self->d.a2;
+
+    data->obsper_count++;
+    data->obslist_new_slot= data->obsper_count % data->NS;
+    reset_obslist(data,data->obslist_new_slot);
+
+    return new_thresh;
+}
+
+static float calc_new_thresh_2(thresh_adapter *self,spade_enviro *enviro) {
+    adapt2_data *data= &self->d.a2;
+    double rec_anom_comp= thresh_from_obslists(data);
+
+    //if (self->debug_level) printf("* New recent anom observation (#%d) is %.5f\n",data->obsper_count,rec_anom_comp);
+    if (data->obsper_count < (data->NS-1)) {
+        return rec_anom_comp; /* haven't observed mid or long yet */
+    }
+    if (((data->obsper_count+1) % data->NS) == 0) { /* time to add new mid */
+        data->recScomps[data->per2_count % data->NM]= rec_anom_comp;
+        //if (self->debug_level) printf("data->recScomps[%d]:= %.5f\n",data->per2_count % data->NM,rec_anom_comp);
+        data->per2_count++;
+        data->mid_anom_comp= anom_ave(data->recScomps,((data->per2_count < data->NM)?data->per2_count:data->NM));
+        //if (self->debug_level) printf("** New mid anom component (#%d) is %.5f\n",data->per2_count-1,data->mid_anom_comp);
+        if (data->per2_count < (data->NM-1)) {
+            return (rec_anom_comp+data->mid_anom_comp)/2.0; /* haven't observed long yet */
+        }
+        if ((data->per2_count % data->NM) == 0) { /* time to add new long */
+            data->recMcomps[data->per3_count % data->NL]= data->mid_anom_comp;
+            //if (self->debug_level) printf("data->recMcomps[%d]:= %.5f\n",data->per3_count % data->NL,data->mid_anom_comp);
+            data->per3_count++; 
+            data->long_anom_comp= anom_ave(data->recMcomps,((data->per3_count < data->NL)?data->per3_count:data->NL));
+            //if (self->debug_level) printf("*** New long anom component (#%d) is %.5f\n",data->per3_count-1,data->long_anom_comp);
+        }
+    }
+    if (data->per2_count < data->NM) {
+        return (rec_anom_comp+data->mid_anom_comp)/2.0; /* haven't observed long yet */
+    }
+    return (rec_anom_comp+data->mid_anom_comp+data->long_anom_comp)/3.0;
+}
+
+static double thresh_from_obslists(adapt2_data *data) {
+    dll_double **pos= (dll_double **)malloc(data->NS * sizeof(dll_double *));
+    int i,c,maxpos=-1;
+    double max,last_score=0.0,before_last_score=0.0;
+    if (0) { /*(self->debug_level > 1) {*/
+        dll_double *l;
+        printf("thresh_from_obslists: finding score that is #%d highest in:\n",data->target);
+        for (i= 0; i < data->NS; i++) {
+            printf("  slot %d: %.5f",i,data->obslists_head[i]->val);
+            for (l=data->obslists_head[i]->next; l != NULL; l=l->next) {
+                printf(" -> %.5f",l->val);
+            }
+            printf("\n");
+        }
+    }
+    for (i= 0; i < data->NS; i++) { /* init pos's to be the list tails */
+        pos[i]= data->obslists_tail[i];
+    }
+    for (c= 1; c <= data->target+1; c++) {
+        max= -1;
+        for (i= 0; i < data->NS; i++) {
+            if (pos[i] != NULL) {
+                if (max < pos[i]->val) {
+                    max= pos[i]->val;
+                    maxpos= i;
+                }
+                
+            }
+        }
+        if (max == -1) {/* should only happen if we don't have enough packets recorded */
+            free(pos);
+            return last_score; 
+        }
+        pos[maxpos]= pos[maxpos]->prev; /* we extracted the tail, so put prev here now */
+        before_last_score= last_score;
+        last_score= max; /* in case this is the last */
+    }
+    free(pos);
+    return (before_last_score+last_score)/2.0;
+}
+
+static double anom_ave(double a[],int size) {
+    double sum= 0.0;
+    int i;
+    if (0) { // self->debug_level) {
+        printf("anom_ave: taking average of (%.5f",a[0]);
+        for (i=1; i < size; i++) printf(",%.5f",a[i]);
+        printf(")\n");
+    }
+    for (i=0; i < size; i++) sum+= a[i];
+    return sum/(double)size;
+}
+
+static void reset_obslist(adapt2_data *data,int slot) {
+    dll_double *first= data->obslists_head[slot];
+    dll_double *second= first->next;
+    if (second->next != NULL) free_dll_double_list(second->next);
+    first->val= 0.0;
+    second->val= 0.0;
+    second->next= NULL;
+    data->obslists_tail[slot]= second;
+    data->obslists_size[slot]= 1;
+}
+
+
+static float grab_new_thresh_3(thresh_adapter *self,spade_enviro *enviro) {
+    ll_double *l;
+    int slot;
+    float new_thresh;
+    adapt3_data *data= &self->d.a3;
+    double obs_thresh= (data->anoms->val + data->anoms->next->val)/2;
+    
+    //if (self->debug_level) printf("observed recent ideal threshold for adapt3 is %.4f\n",obs_thresh);
+    
+    slot= data->completed_obs_per % data->NO;
+    data->completed_obs_per++;
+    if (data->completed_obs_per > data->NO) data->obssum-= data->hist[slot]; /* kicking a score out */
+    data->hist[slot]= obs_thresh;
+    data->obssum+= obs_thresh;
+    
+    if (0) { // self->debug_level > 1) {
+        int i;
+        printf("data->hist= [");
+        printf("%.4f",data->hist[0]);
+        for (i= 1; i < data->NO && i < data->completed_obs_per; i++) {
+            printf(",%.4f",data->hist[i]);
+        }
+        printf("]\n");
+    }
+    
+    new_thresh= data->obssum/((data->completed_obs_per >= data->NO)?data->NO:data->completed_obs_per);  
+    //if (self->debug_level) printf("new threshold is %.4f\n",new_thresh); 
+    
+    for (l=data->anoms; l != NULL; l=l->next)  l->val= 0.0;
+    
+    return new_thresh;
+}
+
+static float grab_new_thresh_4(thresh_adapter *self,spade_enviro *enviro) {
+    adapt4_data *data= &self->d.a4;
+    self->done= 1;
+    return data->thresh;
+}
+
+
+
+
+void thresh_adapter_new_score(thresh_adapter *self,double anom_score) {
+    if (self->done) return;
+    switch (self->adapt_mode) {
+    case 1: thresh_adapter_1_new_score(self,anom_score); break;
+    case 2: thresh_adapter_2_new_score(self,anom_score); break;
+    case 3: thresh_adapter_3_new_score(self,anom_score); break;
+    }
+}
+
+static void thresh_adapter_1_new_score(thresh_adapter *self,double anom_score) {
+    ll_double *new,*prev,*l;
+    adapt1_data *data= &self->d.a1;
+        
+    /* add anomaly score to list if it is high enough */
+    if (data->top_list_size <= data->target) {
+        new= (ll_double *)malloc(sizeof(ll_double));
+        data->top_list_size++;
+    } else if (anom_score > data->top_list->val) {
+        if (anom_score < data->top_list->next->val) {
+            data->top_list->val= anom_score; /* can just replace first */
+            return;
+        }
+        new= data->top_list;
+        data->top_list= data->top_list->next;
+    } else {
+        return;
+    }
+    new->val= anom_score;
+    for (prev= data->top_list, l=data->top_list->next; l != NULL && anom_score > l->val; prev=l,l=l->next);
+    /* add between prev and l */
+    prev->next= new;
+    new->next= l;
+}
+
+static void thresh_adapter_2_new_score(thresh_adapter *self,double anom_score) {
+    dll_double *new,*prev,*l;
+    adapt2_data *data= &self->d.a2;
+    double score= anom_score;
+    int slot= data->obslist_new_slot;
+
+    if (data->obslists_size[slot] < data->target) {
+        new= new_dll_double(score);
+        data->obslists_size[slot]++;
+    } else if (score > data->obslists_head[slot]->val) {
+        if (score < data->obslists_head[slot]->next->val) {
+            data->obslists_head[slot]->val= score; /* can just replace first in place*/
+            return;
+        }
+        new= data->obslists_head[slot];
+        new->val= score;
+        data->obslists_head[slot]= data->obslists_head[slot]->next;
+        new->next->prev= NULL;
+    } else {
+        return;
+    }
+    for (l=data->obslists_head[slot]->next; l != NULL && score > l->val; l=l->next);
+    /* add between l->prev and l */
+    prev= (l == NULL) ? data->obslists_tail[slot] : l->prev;
+    prev->next= new;
+    new->prev= prev;
+    new->next= l;
+    if (l == NULL) {
+        data->obslists_tail[slot]= new;
+    } else {
+        l->prev= new;
+    }
+}
+
+
+
+static void thresh_adapter_3_new_score(thresh_adapter *self,double anom_score) {
+    adapt3_data *data= &self->d.a3;
+    ll_double *prev,*next,*new;
+
+    /* add anomaly score to list if it is high enough */
+    if (data->anoms_size <= data->target) {
+        new= new_ll_double(anom_score);
+        data->anoms_size++;
+    } else if (anom_score > data->anoms->val) {
+        if (anom_score < data->anoms->next->val) {
+            data->anoms->val= anom_score; /* can just replace first */
+            return;
+        }
+        new= data->anoms;
+        new->val= anom_score;
+        data->anoms= data->anoms->next;
+    } else {
+        return;
+    }
+    for (prev= data->anoms, next=data->anoms->next; next != NULL && anom_score > next->val; prev=next,next=next->next);
+    /* add between prev and next */
+    prev->next= new;
+    new->next= next;
+}
+
+void thresh_adapter_print_config_details(thresh_adapter *self,FILE *f,char *indent) {
+    char indent2[100];
+    sprintf(indent2,"%s  ",indent);
+    
+    fprintf(f,"%sadapt_mode=%d\n",indent,self->adapt_mode);
+    fprintf(f,"%sadapt_period=%d; adapt_by_count=%d\n",indent,(int)self->adapt_period,self->adapt_by_count);
+
+    switch (self->adapt_mode) {
+    case 1:
+        fprintf(f,"%starget=%d; period=%d; new_obs_weight=%.3f\n",indent,self->d.a1.target,(int)self->d.a1.period,self->d.a1.new_obs_weight);
+        break;
+    case 2:
+        fprintf(f,"%stargetspec=%.3f; obsper=%d\n",indent,self->d.a2.targetspec,(int)self->d.a2.obsper);
+        fprintf(f,"%sNS=%d; NM=%d; NL=%d\n",indent,self->d.a2.NS,self->d.a2.NM,self->d.a2.NL);
+        break;
+    case 3:
+        fprintf(f,"%stargetspec=%.3f; obsper=%d; NO=%d\n",indent,self->d.a3.targetspec,(int)self->d.a3.obsper,self->d.a3.NO);
+        break;
+    case 4:
+        fprintf(f,"%sthresh=%.3f\n",indent,self->d.a4.thresh);
+        break;
+    }
+}
+
+/*@}*/
+/* Id: thresh_adapter.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+thresh_adviser.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file thresh_adviser.c
+ * \brief 
+ *  thresh_adviser.c contains a "class" thresh_adviser which takes
+ *  observations of Spade anomaly scores and provides a recommendation
+ *  about how to set the threshold to achieve a target rate.
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+#include <stdlib.h>
+
+void init_thresh_adviser(thresh_adviser *self,int obs_size,int obs_secs,spade_msg_fn msg_callback) {
+    self->obs_size= obs_size;
+    self->obs_secs= obs_secs;
+    
+    /* init list to contain just 0; this is to let us assume the list is not
+       empty elsewhere */
+    self->top_anom_list= (ll_double *)malloc(sizeof(ll_double));
+    self->top_anom_list->next= NULL;
+    self->top_anom_list->val= 0.0;
+    self->top_anom_list_size= 1;
+    
+    self->obs_start_time= (time_t)0;
+}
+
+void init_thresh_adviser_from_str(thresh_adviser *self,char *str,spade_msg_fn msg_callback) {
+    int obs_size=200,hours=24;
+    void *args[2];
+    time_t obs_secs;
+
+    args[0]= &obs_size;
+    args[1]= &hours;
+    fill_args_space_sep(str,"i:target;i:obsper",args,msg_callback);
+
+    obs_secs= (time_t)(hours*3600);
+    init_thresh_adviser(self,obs_size,obs_secs,msg_callback);
+}
+
+thresh_adviser *new_thresh_adviser(int obs_size,int obs_secs,spade_msg_fn msg_callback) {
+    thresh_adviser *new= (thresh_adviser *)malloc(sizeof(thresh_adviser));
+    init_thresh_adviser(new,obs_size,obs_secs,msg_callback);
+    return new;
+}
+
+void thresh_adviser_reset(thresh_adviser *self,int obs_size,int obs_secs,spade_msg_fn msg_callback) {
+    free_ll_double_list(self->top_anom_list);
+    init_thresh_adviser(self,obs_size,obs_secs,msg_callback);
+}
+
+void thresh_adviser_start_time(thresh_adviser *self,time_t time) {
+    self->obs_start_time= time;
+}
+
+int thresh_adviser_new_time(thresh_adviser *self,spade_enviro *enviro) {
+    if (self->obs_start_time == 0) { /* first time and start time not given */
+        self->obs_start_time= enviro->now;
+    } else if (enviro->now > (self->obs_start_time + self->obs_secs)) {
+        return 1;
+    }
+    return 0;
+}
+
+void thresh_adviser_new_score(thresh_adviser *self,double anom_score) {
+    ll_double *new,*prev,*l;
+    
+    if (self->top_anom_list_size <= self->obs_size) {
+        new= (ll_double *)malloc(sizeof(ll_double));
+        self->top_anom_list_size++;
+    } else if (anom_score > self->top_anom_list->val) {
+        if (self->top_anom_list->next == NULL ||
+            (self->top_anom_list->next != NULL && anom_score < self->top_anom_list->next->val)) {
+            self->top_anom_list->val= anom_score; /* can just replace first */
+            return;
+        }
+        new= self->top_anom_list;
+        self->top_anom_list= self->top_anom_list->next;
+    } else {
+        return;
+    }
+    new->val= anom_score;
+    for (prev= self->top_anom_list, l=self->top_anom_list->next; l != NULL && anom_score > l->val; prev=l,l=l->next);
+    /* add between prev and l */
+    prev->next= new;
+    new->next= l;   
+
+    return; // not done yet
+}
+
+void thresh_adviser_write_advice(thresh_adviser *self,FILE *file) {
+    ll_double *n;
+    double obs_hours= self->obs_secs/3600.0;
+
+    if (!self->obs_size || self->top_anom_list_size <= 1) return;
+
+    fprintf(file,"Threshold learning results: top %d anomaly scores over %.5f hours\n",self->top_anom_list_size-1,obs_hours);
+    fprintf(file,"  Suggested threshold based on observation: %.6f\n",(self->top_anom_list->val+self->top_anom_list->next->val)/2);
+    fprintf(file,"  Top scores: %.5f",self->top_anom_list->next->val);
+    for (n=self->top_anom_list->next->next; n != NULL; n=n->next) {
+        fprintf(file,",%.5f",n->val);
+    }
+    fprintf(file,"\n  First runner up is %.5f, so use threshold between %.5f and %.5f for %.3f packets/hr\n",self->top_anom_list->val,self->top_anom_list->val,self->top_anom_list->next->val,(self->top_anom_list_size/obs_hours));    
+}
+
+void thresh_adviser_print_config_details(thresh_adviser *self, FILE *f, char *indent) {
+    fprintf(f,"%sobs_size=%d; obs_secs=%d\n",indent,self->obs_size,(int)self->obs_secs);
+}
+
+/*@}*/
+/* Id: thresh_adviser.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+anomscore_surveyer.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*! \file anomscore_surveyer.c
+ * \brief 
+ *  anomscore_surveyer.c contains a class to do a survey of anomaly scores
+ * \ingroup stmgr
+ */
+
+/*! \addtogroup stmgr Score and threshold management
+    @{
+*/
+
+static double survey_ostat(anomscore_surveyer *self, double loc);
+
+int init_anomscore_surveyer(anomscore_surveyer *self,char *filename,float interval,spade_msg_fn msg_callback) {
+    if (filename == NULL) filename="-";
+    if (!strcmp(filename,"-")) {
+        self->surveyfile= stdout;
+    } else {
+        self->surveyfile= fopen(filename,"w");
+    }
+    if (!self->surveyfile) return 0;
+
+    self->interval= interval;
+    self->filename= strdup(filename);
+    self->list= NULL;
+    self->list_len= 0;
+    self->period= 1;
+    self->interval_start_time= (time_t)0;
+    self->rec_count= 0;
+    
+    fprintf(self->surveyfile,"%.2f minute interval #\tPacket Count\tMedian Anom\t90th Percentile Anom\t99th Percentile Anom\n",self->interval/60.0);
+
+    return 1;
+}
+
+int init_anomscore_surveyer_from_str(anomscore_surveyer *self,char *str,spade_msg_fn msg_callback) {
+    char filename[400]= "-";
+    float interval=60.0;
+    void *args[2];
+
+    args[0]= &filename;
+    args[1]= &interval;
+    fill_args_space_sep(str,"s400:surveyfile;f:interval",args,msg_callback);
+
+    interval*= 60.0;
+    return init_anomscore_surveyer(self,filename,interval,msg_callback);
+}
+
+anomscore_surveyer *new_anomscore_surveyer(char *filename,float interval,spade_msg_fn msg_callback) {
+    anomscore_surveyer *new= (anomscore_surveyer *)malloc(sizeof(anomscore_surveyer));
+    init_anomscore_surveyer(new,filename,interval,msg_callback);
+    return new;
+}
+
+void anomscore_surveyer_flush(anomscore_surveyer *self) {
+    fflush(self->surveyfile);
+}
+
+void anomscore_surveyer_shutdown(anomscore_surveyer *self) {
+    fclose(self->surveyfile);
+}
+
+void anomscore_surveyer_new_time(anomscore_surveyer *self,spade_enviro *enviro) {
+    while (enviro->now > (self->interval_start_time + self->interval)) {
+        if (self->interval_start_time == 0) { /* first packet */
+            self->interval_start_time= enviro->now;
+        } else {
+            fprintf(self->surveyfile,"%d\t%d\t%.6f\t%.6f\t%.6f\n",self->period,self->rec_count,survey_ostat(self,0.5),survey_ostat(self,0.9),survey_ostat(self,0.99));
+            fflush(self->surveyfile);
+            if (self->list) 
+                free_ll_double_list(self->list);
+            self->list= NULL;
+            self->list_len= 0;
+            self->rec_count=0;
+            self->period++;
+            self->interval_start_time+= (long) self->interval;
+        }
+    }
+}
+
+void anomscore_surveyer_new_score(anomscore_surveyer *self,double anom_score) {
+    ll_double *new,*prev,*next;
+
+    new= new_ll_double(anom_score);
+    
+    if (self->list == NULL) {
+        self->list= new;
+        self->list_len= 1;
+    } else {
+        if (anom_score < self->list->val) { /* add at head */
+            new->next= self->list;
+            self->list= new;
+        } else {
+            for (prev= self->list, next=self->list->next; next != NULL && anom_score > next->val; prev=next,next=next->next);
+            /* add between prev and next */
+            prev->next= new;
+            new->next= next;    
+        }
+        self->list_len++;
+    }
+
+    self->rec_count++;
+}   
+
+static double survey_ostat(anomscore_surveyer *self,double loc) {
+    ll_double *pos;
+    int p;
+    double fromnext;
+    double posnum;
+    
+    if (self->list_len == 0) return 0.0;
+    posnum= loc*(double)self->list_len + (1.0-loc);/* = (self->list_len-1)*loc+1 */
+
+    for (p= 1, pos=self->list; p <= posnum && pos->next != NULL; p++,pos=pos->next);
+    fromnext= posnum-(double)(p-1);
+    if (fromnext == 0.0 || pos->next == NULL) { /* got it exactly */
+        return pos->val;
+    } else {
+        return (pos->val*(1-fromnext))+(pos->next->val*fromnext);
+    }
+}
+
+void anomscore_surveyer_print_config_details(anomscore_surveyer *self,FILE *f,char *indent) {
+    fprintf(f,"%sinterval=%.2f; filename=%s\n",indent,self->interval,self->filename);
+}
+
+/*@}*/
+/* Id: anomscore_surveyer.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+strtok.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+
+/*! \file strtok.c
+ * \brief
+ *  strtok.c contains a module providing string parsing functionality
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util
+    @{
+*/
+
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/// a record for an argument we are set to expect
+typedef struct _argspec {
+    /// the next argspec in a linked list
+    struct _argspec *next;
+    /// an indication of what type of argument value we are expecting and how to interpret it
+    /** 'c' indicates a single character, 's' a string, 'd' a double,
+        'f' a float, 'l' a long int, 'i' and int, and 'b' a boolean */
+    char type;
+    /// if we are expecting a sting, the maximum number of charecters that should be read
+    int maxlen;
+    /// for matching unlabeled argument values, this is the position number we are expect our value to be in
+    int argpos;
+    /// up to 5 strings we accept as our argument name; list is terminated by a '\0' in the first char of the first unused array slot
+    char labels[5][50];
+} argspec;
+
+argspec *argspec_freelist= NULL;
+
+static argspec *new_argspec(char format, int argpos);
+static void free_argspecs(argspec *head);
+//static void free_argspec(argspec *spec);
+static argspec *parse_argspec_format(char *format);
+
+int strtok_space_sep(char *str,char **after) {
+    char *p= str;
+    int len= 0;
+    if (p == NULL) return 0;
+    while (*p != '\0' && !isspace((int)*p)) {
+        p++;
+        len++;
+    }
+    while (*p != '\0' && isspace((int)*p)) p++;
+    *after= p;
+    return len;
+}
+
+static argspec *new_argspec(char format,int argpos) {
+    argspec *new;
+    if (argspec_freelist == NULL) {
+        new= (argspec *)malloc(sizeof(argspec));
+    } else {
+        new= argspec_freelist;
+        argspec_freelist= argspec_freelist->next;
+    }
+    new->next= NULL;
+    new->type= format;
+    new->maxlen= 0;
+    new->argpos= argpos;
+    new->labels[0][0]= '\0';
+    return new;
+}
+
+static void free_argspecs(argspec *head) {
+    argspec *last;
+    if (head == NULL) return;
+    for (last= head; last->next != NULL; last=last->next);
+    last->next= argspec_freelist;
+    argspec_freelist= head;
+}
+
+#if 0
+static void free_argspec(argspec *spec) {
+    if (spec == NULL) return;
+    spec->next= argspec_freelist;
+    argspec_freelist= spec;
+}
+#endif
+
+static argspec *parse_argspec_format(char *format) {
+    char errstr[100]= "\0";
+    char *f= format;
+    argspec *spec,*spechead=NULL,*spectail=NULL;
+    int argpos= 0;
+    char *rem;
+    
+    while (f != NULL && *f != '\0') {
+        // parse new arg
+        argpos++;
+        if (*f != 'c' && *f != 's' && *f != 'd' && *f != 'f' && *f != 'l' && *f != 'i' && *f != 'b') {
+            sprintf(errstr,"invalid arg letter: %c",*f);
+            break;
+        }
+        spec= new_argspec(*f,argpos);
+        f++;
+        if (isdigit(*f)) {
+            spec->maxlen= strtol(f,&f,10);
+        }
+        if (*f == ':') {
+            int count= 0;
+            f++;
+            while (isspace((int)*f)) f++;
+            rem= f;
+            f= strchr(rem,';');
+            do {
+                int len= 0;
+                if (*rem == ',') rem++;
+                while (isspace((int)*rem)) rem++;
+                while (*rem != '\0' && !isspace((int)*rem) && *rem != ',' && *rem != ';' && len < 50) {
+                    spec->labels[count][len]= *rem;
+                    rem++;
+                    len++;
+                }
+                spec->labels[count][len]= '\0';
+                while (isspace((int)*rem)) rem++;
+                count++;
+                if (count < 5) spec->labels[count][0]= '\0';
+            } while (count < 5 && *rem == ',');
+        }
+        if (f != NULL) {
+            while (isspace((int)*f)) f++;
+            if (*f == ';') f++;
+            while (isspace((int)*f)) f++;
+        }
+        if (spechead == NULL) {
+            spechead= spectail= spec;
+        } else {
+            spectail->next= spec;
+            spectail= spec;
+        }
+    }
+    if (errstr[0] != '\0') { // an error occurred
+        fprintf(stderr,"syntax error in spec format: %s: \"%s\"",errstr,format);
+        free_argspecs(spechead);
+        return NULL;
+    }
+    return spechead;
+}
+
+int fill_args_space_sep(char *str,char *format,void *args[],spade_msg_fn msg_callback) {
+    int i,arrfilepos;
+    char *next,*seppos,*labelhead,*valhead,*after;
+    char oldchar;
+    int copylen,len,labellen;
+    char *strcopy= strdup(str);
+    char *head= strcopy;
+    int argpos= 0;
+    int count= 0;
+    int no_pos_based= 0;
+    argspec *curspec,*spec;
+    argspec *argspecs;
+    argspec *pb_spec;
+    
+    if (*format == '$') {
+        no_pos_based= 1;
+        format++;
+    }
+    argspecs= parse_argspec_format(format);
+    pb_spec= argspecs;
+
+    while (head != NULL) {
+        argpos++;
+        len= strtok_space_sep(head,&next);
+        if (len == 0) break;
+        after= head+len;
+        oldchar= *after;
+        *after= '\0'; // temporarily null terminate head
+        
+        seppos= strchr(head,'=');
+        if (seppos == NULL) { // boolean label-based spec else position based spec
+            valhead= head;
+            labelhead= head;
+            labellen= len;
+        } else { // label-based spec or else string position based spec that contains a '='
+            /* search for matching spec label */
+            labelhead= head;
+            labellen= seppos-labelhead;
+            valhead= seppos+1;
+        }
+        
+        /* look for label-based-spec */
+        curspec= NULL;
+        for (spec= argspecs; curspec == NULL && spec != NULL; spec= spec->next) {
+            if (seppos == NULL && spec->type != 'b') continue;
+            for (i=0; i < 5; i++) {
+                if (spec->labels[i][0] == '\0') break;
+                if (!strncmp(spec->labels[i],labelhead,labellen) && strlen(spec->labels[i]) == labellen) {
+                    curspec= spec;
+                    break;
+                }
+            }
+        }
+        if (curspec == NULL) { // must be position based spec
+            if (!no_pos_based || pb_spec == NULL) {
+                if (seppos != NULL) { // must be string position based spec that contains a '='
+                    valhead= head; /* reset value start to start of arg */
+                }
+                while ((pb_spec->next != NULL) && (pb_spec->argpos < argpos)) pb_spec=pb_spec->next;
+            }
+            if (no_pos_based || pb_spec == NULL || (seppos != NULL && pb_spec->type != 's') || pb_spec->argpos != argpos) {
+                formatted_spade_msg_send(SPADE_MSG_TYPE_WARNING,msg_callback,"Warning: option \"%s\" not understood in \"%s\"; ignoring it",labelhead,str);
+                *(head+len)= oldchar; // restore orig char
+                head= next;
+                continue; // no match; ignore
+            }
+            curspec= pb_spec;
+        } else {
+            if (seppos == NULL) { /* a boolean with no '=' */
+                valhead= NULL;
+            }
+        }
+            
+        arrfilepos= curspec->argpos-1;
+        switch (curspec->type) {
+            case 'i':
+                *((int *)args[arrfilepos])= atoi(valhead);
+                break;
+            case 'l':
+                *((long *)args[arrfilepos])= atol(valhead);
+                break;
+            case 'f':
+                *((float *)args[arrfilepos])= (float)atof(valhead);
+                break;
+            case 'd':
+                *((double *)args[arrfilepos])= atof(valhead);
+                break;
+            case 'c':
+                *((char *)args[arrfilepos])= *valhead;
+                break;
+            case 'b':
+            {
+                int bool;
+                if (valhead == NULL) {
+                    bool= 1;
+                } else {
+                    if (!strcmp(valhead,"yes") || !strcmp(valhead,"true") || !strcmp(valhead,"on")) {
+                        bool= 1;
+                    } else if  (!strcmp(valhead,"no") || !strcmp(valhead,"false") || !strcmp(valhead,"off")) {
+                        bool= 0;
+                    } else {
+                        bool= atoi(valhead);
+                    }
+                }
+                *((int *)args[arrfilepos])= bool;
+                break;
+            }
+            case 's':
+                copylen= after-valhead;
+                if (curspec->maxlen) {
+                    if (len > curspec->maxlen) copylen=curspec->maxlen;
+                }
+                strncpy((char *)args[arrfilepos],valhead,copylen);
+                ((char *)args[arrfilepos])[copylen]= '\0';
+                break;
+            default:
+                args[arrfilepos]= NULL;
+                break;
+        }
+        
+        *after= oldchar; // restore orig char
+        count++;
+        head= next;
+    }
+    free(strcopy);
+    free_argspecs(argspecs);
+    return count;
+}
+
+char *extract_str_arg_space_sep(char *str,char *argname) {
+    char *after;
+    char *val,*valhead;
+    int vallen,copylen;
+    char *head= str;
+    int arglen= strlen(argname);
+    char *strafter= str+strlen(str);
+    while ((head=strstr(head,argname)) != NULL) {
+        if (head != str && !isspace((int)*(head-1)))
+            continue;
+        after= head+arglen;
+        if (*(head+arglen) != '=')
+            continue;
+            
+        /* found it */
+        /* put in a str */
+        valhead= after+1;
+        after= valhead;
+        while (*after != '\0' && !isspace((int)*after)) after++;
+        vallen= (after-valhead);
+        val= (char *)malloc(sizeof(char)*(vallen+1));
+        strncpy(val,valhead,vallen);
+        *(val+vallen)= '\0';
+        
+        /* now remove it from the str */
+        while (*after != '\0' && isspace((int)*after)) after++;
+        copylen= strafter-after+1; /* includes the terminating \0 */
+        memmove(head,after,copylen);
+        
+        return val;
+    }
+    return NULL;
+}
+
+int terminate_first_tok(char *str,char *sepchars,char **head,char *oldchar) {
+    char *p= str;
+    int len;
+    
+    do {
+        char *sep= strpbrk(p,sepchars);
+        if (sep == NULL) {
+            if (*p == '\0') return 0;
+            len= strlen(p);
+        } else {
+            len= sep- p;
+        }
+        if (len > 0) {
+            if (sep != NULL) {
+                *oldchar= *sep;
+                *sep= '\0';
+            } else {
+                *oldchar= '\0';
+            }
+            *head= p;
+        } else {
+            p++;
+        }
+    } while (len == 0);
+    
+    return len;
+}
+
+/*@}*/
+/* Id: strtok.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+dll_double.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdlib.h>
+
+/*! \file dll_double.c
+ * \brief 
+ *  dll_double.c contains routines for dll_double allocation, initing,
+ *  and recycling; dll_doubles are doubly linked list of doubles
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util Spade library utilities
+ * \brief this group contains general utility objects in libspade
+ * \ingroup libspade
+    @{
+*/
+
+/// free list of dll_doubles
+dll_double *free_dlink_list= NULL;
+
+/* creation and recycling routines for dll_double's */
+
+dll_double *new_dll_double(double val) {
+    dll_double *link;
+    if (free_dlink_list != NULL) {
+        link= free_dlink_list;
+        free_dlink_list= link->next;
+    } else {
+        link= (dll_double *)malloc(sizeof(dll_double));
+    }
+    link->val= val;
+    link->prev= NULL;
+    link->next= NULL;
+    return link;
+}
+
+void free_dll_double_list(dll_double *start) {
+    dll_double *end;
+    for (end= start; end->next != NULL; end=end->next);
+    end->next= free_dlink_list;
+    free_dlink_list= start;
+}
+
+/*@}*/
+/* Id: dll_double.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+ll_double.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+lease send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file ll_double.c
+ * \brief
+ *  contains routines for ll_double allocation, initing, and
+ *  recycling; ll_doubles are singly linked list of doubles
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util
+    @{
+*/
+
+#include <stdlib.h>
+
+/// free list of allocated ll_doubles
+ll_double *free_link_list=NULL;
+
+/* creation and recycling routines for ll_double's */
+
+ll_double *new_ll_double(double val) {
+    ll_double *link;
+    if (free_link_list != NULL) {
+        link= free_link_list;
+        free_link_list= link->next;
+    } else {
+        link= (ll_double *)malloc(sizeof(ll_double));
+    }
+    link->val= val;
+    link->next= NULL;
+    return link;
+}
+
+void free_ll_double_list(ll_double *start) {
+    ll_double *end,*next;
+    for (end= start, next=start->next; next != NULL; end=next,next=next->next);
+    end->next= free_link_list;
+    free_link_list= start;
+}
+
+/*@}*/
+
+/* Id: ll_double.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+spade_event.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdlib.h>
+
+/*! \file spade_event.c
+ * \brief 
+ *  spade_event.c contains routines for spade_event allocation, initing,
+ *  and recycling; spade_event reprents an event that Spade is processing
+ * \ingroup libspade_misc
+ */
+
+/*! \addtogroup libspade Spade library
+ * \brief This group contains the objects in libspade, which provides core
+ *  routines for Spade-like detection
+*/
+ 
+/*! \addtogroup libspade_misc Spade library misc
+ * \brief this group contains miscellaneous objects in libspade
+ * \ingroup libspade
+ * @{
+*/
+
+/// free list of allocated spade_events
+spade_event *spade_event_freelist=NULL;
+
+/* creation and recycling routines for spade_event's */
+
+spade_event *new_spade_event() {
+    spade_event *new;
+    if (spade_event_freelist != NULL) {
+        new= spade_event_freelist;
+        spade_event_freelist= (spade_event *)new->native;
+    } else {
+        new= (spade_event *)malloc(sizeof(spade_event));
+    }
+    new->native= NULL;
+    new->native_freer= NULL;
+    return new;
+}
+
+spade_event *spade_event_clone(spade_event *e,event_native_copier_t native_copier,event_native_freer_t native_freer) {
+    spade_event *clone= new_spade_event();
+    *clone= *e; /* copy data */
+    if (native_copier != NULL)
+        clone->native= (*native_copier)(e->native);
+    clone->native_freer= native_freer;
+    return clone;
+}
+
+void free_spade_event(spade_event *e) {
+    if (e->native_freer != NULL) (*(e->native_freer))(e->native);
+    e->native= (void *)spade_event_freelist;
+    spade_event_freelist= e;
+}
+
+/*@}*/
+
+/* Id: spade_event.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+/*********************************************************************
+event_recorder.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+event_recorder.c contains the "class" event_recorder which is manages a set
+  of spade_prob_tables to accomplish user specified goals.  This trys to 
+  avoid creating more tables that are needed for the set of goals.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/*! \file event_recorder.c
+ * \brief 
+ *  event_recorder.c contains the "class" event_recorder which is
+ *  manages a set of spade_prob_tables to accomplish user specified goals.
+ *  This trys to avoid creating more tables that are needed for the set of
+ *  goals.
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec Spade state recording
+ * \brief this group contains objects the maintain accumulated Spade
+ *  observation state
+ * \ingroup libspade
+    @{
+*/
+
+
+
+#include <stdlib.h>
+#include <string.h>
+
+static evfile *new_evfile(table_mgr *mgr,int feat_depth,feature_list *calc_feats);
+static table_mgr *new_table_mgr(feature_list *feats, const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold, time_t curtime);
+static int table_mgr_recover(statefile_ref *ref, table_mgr **mgr);
+static int table_mgr_checkpoint(table_mgr *mgr, statefile_ref *ref);
+static int table_mgr_is_compatable(table_mgr *mgr, feature_list *feats, const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold);
+static void table_mgr_new_time(table_mgr *mgr, time_t time);
+static void free_table_mgr(table_mgr *mgr);
+static void table_mgr_write_stats(table_mgr *mgr, FILE *file, u8 stats_to_print,condition_printer_t condprinter);
+static void table_mgr_print_config_details(table_mgr *mgr, FILE *f, char *indent);
+static void file_print_feature_list(feature_list *feats, FILE *f, const char **featurenames);
+
+#define feats_to_calc_with(evf) ( (evf->calc_feats.num > 0) ? (&(evf->calc_feats)) : (&(evf->mgr->feats)) )
+
+#define map_event_to_val_arr(featmap,size,event,val) { \
+    int featidx; \
+    for (featidx= 0; featidx < size; featidx++) { \
+        val[featidx]= event->fldval[featmap[featidx]]; \
+    } \
+}
+
+event_recorder *new_event_recorder() {
+    event_recorder *new= (event_recorder *)malloc(sizeof(event_recorder));
+    init_event_recorder(new);
+    return new;
+}
+
+void init_event_recorder(event_recorder *self) {
+    self->tables= NULL;
+    self->files= NULL;
+    self->curtime= (time_t)0;
+}
+
+int event_recorder_recover(event_recorder **self,statefile_ref *ref) {
+    *self= new_event_recorder();
+    if (*self == NULL) return 0;
+    return event_recorder_merge_recover(*self,ref);
+}
+
+int event_recorder_merge_recover(event_recorder *self,statefile_ref *ref) {
+    int i,count;
+    table_mgr *mgr;
+    if (!spade_state_recover_u32(ref,&count)) return 0;
+    for (i= 0; i < count; i++) {
+        if (!table_mgr_recover(ref,&mgr)) return 0;
+        /* add manager into list by prepending*/
+        mgr->next= self->tables;
+        self->tables= mgr;
+    }
+    return 1;
+}
+
+int event_recorder_checkpoint(event_recorder *self,statefile_ref *ref) {
+    table_mgr *mgr;
+    u32 count= 0;
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) count++;
+    
+    spade_state_checkpoint_u32(ref,count);
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+        if (!table_mgr_checkpoint(mgr,ref)) return 0;
+    }
+    return 1;
+}
+
+evfile_ref event_recorder_new_event_file(event_recorder *self,feature_list *feats,const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold,int fresh_only, feature_list *calc_feats) {
+    table_mgr *mgr=NULL;
+    evfile *eventfile;
+    
+    /**** find a compatable table manager, extending or creating if needed ****/
+    if (!fresh_only) {
+        for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+            if (table_mgr_is_compatable(mgr,feats,featurenames,conds,scale_freq,scale_factor,prune_threshold)) break;
+        }
+        if (mgr != NULL) {
+            /* reusing a table manager, but some tweaking may be required */
+            if (mgr->feats.num < feats->num) /* need to extend features */
+                mgr->feats= *feats; /* copy whole struct */
+            if (!mgr->use_count) {
+                mgr->scale_freq= scale_freq;
+                mgr->scale_factor= scale_factor;
+                mgr->prune_threshold= prune_threshold;
+            }
+        }
+    }
+    
+    if (mgr == NULL) {
+        /* NOTE: we could go through tables again looking for compatable shared leading features to save on a table and save double-recording of leading features, but that seeking code is a little hairy and it would require recording "skip" information when getting an event */
+        mgr= new_table_mgr(feats,featurenames,conds,scale_freq,scale_factor,prune_threshold,self->curtime);
+        if (mgr == NULL) return NULL;
+        /* add manager into list by prepending*/
+        mgr->next= self->tables;
+        self->tables= mgr;
+    }
+    mgr->use_count++;
+        
+    /**** find a compatable evfile, creating if needed ****/
+    for (eventfile= self->files; eventfile != NULL; eventfile=eventfile->next) {
+        if (eventfile->mgr != mgr) continue;
+        if (eventfile->feat_depth != feats->num)
+            continue;
+        if ((calc_feats == NULL) && eventfile->calc_feats.num > 0) continue;
+        if (calc_feats != NULL) {
+            int i;
+            if (eventfile->calc_feats.num == 0) /* calc_feats is off */
+                continue;
+            if (eventfile->feat_depth == calc_feats->num)
+                continue;
+            for (i= 0; i < eventfile->feat_depth; i++)
+                if (eventfile->calc_feats.feat[i] != calc_feats->feat[i]) break;
+            if (i < eventfile->feat_depth) continue;
+        }
+        break; // all matched
+    }
+    
+    if (eventfile == NULL) {
+        eventfile= new_evfile(mgr,feats->num,calc_feats);
+        if (eventfile == NULL) return NULL;
+        /* add eventfile into list by prepending*/
+        eventfile->next= self->files;
+        self->files= eventfile;
+    }
+    
+    return (evfile_ref)eventfile;
+}
+
+evfile_ref *event_recorder_new_event_files(event_recorder *self,int howmany,feature_list feats[],const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold,int fresh_only) {
+    int i;
+    evfile_ref *arr= (evfile_ref *)malloc(sizeof(evfile_ref)*howmany);
+    if (arr == NULL) return NULL;
+
+    for (i= 0; i < howmany; i++)
+        arr[i]= event_recorder_new_event_file(self,&feats[i],featurenames,conds,scale_freq,scale_factor,prune_threshold,fresh_only,NULL);
+
+    return arr;
+}
+
+void event_recorder_new_time(event_recorder *self, time_t time) {
+    table_mgr *mgr;
+    self->curtime= time;
+    /* check for scaling */
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+        if (mgr->use_count) table_mgr_new_time(mgr,time);
+    }
+}
+
+event_condition_set event_recorder_needed_conds(event_recorder *self) {
+    table_mgr *mgr;
+    event_condition_set needed_conds= 0;
+    /* record which conditions we require events for */
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next)
+        ADD_TO_CONDS(needed_conds,mgr->conds); /* NOTE: some information loss here, so might get passed unneeded events; can represent more precisely as a or-ed list of masks */
+    return needed_conds;
+}
+
+int event_recorder_new_event(event_recorder *self, spade_event *event, event_condition_set matching_conds) {
+    table_mgr *mgr;
+    int updates= 0;
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+        if (ALL_CONDS_MET(matching_conds,mgr->conds)) { /* all of mgr's conditions are met by event */
+            u32 val[MAX_NUM_FEATURES];
+            feature_list *l= &mgr->feats;
+            map_event_to_val_arr(l->feat,l->num,event,val);
+            increment_Njoint_count(&mgr->table,l->num,l->feat,val,0);
+            mgr->store_count++;
+            updates++;
+        }
+    }
+    return updates;
+}
+
+void event_recorder_prune_unused(event_recorder *self) {
+    table_mgr *mgr,*prev=NULL;
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+        if (!mgr->use_count) {
+            if (prev == NULL)
+                self->tables= mgr->next;
+            else 
+                prev->next= mgr->next;
+            free_table_mgr(mgr);
+        } else {
+            prev= mgr;
+        }
+    }
+}
+
+double event_recorder_get_prob(event_recorder *self,evfile_ref eventfile,spade_event *event,int one_more) {
+    u32 val[MAX_NUM_FEATURES];
+    feature_list *l=  &eventfile->mgr->feats;
+    /* calculate the joint probability to the depth indicated in the evfile */
+    map_event_to_val_arr(feats_to_calc_with(eventfile)->feat,eventfile->feat_depth,event,val);
+    return one_more ?
+        prob_Njoint_Ncond_plus_one(&eventfile->mgr->table,eventfile->feat_depth,l->feat,val,0) :
+        prob_Njoint_Ncond(&eventfile->mgr->table,eventfile->feat_depth,l->feat,val,0);
+}
+
+double event_recorder_get_condprob(event_recorder *self,evfile_ref eventfile,spade_event *event,int condcutoff,int one_more) {
+    u32 val[MAX_NUM_FEATURES];
+    feature_list *l= &eventfile->mgr->feats;
+    if (condcutoff < 0) condcutoff+= eventfile->feat_depth; /* condition cutoff specified from end */
+    /* calculate the joint probability to the depth indicated in the evfile and conditioned to the indicated level */
+    map_event_to_val_arr(feats_to_calc_with(eventfile)->feat,eventfile->feat_depth,event,val);
+    return one_more ?
+        prob_Njoint_Ncond_plus_one(&eventfile->mgr->table,eventfile->feat_depth,l->feat,val,condcutoff) :
+        prob_Njoint_Ncond(&eventfile->mgr->table,eventfile->feat_depth,l->feat,val,condcutoff);
+}
+
+double event_recorder_get_count(event_recorder *self,evfile_ref eventfile,spade_event *event,int featdepth) {
+    u32 val[MAX_NUM_FEATURES];
+    feature_list *l=  &eventfile->mgr->feats;
+    /* calculate the joint probability to the depth indicated in the evfile and conditioned to the indicated level */
+    map_event_to_val_arr(feats_to_calc_with(eventfile)->feat,featdepth,event,val);
+    return jointN_count(&eventfile->mgr->table,featdepth,l->feat,val);
+}
+
+double event_recorder_get_entropy(event_recorder *self,evfile_ref eventfile,spade_event *event,int entropy_prefix_len) {
+    u32 val[MAX_NUM_FEATURES];
+    feature_list *l=  &eventfile->mgr->feats;
+    map_event_to_val_arr(feats_to_calc_with(eventfile)->feat,entropy_prefix_len,event,val);
+    return spade_prob_table_entropy(&eventfile->mgr->table,entropy_prefix_len,l->feat,val);
+}
+
+int event_recorder_get_store_count(event_recorder *self, evfile_ref eventfile) {
+    return eventfile->mgr->store_count;
+}
+
+double event_recorder_get_obs_count(event_recorder *self, evfile_ref eventfile) {
+    return jointN_count(&eventfile->mgr->table,0,eventfile->mgr->feats.feat,NULL);
+}
+
+void event_recorder_write_stats(event_recorder *self,FILE *file,u8 stats_to_print,condition_printer_t condprinter) {
+    table_mgr *mgr;
+    for (mgr= self->tables; mgr != NULL; mgr=mgr->next) {
+        table_mgr_write_stats(mgr,file,stats_to_print,condprinter);
+    }
+}
+
+static evfile *new_evfile(table_mgr *mgr,int feat_depth,feature_list *calc_feats) {
+    evfile *new= (evfile *)malloc(sizeof(evfile));
+    if (new == NULL) return NULL;
+    new->mgr= mgr;
+    new->feat_depth= feat_depth;
+    if (calc_feats == NULL)
+        new->calc_feats.num= 0;
+    else
+        new->calc_feats= *calc_feats; /* copy struct over */
+    new->next= NULL;
+    return new;
+}
+
+static table_mgr *new_table_mgr(feature_list *feats,const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold,time_t curtime) {
+    int num_featurenames;
+    table_mgr *new= (table_mgr *)malloc(sizeof(table_mgr));
+    if (new == NULL) return NULL;
+    
+    init_spade_prob_table(&new->table,featurenames,0);
+    new->next= NULL;
+    new->last_scale= (time_t)0;
+    
+    new->feats= *feats; // make copy
+    for (num_featurenames= 0; featurenames[num_featurenames] != NULL; num_featurenames++);
+    new->featurenames= (const char **)malloc(sizeof(const char *)*(num_featurenames+1));
+    if (new->featurenames != NULL) {
+        int i;
+        for (i= 0; featurenames[i] != NULL; i++) {
+            new->featurenames[i]= strdup(featurenames[i]);
+        }
+        new->featurenames[i]= NULL;
+    }
+    
+    new->conds= conds;
+    new->start_time= curtime;
+    new->scale_freq= scale_freq;
+    new->scale_factor= scale_factor;
+    new->prune_threshold= prune_threshold;
+    new->use_count= 0;
+    new->store_count= 0;
+    return new;
+}
+
+static int table_mgr_recover(statefile_ref *ref,table_mgr **mgr) {
+    u8 count= 0;
+
+    feature_list feats;
+    const char **featurenames;
+    event_condition_set conds;
+    int scale_freq;
+    double scale_factor;
+    double prune_threshold;
+    time_t start_time;
+    
+    time_t last_scale;
+
+    if (!(spade_state_recover_u32(ref,(u32 *)&conds)
+        && spade_state_recover_u8(ref,(u8 *)&feats.num)
+        && spade_state_recover_arr(ref,(u8 **)&feats.feat,feats.num,1)
+        && spade_state_recover_u8(ref,(u8 *)&count)
+    )) return 0;
+    
+    featurenames= (const char **)malloc(sizeof(const char *)*(count+1));
+    if (featurenames == NULL) return 0;
+    if (!spade_state_recover_str_arr(ref,(char **)featurenames,count)) return 0;
+    featurenames[count]= NULL;
+    
+    if (!(spade_state_recover_u32(ref,(u32 *)&scale_freq)
+        && spade_state_recover_double(ref,&scale_factor)
+        && spade_state_recover_double(ref,&prune_threshold)
+        && spade_state_recover_time_t(ref,&start_time)
+    )) return 0;
+
+    *mgr= new_table_mgr(&feats,featurenames,conds,scale_freq,scale_factor,prune_threshold,start_time);
+
+    if (!spade_state_recover_time_t(ref,&last_scale)) return 0;
+    /* we choose not to record the recovered last_scale; it would cause repeated immediate scaling to make up for lost time; not want we want most of the time */
+
+    return spade_prob_table_recover(ref,&(*mgr)->table); /* does not effect featurenames of the table */
+}
+
+static int table_mgr_checkpoint(table_mgr *mgr,statefile_ref *ref) {
+    u8 count= 0;
+    for (count= 0; mgr->featurenames[count] != NULL; count++);
+    
+    return spade_state_checkpoint_u32(ref,(u32)mgr->conds)
+        && spade_state_checkpoint_u8(ref,(u8)mgr->feats.num)
+        && spade_state_checkpoint_arr(ref,(u8 *)mgr->feats.feat,mgr->feats.num,1)
+        && spade_state_checkpoint_u8(ref,(u8)count)
+        && spade_state_checkpoint_str_arr(ref,(char **)mgr->featurenames,count)
+    
+        && spade_state_checkpoint_u32(ref,(u32)mgr->scale_freq)
+        && spade_state_checkpoint_double(ref,mgr->scale_factor)
+        && spade_state_checkpoint_double(ref,mgr->prune_threshold)
+        && spade_state_checkpoint_time_t(ref,mgr->start_time)
+        && spade_state_checkpoint_time_t(ref,mgr->last_scale)    
+
+        && spade_prob_table_checkpoint(ref,&mgr->table);
+}
+
+static int table_mgr_is_compatable(table_mgr *mgr,feature_list *feats,const char **featurenames,event_condition_set conds,int scale_freq,double scale_factor,double prune_threshold) {
+    int i,cmp_featlen;
+
+    if (mgr->conds != conds) return 0;
+    
+    if (mgr->use_count) { /* we'll waive these checks if an orphan */
+        //if (mgr->start_time != self->curtime) return 0;
+        if (mgr->scale_freq != scale_freq) return 0;
+        if (mgr->scale_factor != scale_factor) return 0;
+        if (mgr->prune_threshold != prune_threshold) return 0;
+    }
+    
+    for (i= 0; featurenames[i] != NULL; i++)
+        if (strcmp(mgr->featurenames[i],featurenames[i])) return 0;
+
+    if (mgr->feats.num < feats->num) {
+        if (!spade_prob_table_is_empty(&mgr->table)) return 0; /* can only extend if empty */
+        cmp_featlen= mgr->feats.num;
+    } else {
+        cmp_featlen= feats->num;
+    }
+    for (i= 0; i < cmp_featlen; i++)
+        if (mgr->feats.feat[i] != feats->feat[i]) return 0;
+
+    return 1; /* found a compatable table manager */
+}
+
+static void table_mgr_new_time(table_mgr *mgr,time_t time) {
+    if (mgr->scale_freq > 0) {
+        while (time - mgr->last_scale > mgr->scale_freq) {
+            if (mgr->last_scale == (time_t)0) { /* never have scaled before */
+                mgr->last_scale= time;
+            } else {
+                //if (self->debug_level > 1) printf("scaling by %f at time %d; discarding at %f\n",mgr->scale_factor,(int)time,mgr->prune_threshold);
+                scale_and_prune_table(&mgr->table,mgr->scale_factor,mgr->prune_threshold);
+                mgr->last_scale+= mgr->scale_freq;  /* lets pretend we did this right on time */
+                //if (self->debug_level > 1) printf("done with scale/prune\n");
+            }
+        }
+    }
+}
+
+static void free_table_mgr(table_mgr *mgr) {
+    int i;
+    /* need to reset mgr->table */
+    for (i= 0; mgr->featurenames[i] != NULL; i++) {
+        free((char *)mgr->featurenames[i]);
+    }
+    free((char *)mgr->featurenames);
+    free(mgr);
+}
+
+static void table_mgr_write_stats(table_mgr *mgr,FILE *file,u8 stats_to_print,condition_printer_t condprinter) {
+    fprintf(file,"** table for ");
+    if (condprinter != NULL)
+        (*condprinter)(file,mgr->conds);
+    else
+        fprintf(file," %x",mgr->conds);
+    fprintf(file," **\n");
+    fprintf(file,"Recorded is: P(");
+    file_print_feature_list(&mgr->feats,file,mgr->featurenames);
+    fprintf(file,")\n");
+    fprintf(file,"Scaling freqency: %d; Scaling factor: %.5f; Pruning Threshold=%.5f\n",mgr->scale_freq,mgr->scale_factor,mgr->prune_threshold);
+    fprintf(file,"Start time: %d; Last time scaled: %d\n",(int)mgr->start_time,(int)mgr->last_scale);
+    spade_prob_table_write_stats(&mgr->table,file,stats_to_print);
+    fprintf(file,"\n");
+}
+
+void evfile_print_config_details(evfile_ref eventfile,FILE *f,char *indent) {
+    char indent2[100];
+    sprintf(indent2,"%s  ",indent);
+    fprintf(f,"%smgr=\n",indent);
+    table_mgr_print_config_details(eventfile->mgr,f,indent2);
+    fprintf(f,"%sfeat_depth=%d\n",indent,eventfile->feat_depth);
+    if (eventfile->calc_feats.num > 0) {
+        fprintf(f,"%scalc_feats=",indent);
+        file_print_feature_list(&eventfile->calc_feats,f,eventfile->mgr->featurenames);
+        fprintf(f,"\n");
+    }
+}
+
+static void table_mgr_print_config_details(table_mgr *mgr,FILE *f,char *indent) {
+    fprintf(f,"%sfeats=",indent);
+    file_print_feature_list(&mgr->feats,f,mgr->featurenames);
+    fprintf(f,"\n%sconds=%x\n",indent,mgr->conds);
+    fprintf(f,"%sscale_freq=%d; scale_factor=%.5f; prune_threshold=%.5f\n",indent,mgr->scale_freq,mgr->scale_factor,mgr->prune_threshold);
+}
+
+static void file_print_feature_list(feature_list* feats,FILE *f,const char **featurenames) {
+    int i;
+    for (i= 0; i < feats->num; i++) {
+        if (i != 0) fprintf(f,",");
+        fprintf(f,"%s",featurenames[feats->feat[i]]);
+    }
+}
+/* Id: event_recorder.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+score_info.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdlib.h>
+
+/*! \file score_info.c
+ * \brief 
+ *  score_info.c contains routines for score_info allocation, initing,
+ *  and recycling and access; score_info reprents computed anomaly
+ *  score(s)
+ * \ingroup scoreprod
+ */
+
+/*! \addtogroup scoreprod
+    @{
+*/
+
+
+/// free list of allocated score_infos
+score_info *score_info_freelist=NULL;
+
+/* creation and recycling routines for score_info's */
+
+score_info *new_score_info(scorepref main,double relscore,double rawscore,int corrscore_used) {
+    score_info *new;
+    if (score_info_freelist != NULL) {
+        new= score_info_freelist;
+        score_info_freelist= new->next;
+    } else {
+        new= (score_info *)malloc(sizeof(score_info));
+    }
+    init_score_info(new,main,relscore,rawscore,corrscore_used);
+    return new;
+}
+
+void init_score_info(score_info *i,scorepref main,double relscore,double rawscore,int corrscore_used) {
+    i->main= main;
+    i->relscore= relscore;
+    i->rawscore= rawscore;
+    i->corrscore_used= corrscore_used;
+}
+
+score_info *score_info_clone(score_info *i) {
+    return new_score_info(i->main,i->relscore,i->rawscore,i->corrscore_used);
+}
+
+void free_score_info(score_info *i) {
+    i->next= score_info_freelist;
+    score_info_freelist= i;
+}
+
+void free_score_infos(score_info *start) {
+    score_info *end,*next;
+    for (end= start, next=start->next; next != NULL; end=next,next=next->next);
+    end->next= score_info_freelist;
+    score_info_freelist= start;
+}
+
+double score_info_mainscore(score_info *i) {
+    return i->main == PREF_RAWSCORE ? i->rawscore : i->relscore;
+}
+
+double score_info_relscore(score_info *i) {
+    return i->relscore;
+}
+
+double score_info_rawscore(score_info *i) {
+    return i->rawscore;
+}
+
+int score_info_raw_is_corrscore(score_info *i) {
+    return i->corrscore_used;
+}
+
+scorepref score_info_main_pref(score_info *i) {
+    return i->main;
+}
+
+
+const char *scorepref_str(scorepref pref) {
+    switch (pref) {
+    case PREF_NOSCORE: return "NOSCORE";
+    case PREF_RAWSCORE: return "RAWSCORE";
+    case PREF_RELSCORE: return "RELSCORE";
+    default: return "undefined";
+    }
+}
+
+/*@}*/
+/* Id: score_info.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+/*********************************************************************
+spade_enviro.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdlib.h>
+
+/*! \file spade_enviro.c
+ * \brief 
+ *  spade_enviro.c contains routines for spade_enviro allocation,
+ *  and initing
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+spade_enviro *new_spade_enviro(double thresh,unsigned long *total_pkts_ptr) {
+    spade_enviro *new= (spade_enviro *)malloc(sizeof(spade_enviro));
+    if (new == NULL) return NULL;
+    init_spade_enviro(new,thresh,total_pkts_ptr);
+    return new;
+}
+
+void init_spade_enviro(spade_enviro *self,double thresh,unsigned long *total_pkts_ptr) {
+    self->now= (time_t)0;
+    self->thresh= thresh;
+    self->total_pkts= total_pkts_ptr;
+    self->pkt_stats.scored= 0;
+    self->pkt_stats.respchecked= 0;
+    self->pkt_stats.excluded= 0;
+    self->pkt_stats.nonexcluded= 0;
+    self->pkt_stats.reported= 0;
+    self->pkt_stats.waited= 0;
+    self->pkt_stats.insuffobsed= 0;
+}
+
+/*@}*/
+/* Id: spade_enviro.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+/*********************************************************************
+spade_output.c, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#include <stdarg.h>
+#include <stdio.h>
+
+/*! \file spade_output.c
+ * \brief 
+ *  spade_output.c contains the definition of default_spade_msg_fn
+ * \ingroup libspade_misc
+ */
+
+/*! \addtogroup libspade_misc
+    @{
+*/
+
+void default_spade_msg_fn(spade_message_type msg_type,const char *str) {
+    switch (msg_type) {
+    case SPADE_MSG_TYPE_FATAL:
+        fprintf(stderr, "%s", str);
+        exit(1);
+    case SPADE_MSG_TYPE_WARNING:
+        fprintf(stderr, "%s", str);
+        break;
+    default:
+        printf("%s", str);
+        break;
+    }
+}
+
+void formatted_spade_msg_send(spade_message_type msg_type,spade_msg_fn msg_fn,const char *format,...) {
+    char buf[MAX_SPADE_MSG_LEN+1];
+    va_list ap;
+    va_start(ap, format);
+    
+    vsnprintf(buf, MAX_SPADE_MSG_LEN, format, ap);
+    (*msg_fn)(msg_type,buf);
+    va_end(ap);
+}
+
+/*@}*/
+
+/* Id: spade_output.c,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
diff -rNu snort-2.7.0/src/preprocessors/spp_spade.h snort-2.7.0.mod/src/preprocessors/spp_spade.h
--- snort-2.7.0/src/preprocessors/spp_spade.h	1970-01-01 01:00:00.000000000 +0100
+++ snort-2.7.0.mod/src/preprocessors/spp_spade.h	2007-09-06 20:15:11.000000000 +0200
@@ -0,0 +1,2055 @@
+/*********************************************************************
+snort_spade.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: snort_spade.h,v 1.2 2005/09/02 18:31:18 jebrahimi Exp $ */
+
+#ifndef __SNORT_SPADE_H__
+#define __SNORT_SPADE_H__
+
+/*! \file snort_spade.h
+ * \brief 
+ *  snort_spade.h is the header file for snort_spade.c
+ */
+
+/*! \addtogroup snort_spade
+ * @{
+*/
+
+void SetupSpade();
+void SpadeInit(u_char *argsstr);
+void PreprocSpade(Packet *p, void *);
+void SpadeHomenetInit(u_char *args);
+void SpadeDetectInit(u_char *args);
+void SpadeStatInit(u_char *args);
+void SpadeThreshadviseInit(u_char *args);
+void SpadeAdaptInit(u_char *args);
+void SpadeAdapt2Init(u_char *args);
+void SpadeAdapt3Init(u_char *args);
+void SpadeSurveyInit(u_char *args);
+void SpadeCatchSig(int signal, void *arg);
+
+#endif // __SNORT_SPADE_H__
+/*********************************************************************
+netspade.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: netspade.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+/*! \file netspade.h
+ * \brief 
+ *  netspade.h is the header file for the netspade "class"
+ * \ingroup netspade_layer
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+#ifndef NETSPADE_H
+#define NETSPADE_H
+
+/*********************************************************************
+netspade_features.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+netspade_features.h is contains the features definitions for netspade
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: netspade_features.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef NETSPADE_FEATURES_H
+#define NETSPADE_FEATURES_H
+
+/*********************************************************************
+spade_features.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: spade_features.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SPADE_FEATURES_H
+#define SPADE_FEATURES_H
+
+/*! \file spade_features.h
+ * \brief 
+ *  spade_features.h is a set of type declarations around a spade feature
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+#include <limits.h>
+
+#define MAX_U32 0xFFFFFFFF ///< the largest number that can be represented in a u32
+#define MAX_U16 0xFFFF     ///< the largest number that can be represented in a u16
+#define MAX_U8  0xFF       ///< the largest number that can be represented in a u8
+
+/* search to find a type to be u32 */
+// u32 is a unsigned (exactly) 32 bit integer
+#if USHRT_MAX == MAX_U32
+typedef unsigned short u32;
+#elif UINT_MAX == MAX_U32
+typedef unsigned int u32;
+#elif ULONG_MAX == MAX_U32
+typedef unsigned long u32;
+#else
+#error could not find a 4 byte int to be u32 in types.h
+#endif
+
+/* search to find a type to be u16 */
+// u16 is a unsigned (exactly) 16 bit integer
+#if USHRT_MAX == MAX_U16
+typedef unsigned short u16;
+#elif UINT_MAX == MAX_U16
+typedef unsigned int u16;
+#elif ULONG_MAX == MAX_U16
+typedef unsigned long u16;
+#else
+#error could not find a 2 byte int to be u16 in types.h
+#endif
+
+/* search to find a type to be u8 */
+/* u8 is a unsigned (exactly) 8 bit integer */
+#if UCHAR_MAX == MAX_U8
+typedef unsigned char u8;
+#elif USHRT_MAX == MAX_U8
+typedef unsigned short u8;
+#elif UINT_MAX == MAX_U8
+typedef unsigned int u8;
+#else
+#error could not find a 1 byte int to be u8 in types.h
+#endif
+
+
+/// the maximum number of features libspade can handle
+#define MAX_NUM_FEATURES 8
+
+typedef u8 features; ///< type of the index represting the features we are storing the prob table about
+
+/// this represents a sorted list of up to MAX_NUM_FEATURES features
+typedef struct {
+    u8 num;  ///< how many featrues are in the list
+    features feat[MAX_NUM_FEATURES]; ///< 0-based array storing the features
+} feature_list;
+
+#endif // SPADE_FEATURES_H
+
+
+/*! \file netspade_features.h
+ * \ingroup netspade_layer
+ * \brief 
+ *  netspade_features.h is contains the features definitions for netspade
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+
+#define SIP             0 ///< the source IP netspade feature
+#define DIP             1 ///< the dest IP netspade feature
+#define SPORT           2 ///< the source port netspade feature
+#define DPORT           3 ///< the dest port netspade feature
+#define IPPROTO         4 ///< the IP protocol netspade feature
+#define TCPFLAGS        5 ///< the TCP flags netspade feature
+#define ICMPTYPE        6 ///< the ICMP type netspade feature
+#define ICMPTYPECODE    7 ///< the ICMP type&code netspade feature
+
+/// \brief the number of netspade features defined
+/// \note must be no more than MAX_NUM_FEATURES in spade_features.h
+//#define NETSPADE_NUM_FEATURES 6
+#define NETSPADE_NUM_FEATURES 8
+extern const char *featurenames[NETSPADE_NUM_FEATURES+1];
+
+/// used for the IPPROTO file when we don't know the IP protocol
+#define IPPROTO_UNKNOWN (u32)-1;
+
+/// the value for the "origin" field in spade_event when the header was at the top level of the packet
+#define PKTORIG_TOP     1
+/// the value for the "origin" field in spade_event when the header was enclosed in an unreachable packet
+#define PKTORIG_UNRCH   2
+
+/*@}*/
+
+#endif // NETSPADE_FEATURES_H
+
+/*********************************************************************
+spade_detection_types.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef SPADE_DETECTION_TYPES_H
+#define SPADE_DETECTION_TYPES_H
+
+
+/*! \file spade_detection_types.h
+ * \ingroup netspade_layer
+ * \brief 
+ *  spade_detection_types.h contains constants, strings, and conversion macros
+ *  for spade detection types and detector types
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+
+/* detector types (each spade detector is of a certain type) */
+#define SPADE_DR_TYPE_UNKNOWN       0
+#define SPADE_DR_TYPE_CLOSED_DPORT  1
+#define SPADE_DR_TYPE_DEAD_DEST     2
+#define SPADE_DR_TYPE_ODD_DPORT     3
+#define SPADE_DR_TYPE_ODD_TYPECODE  4
+#define SPADE_DR_TYPE_ODD_PORTDEST  5
+
+/// map a detector type plus an relative detector number to the corresponding detector number
+#define SPADE_DN_TYPE_FOR_DR_TYPE(num,index) ((num << 8) + index)
+
+/// map detector type number to a short strings representing it
+#define SPADE_DR_TYPE_SHORT4NUM(num) \
+    ((num == SPADE_DR_TYPE_CLOSED_DPORT) ? "closed-dport" \
+    :(num == SPADE_DR_TYPE_DEAD_DEST) ? "dead-dest" \
+    :(num == SPADE_DR_TYPE_ODD_DPORT) ? "odd-dport" \
+    :(num == SPADE_DR_TYPE_ODD_TYPECODE) ? "odd-typecode" \
+    :(num == SPADE_DR_TYPE_ODD_PORTDEST) ? "odd-port-dest" \
+    :"?" \
+    )
+
+/// map short strings representing a detector type to its number
+#define SPADE_DR_TYPE_NUM4SHORT(str) \
+    ((!strcmp(str,"closed-dport")) ? SPADE_DR_TYPE_CLOSED_DPORT \
+    :(!strcmp(str,"dead-dest")) ? SPADE_DR_TYPE_DEAD_DEST \
+    :(!strcmp(str,"odd-dport")) ? SPADE_DR_TYPE_ODD_DPORT \
+    :(!strcmp(str,"odd-typecode")) ? SPADE_DR_TYPE_ODD_TYPECODE \
+    :(!strcmp(str,"odd-port-dest")) ? SPADE_DR_TYPE_ODD_PORTDEST \
+    :SPADE_DR_TYPE_UNKNOWN \
+    )
+
+
+/* detection types (a detector type can have multiple detection types) */
+#define SPADE_DN_TYPE_UNKNOWN       0
+#define SPADE_DN_TYPE_CLOSED_DPORT  ((SPADE_DR_TYPE_CLOSED_DPORT << 8) +0)
+#define SPADE_DN_TYPE_ODD_OPEN_DPORT  ((SPADE_DR_TYPE_CLOSED_DPORT << 8) +1)
+#define SPADE_DN_TYPE_ODD_DPORT  ((SPADE_DR_TYPE_CLOSED_DPORT << 8) +2)
+#define SPADE_DN_TYPE_NONLIVE_DEST  ((SPADE_DR_TYPE_DEAD_DEST << 8) +0)
+#define SPADE_DN_TYPE_SRC_ODD_DPORT ((SPADE_DR_TYPE_ODD_DPORT << 8) +0)
+#define SPADE_DN_TYPE_ODD_TYPECODE  ((SPADE_DR_TYPE_ODD_TYPECODE << 8) +0)
+#define SPADE_DN_TYPE_ODD_PORTDEST_LOWH  ((SPADE_DR_TYPE_ODD_PORTDEST << 8) +0)
+//#define SPADE_DN_TYPE_ODD_PORTDEST_HIGHH  ((SPADE_DR_TYPE_ODD_PORTDEST << 8) +1)
+
+/// map a detector type number to the detection type number
+#define SPADE_DR_TYPE_FOR_DN_TYPE(num) (num >> 8)
+
+/// obtain the default detection type number for a detector type number
+#define DEFAULT_DN_TYPE_FOR_DR_TYPE(num) SPADE_DN_TYPE_FOR_DR_TYPE(num,0)
+
+/// map detction type to very brief strings denoting the detection type
+#define SPADE_DN_TYPE_BRIEF4NUM(num) \
+    ((num == SPADE_DN_TYPE_CLOSED_DPORT) ? "CD" \
+    :(num == SPADE_DN_TYPE_ODD_OPEN_DPORT) ? "ROD" \
+    :(num == SPADE_DN_TYPE_ODD_DPORT) ? "RD" \
+    :(num == SPADE_DN_TYPE_NONLIVE_DEST) ? "DD" \
+    :(num == SPADE_DN_TYPE_SRC_ODD_DPORT) ? "OD" \
+    :(num == SPADE_DN_TYPE_ODD_TYPECODE) ? "OT" \
+    :(num == SPADE_DN_TYPE_ODD_PORTDEST_LOWH) ? "PD" \
+    :"?" \
+    )
+
+/// map detction type very brief strings to the detection type number
+#define SPADE_DN_TYPE_NUM4BRIEF(str) \
+    ((!strcmp(str,"CD")) ? SPADE_DN_TYPE_CLOSED_DPORT \
+    ((!strcmp(str,"ROD")) ? SPADE_DN_TYPE_ODD_OPEN_DPORT \
+    ((!strcmp(str,"RD")) ? SPADE_DN_TYPE_ODD_DPORT \
+    :(!strcmp(str,"DD")) ? SPADE_DN_TYPE_NONLIVE_DEST \
+    :(!strcmp(str,"OD")) ? SPADE_DN_TYPE_SRC_ODD_DPORT \
+    :(!strcmp(str,"OT")) ? SPADE_DN_TYPE_ODD_TYPECODE \
+    :(!strcmp(str,"PD")) ? SPADE_DN_TYPE_ODD_PORTDEST_LOWH \
+    :SPADE_DN_TYPE_UNKNOWN \
+    )
+
+/// map detction type to medium-length strings describing the detection done
+#define SPADE_DN_TYPE_MEDDESCR4NUM(num) \
+    ((num == SPADE_DN_TYPE_CLOSED_DPORT) ? "Closed dest port used" \
+    :(num == SPADE_DN_TYPE_ODD_OPEN_DPORT) ? "Rare but open dest port used" \
+    :(num == SPADE_DN_TYPE_ODD_DPORT) ? "Rare dest port used" \
+    :(num == SPADE_DN_TYPE_NONLIVE_DEST) ? "Non-live dest used" \
+    :(num == SPADE_DN_TYPE_SRC_ODD_DPORT) ? "Source used odd dest port" \
+    :(num == SPADE_DN_TYPE_ODD_TYPECODE) ? "Odd ICMP type/code found" \
+    :(num == SPADE_DN_TYPE_ODD_PORTDEST_LOWH) ? "Source used odd dest for port" \
+    :"?" \
+    )
+
+/// map the medium-length strings describing the detection done to the detection type number
+#define SPADE_DN_TYPE_NUM4MEDDESCR(str) \
+    ((!strcmp(str,"Closed dest port used")) ? SPADE_DN_TYPE_CLOSED_DPORT \
+    :(!strcmp(str,"Rare but open dest port used")) ? SPADE_DN_TYPE_ODD_OPEN_DPORT \
+    :(!strcmp(str,"Rare dest port used")) ? SPADE_DN_TYPE_ODD_DPORT \
+    :(!strcmp(str,"Non-live dest used")) ? SPADE_DN_TYPE_NONLIVE_DEST \
+    :(!strcmp(str,"Source used odd dest port")) ? SPADE_DN_TYPE_SRC_ODD_DPORT \
+    :(!strcmp(str,"Odd ICMP type/code found")) ? SPADE_DN_TYPE_ODD_TYPECODE \
+    :(!strcmp(str,"Source used odd dest for port")) ? SPADE_DN_TYPE_ODD_PORTDEST_LOWH \
+    :SPADE_DN_TYPE_UNKNOWN \
+    )
+    
+/*@}*/
+
+/* Id: spade_detection_types.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#endif // SPADE_DETECTION_TYPES_H
+
+/*********************************************************************
+score_mgr.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: score_mgr.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SCORE_MGR_H
+#define SCORE_MGR_H
+
+/*! \file score_mgr.h
+ * \brief 
+ *  score_mgr.h is the header file for score_mgr.c
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+#include <stdio.h>
+
+/*********************************************************************
+thresh_adviser.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: thresh_adviser.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef THRESH_ADVISER_H
+#define THRESH_ADVISER_H
+
+/*! \file thresh_adviser.h
+ * \brief 
+ *  thresh_adviser.h is the header file for thresh_adviser.c
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+#include <stdio.h>
+/*********************************************************************
+spade_enviro.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: spade_enviro.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SPADE_ENVIRO_H
+#define SPADE_ENVIRO_H
+
+/*! \file spade_enviro.h
+ * \brief 
+ *  spade_enviro.h contains the type declaration for the spade_enviro
+ *  struct
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+
+#include <time.h>
+
+/// various counts of the disposition of events; yes, this should be in netspade, not libspade because it violates abstractions
+typedef struct {
+    int scored;      ///< count of all packets scored 
+    int respchecked; ///< count of all packets checked as a response
+    int reported;    ///< count of all packets reported
+    int excluded;    ///< count of all packets not reported due to configured exclusion
+    int nonexcluded; ///< count of all packets that were anomalous but not excluded
+    int waited;      ///< count of all packets added to the wait queue
+    int insuffobsed; ///< count of packets with insufficient obsercations
+} spade_pkt_stats;
+
+
+/// shared state between libspade and its user
+typedef struct {
+    time_t now; ///< the time of the last packet added
+
+    /// the threshold at which anomolous events are reported
+    double thresh;
+    
+    unsigned long *total_pkts; ///< pointer to read-only count of all packets seen
+    spade_pkt_stats pkt_stats; ///< packet disposition counts
+} spade_enviro;
+
+spade_enviro *new_spade_enviro(double thresh,unsigned long *total_pkts_ptr);
+void init_spade_enviro(spade_enviro *self,double thresh,unsigned long *total_pkts_ptr);
+
+/*@}*/
+#endif // SPADE_ENVIRO_H
+
+/*********************************************************************
+ll_double.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef LL_DOUBLE_H
+#define LL_DOUBLE_H
+
+/*! \file ll_double.h
+ * \brief
+ *  ll_double.h is the header file for ll_double.c
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util
+    @{
+*/
+
+/// a link in a singly linked list of doubles
+typedef struct _ll_double {
+    double val; ///< the value
+    struct _ll_double *next; ///< the next in the list
+} ll_double;
+
+ll_double *new_ll_double(double val);
+void free_ll_double_list(ll_double *start);
+
+/*@}*/
+#endif  /* ! LL_DOUBLE_H */
+
+/* Id: ll_double.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+/*********************************************************************
+spade_output.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: spade_output.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SPADE_OUTPUT_H
+#define SPADE_OUTPUT_H
+
+/*! \file spade_output.h
+ * \brief 
+ *  spade_output.h contains some declarations regarding Spade
+ *  message output
+ * \ingroup libspade_misc
+ */
+
+/** \addtogroup libspade_misc
+    @{
+*/
+
+#include <stdarg.h>
+
+/// the max length of a message from Spade
+#define MAX_SPADE_MSG_LEN 1000
+
+/// enum listing the different messages types from Spade to the user
+typedef enum {
+    SPADE_MSG_TYPE_STATUS,  ///< message is providing routine status information, e.g., from starting up
+    SPADE_MSG_TYPE_INFO,    ///< the message is merely informational
+    SPADE_MSG_TYPE_DEBUG,   ///< it is a debugging message
+    SPADE_MSG_TYPE_WARNING, ///< the message is a warning
+    SPADE_MSG_TYPE_FATAL    ///< fatal error
+} spade_message_type;
+
+/// function type for a spade message callback function
+typedef void (*spade_msg_fn)(spade_message_type msg_type,const char *str);
+
+void default_spade_msg_fn(spade_message_type msg_type,const char *str);
+
+void formatted_spade_msg_send(spade_message_type msg_type,spade_msg_fn msg_fn,const char *format,...);
+
+/*@}*/
+
+#endif // SPADE_OUTPUT_H
+
+
+/// representation of a threshold adviser
+typedef struct {
+    int obs_size;  ///< the number of anomalous packets desired
+    time_t obs_secs; ///< how long to observe for
+    /// head of a linked list of the highest anomaly scores we've seen
+    /** this list can be up to tl_obs_size+1 long and is ordered by increasing score; the list is initialized to 0 -> 0 in case we never see enough packets */
+    ll_double *top_anom_list; 
+    int top_anom_list_size; ///< the number of scores on the list (0-based)
+    time_t obs_start_time; ///< the start time of the observation, set after the first packet we see
+} thresh_adviser;
+
+
+void init_thresh_adviser(thresh_adviser *self, int obs_size, int obs_secs, spade_msg_fn msg_callback);
+void init_thresh_adviser_from_str(thresh_adviser *self, char *str, spade_msg_fn msg_callback);
+thresh_adviser *new_thresh_adviser(int obs_size, int obs_secs, spade_msg_fn msg_callback);
+void thresh_adviser_reset(thresh_adviser *self, int obs_size, int obs_secs, spade_msg_fn msg_callback);
+void thresh_adviser_start_time(thresh_adviser *self, time_t time);
+int thresh_adviser_new_time(thresh_adviser *self, spade_enviro *enviro);
+void thresh_adviser_new_score(thresh_adviser *self, double anom_score);
+void thresh_adviser_write_advice(thresh_adviser *self, FILE *file);
+
+void thresh_adviser_print_config_details(thresh_adviser *self, FILE *f, char *indent);
+
+/*@}*/
+#endif // THRESH_ADVISER_H
+
+/*********************************************************************
+thresh_adapter.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+thresh_adapter.h is the header file for thresh_adapter.c
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: thresh_adapter.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef THRESH_ADAPTER_H
+#define THRESH_ADAPTER_H
+
+/*! \file thresh_adapter.h
+ * \brief 
+ *  thresh_adapter.h is the header file for thresh_adapter.c
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+/*********************************************************************
+dll_double.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef DLL_DOUBLE_H
+#define DLL_DOUBLE_H
+
+/*! \file dll_double.h
+ * \brief 
+ *  dll_double.h is the header file for dll_double.c.
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util
+    @{
+*/
+
+/// a link in a doubly linked list of doubles
+typedef struct _dll_double {
+    double val; ///< the value
+    struct _dll_double *prev; ///< the previous item on the linked list
+    struct _dll_double *next; ///< the next item on the linked list
+} dll_double;
+
+dll_double *new_dll_double(double val);
+void free_dll_double_list(dll_double *start);
+
+
+#endif  /* ! DLL_DOUBLE_H */
+
+
+/* Id: dll_double.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+ 
+ 
+ 
+
+#include <stdio.h>
+#include <time.h>
+
+/// structure to hold the data for adapt mode #1
+typedef struct {
+    /// the number of alerts that is ideal for the given length of time
+    int target;
+    /// the length of time in which to ideally produce the given number of alerts; also the interval at which to adjust the report threshold
+    time_t period;
+    /// the weight to give to the new observation ideal cutoff in determining the new weight
+    float new_obs_weight;
+    /// adapt by count or by time only
+    int by_count;
+    
+    /// the head of the list of anomaly scores.
+    ll_double *top_list;
+    /// the current size of this list (0-based)
+    int top_list_size;
+} adapt1_data;
+
+/// structure to hold the data for adapt mode #2
+typedef struct {
+    /// the specification of the target
+    double targetspec;
+    /// the observation period
+    double obsper;
+    /// the number of short periods in a medium period
+    int NS;
+    /// the number of medium periods in a long period
+    int NM;
+    /// the number of long periods to average over
+    int NL;
+    
+    /// the current target based on targetspec
+    int target;
+    /// latest medium term component
+    double mid_anom_comp;
+    /// latest long term component
+    double long_anom_comp;
+    /// an array of heads of observation linked lists
+    dll_double **obslists_head;
+    /// an array of tails of the observation linked lists
+    dll_double **obslists_tail;
+    /// an array of the (0-based) size of these lists
+    int *obslists_size;
+    /// the number of complete observation periods
+    int obsper_count;
+    /// arrays of short and medium term components used for calculating other components
+    double *recScomps,*recMcomps;
+
+    /// the start time of the current observation period
+    time_t obsper_start;
+    /// which obslist to add to, aka, obsper_count % NS
+    int obslist_new_slot;
+
+    // the count of period 2 instances
+    int per2_count;
+    // the count of period 3 instances
+    int per3_count; 
+} adapt2_data;
+
+/// structure to hold the data for adapt mode #3
+typedef struct {
+    /// the specification of the target
+    double targetspec;
+    /// the observation period
+    double obsper;
+    /// the number of observation period results to average together
+    int NO;
+    
+    /// the current target based on targetspec
+    int target;
+    /// array of past observations
+    double *hist;
+    /// a linked list of anomaly scores from the current period
+    ll_double *anoms;
+    /// (0-based) size of this list
+    int anoms_size;
+    /// number of completed observation periods
+    int completed_obs_per;
+    
+    double obssum; ///< the sum of all current elements in the array
+} adapt3_data;
+ 
+/// structure to hold the data for adapt mode #4
+typedef struct {
+    double thresh; ///< the threshold to change to
+} adapt4_data;
+
+/// the representation of a threshold adapter
+typedef struct {
+    /// the adapt mode number
+    int adapt_mode;
+    /// the adapt-type specific storage; the union is selected by adapt_mode
+    union {
+        adapt1_data a1;
+        adapt2_data a2;
+        adapt3_data a3;
+        adapt4_data a4;
+    } d;
+    
+    /// adapt by count or by time only
+    int adapt_by_count;
+    
+    /// the total count of packets at the start of the observation period
+    int last_total_stats;
+    /// how often (in secs) to recalc packet rate and to trigger adapting
+    time_t adapt_period; 
+    /// how many packet periods have occurred
+    int pkt_period_count;
+    /// the time this period started
+    time_t period_start;
+    /// the rate of all packets in the adapt period; used to decide when to adapt
+    float period_pkt_rate;
+    /// rate of accepted packets in the adapt period; sometimes used to determine target rate of reports
+    float period_acc_rate; 
+    /// are we done adapting?
+    int done;
+    /// the function to call to provide a message to the user
+    spade_msg_fn msg_callback;
+} thresh_adapter;
+
+
+void init_thresh_adapter(thresh_adapter *self,spade_msg_fn msg_callback);
+thresh_adapter *new_thresh_adapter(spade_msg_fn msg_callback);
+void thresh_adapter_setup_from_str(thresh_adapter *self,int adaptmode,char *str);
+void thresh_adapter_setup_1(thresh_adapter *self, int target, time_t period, float new_obs_weight, int by_count);
+void thresh_adapter_setup_2(thresh_adapter *self, double targetspec, double obsper, int NS, int NM, int NL);
+void thresh_adapter_setup_3(thresh_adapter *self, double targetspec, double obsper, int NO);
+void thresh_adapter_setup_4(thresh_adapter *self, double thresh, double obsper);
+void thresh_adapter_start_time(thresh_adapter *self, time_t now);
+int thresh_adapter_new_time(thresh_adapter *self, spade_enviro *enviro, double *sugg_thresh);
+void thresh_adapter_new_score(thresh_adapter *self, double anom_score);
+
+void thresh_adapter_print_config_details(thresh_adapter *self,FILE *f,char *indent);
+
+/*@}*/
+#endif // THRESH_ADAPTER_H
+
+/*********************************************************************
+anomscore_surveyer.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+anomscore_surveyer.h is the header file for anomscore_surveyer.c
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: anomscore_surveyer.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef ANOMSCORE_SURVEYER_H
+#define ANOMSCORE_SURVEYER_H
+
+/*! \file anomscore_surveyer.h
+ * \brief 
+ *  anomscore_surveyer.h is the header file for anomscore_surveyer.c
+ * \ingroup stmgr
+ */
+
+/*! \weakgroup stmgr
+    @{
+*/
+
+
+
+
+#include <time.h>
+#include <stdio.h>
+
+/// represents an instance of an anomscore_surveyer
+typedef struct {
+    /// the number of seconds in the survey interval
+    float interval;
+    /// the survey file name
+    char *filename;
+
+    /// the survey log file handle
+    FILE *surveyfile;
+    /// the list of anomaly scores for the survey
+    ll_double *list;
+    /// the length of the list (1-based)
+    int list_len;
+    /// the suvery period number (starts with 1)
+    int period;
+    
+    /// the start time for this survey interval
+    time_t interval_start_time;
+    /// the number of packets seen in this survey period so far
+    int rec_count;
+} anomscore_surveyer;
+
+
+int init_anomscore_surveyer(anomscore_surveyer *self, char *filename, float interval,spade_msg_fn msg_callback);
+int init_anomscore_surveyer_from_str(anomscore_surveyer *self,char *str,spade_msg_fn msg_callback);
+anomscore_surveyer *new_anomscore_surveyer(char *filename, float interval,spade_msg_fn msg_callback);
+void anomscore_surveyer_flush(anomscore_surveyer *self);
+void anomscore_surveyer_shutdown(anomscore_surveyer *self);
+void anomscore_surveyer_new_time(anomscore_surveyer *self, spade_enviro *enviro);
+void anomscore_surveyer_new_score(anomscore_surveyer *self, double anom_score);
+
+void anomscore_surveyer_print_config_details(anomscore_surveyer *self,FILE *f,char *indent);
+
+/*@}*/
+#endif // ANOMSCORE_SURVEYER_H
+
+/*********************************************************************
+spade_state.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef SPADE_STATE_H
+#define SPADE_STATE_H
+
+/*! \file spade_state.h
+ * \brief 
+ *  spade_state.h is the header file for spade_state.c.
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+#include <stdio.h>
+#include <time.h>
+
+/// a handle for ths user on a currently active state recovery file
+typedef struct {
+    FILE *f; ///< the file pointer
+} statefile_ref;
+
+
+statefile_ref *spade_state_begin_checkpointing(char *filename, char *appname, u8 app_cur_fvers);
+int spade_state_end_checkpointing(statefile_ref *s);
+int spade_state_checkpoint_str(statefile_ref *s, char *str);
+int spade_state_checkpoint_arr(statefile_ref *s, void *arr, int len, int elsize);
+int spade_state_checkpoint_str_arr(statefile_ref *s, char **arr, int len);
+int spade_state_checkpoint_u32(statefile_ref *s, u32 val);
+int spade_state_checkpoint_u8(statefile_ref *s, u8 val);
+int spade_state_checkpoint_time_t(statefile_ref *s, time_t val);
+int spade_state_checkpoint_double(statefile_ref *s,double val);
+int spade_state_end_section(statefile_ref *s);
+
+statefile_ref *spade_state_begin_recovery(char *filename, int min_app_fvers, char **appname, u8 *file_app_fvers);
+int spade_state_end_recovery(statefile_ref *s);
+int spade_state_recover_check_end_of_section(statefile_ref *s, int *res);
+int spade_state_recover_arr(statefile_ref *s, void *arr, int len, int elsize);
+int spade_state_recover_str_arr(statefile_ref *s, char **arr, int len);
+int spade_state_recover_u32(statefile_ref *s, u32 *val);
+int spade_state_recover_u8(statefile_ref *s, u8 *val);
+int spade_state_recover_time_t(statefile_ref *s, time_t *val);
+int spade_state_recover_double(statefile_ref *s, double *val);
+int spade_state_recover_str(statefile_ref *s, char **str);
+int spade_state_recover_str_to_buff(statefile_ref *s, char *buff, int maxlen);
+
+#endif // SPADE_STATE_H
+
+/* Id: spade_state.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+//
+/*********************************************************************
+score_info.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: score_info.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SCORE_INFO_H
+#define SCORE_INFO_H
+
+/*! \file score_info.h
+ * \brief 
+ *  score_info.h contains the type declaration for the score_info
+ *  struct and the interface to the associated functions
+ * \ingroup scoreprod
+ */
+
+/*! \addtogroup scoreprod
+    @{
+*/
+
+/// a special double indicating that there is no anomaly score
+#define NO_SCORE (double)-1
+
+/// enum containing the possible preferences among types of anomaly scores
+typedef enum {PREF_NOSCORE,PREF_RAWSCORE,PREF_RELSCORE} scorepref;
+
+const char *scorepref_str(scorepref pref);
+
+/// stores information about a anomaly scoring result
+typedef struct _score_info {
+    scorepref main; ///< the preference for which available score to use as the main score
+    double relscore; ///< the relative anomaly score, or NO_SCORE
+    double rawscore; ///< the raw anomaly score, or NO_SCORE
+    int corrscore_used; ///< if the raw anomaly score was computed, was it computed correctly
+    
+    struct _score_info *next; ///< the next score_info in a list of them
+} score_info;
+
+score_info *new_score_info(scorepref main, double relscore, double rawscore, int corrscore_used);
+void init_score_info(score_info *i, scorepref main, double relscore, double rawscore, int corrscore_used);
+score_info *score_info_clone(score_info *i);
+void free_score_info(score_info *i);
+void free_score_infos(score_info *start);
+
+double score_info_mainscore(score_info *i);
+double score_info_relscore(score_info *i);
+double score_info_rawscore(score_info *i);
+int score_info_raw_is_corrscore(score_info *i);
+scorepref score_info_main_pref(score_info *i);
+
+/*@}*/
+#endif // SCORE_INFO_H
+
+/*********************************************************************
+spade_event.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: spade_event.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SPADE_EVENT_H
+#define SPADE_EVENT_H
+
+/*! \file spade_event.h
+ * \brief 
+ *  spade_event.h contains the type declaration for the spade_event struct 
+ *  and the interface to the associated functions
+ * \ingroup libspade_misc
+ */
+
+/*! \addtogroup libspade_misc
+    @{
+*/
+
+/*********************************************************************
+spade_prob_table_types.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef SPADE_PROB_TABLE_TYPES_H
+#define SPADE_PROB_TABLE_TYPES_H
+
+/*! \file spade_prob_table_types.h
+ * \brief 
+ *  spade_prob_table_types.h is the header file for spade_prob_table_types.c.
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+
+
+/// index type into tree memory block data structures
+typedef u32 mindex;
+
+/// dmindex is a mindex used with top bit indicating if one of two datatypes is present
+typedef u32 dmindex;
+
+/// the type of the values of the features
+/** \note right now, we assume all features can be contained in a u32 and can be sorted as unsigned ints; we may need to extend this someday */
+typedef u32 valtype;
+
+
+/// a tree root
+typedef struct _treeroot {
+    mindex next;      ///< the next tree root in a list
+    dmindex root;     ///< root node of the tree, if top bit is 1, it is a leafnode, otherwise it is a interior node
+    features type;    ///< the feature that is being represented in this tree
+    double entropy;   ///< the last calculated entropy in this tree; < 0 if it has not been calculated
+    u16 entropy_wait; ///< the number of additions to the tree to wait till recalculating the entropy; only valid if entropy >= 0
+} treeroot;
+
+/// an interior node in the tree
+typedef struct _intnode {
+    double sum;     ///< the sum of the counts underneath this node in the tree
+    valtype sortpt; ///< the highest value on the left side of this node
+    dmindex left;   ///< the left node; if top bit is 1, it is a leafnode
+    dmindex right;  ///< the right node; if top bit is 1, it is a leafnode
+    u16 wait;       ///< the number of additions to the subtree to wait before checking for reblancing
+} intnode;
+
+/// a leaf node of the tree
+typedef struct _leafnode {
+    double count;    ///< the count on this node
+    valtype value;   ///< the value this node represents
+    mindex nexttree; ///< the first in a linked list of trees anchored from this leaf node
+} leafnode;
+
+#define isleaf(node) (node & DMINDEXMASK)
+#define asleaf(leaf) (leaf | DMINDEXMASK)
+#define encleaf2mindex(node) (node ^ DMINDEXMASK)
+/* arg is a dmindex; if it denotes a leaf, return the count on that leaf
+   otherwise return the sum on the interior node */ 
+#define count_or_sum(node) (isleaf(node) ? leafnode(encleaf2mindex(node)).count : intnode(node).sum)
+#define eleafval(leaf) leafnode(encleaf2mindex(leaf)).value
+#define largestval(node) (isleaf(node) ? eleafval(node) : largest_val(node))
+#define treetype(t) tree(t).type
+#define treeroot(t) tree(t).root
+#define treenext(t) tree(t).next
+#define treeH(t) tree(t).entropy
+#define treeH_wait(t) tree(t).entropy_wait
+#define intleft(node) intnode(node).left
+#define intright(node) intnode(node).right
+#define intsum(node) intnode(node).sum
+#define intsortpt(node) intnode(node).sortpt
+#define intwait(node) intnode(node).wait
+#define leafcount(leaf) leafnode(leaf).count
+#define leafvalue(leaf) leafnode(leaf).value
+#define leafnexttree(leaf) leafnode(leaf).nexttree
+
+
+/* defaults unless recovering from a checkpoint */
+#define DEFAULT_ROOT_BLOCK_BITS 10
+#define DEFAULT_INT_BLOCK_BITS 9
+#define DEFAULT_LEAF_BLOCK_BITS 10
+
+/* these number of blocks are used
+   unless file recovering from already uses more blocks */
+#define DEFAULT_MAX_ROOT_BLOCKS 4500
+#define DEFAULT_MAX_INT_BLOCKS 12000
+#define DEFAULT_MAX_LEAF_BLOCKS 9000
+
+#define bits2blocksize(b) (1 << b)
+
+#define ROOT_BLOCK_SIZE bits2blocksize(ROOT_BLOCK_BITS)
+#define ROOT_BLOCK_MASK ((1 << ROOT_BLOCK_BITS) -1)
+#define tree(i) ROOT_M[i>>ROOT_BLOCK_BITS][i&ROOT_BLOCK_MASK]
+#define root_index(p,i) ((p<<ROOT_BLOCK_BITS)+i)
+
+#define INT_BLOCK_SIZE bits2blocksize(INT_BLOCK_BITS)
+#define INT_BLOCK_MASK ((1 << INT_BLOCK_BITS) -1)
+#define intnode(i) INT_M[i>>INT_BLOCK_BITS][i&INT_BLOCK_MASK]
+#define intnode_index(p,i) ((p<<INT_BLOCK_BITS)+i)
+
+#define LEAF_BLOCK_SIZE bits2blocksize(LEAF_BLOCK_BITS)
+#define LEAF_BLOCK_MASK ((1 << LEAF_BLOCK_BITS) -1)
+#define leafnode(i) LEAF_M[i>>LEAF_BLOCK_BITS][i&LEAF_BLOCK_MASK]
+#define leafnode_index(p,i) ((p<<LEAF_BLOCK_BITS)+i)
+
+#define rfreenext(n) (n).next
+#define ifreenext(n) (n).left
+#define lfreenext(n) (n).nexttree
+
+/* something of valtype that cannot be a sortpt */
+#define NOT_A_SORTPT ((u32)MAX_U32)
+
+#define TNULL (mindex)-1
+#define DMINDEXMASK ((dmindex)(1 << (sizeof(dmindex)*8-1)))
+
+extern treeroot **ROOT_M;
+extern intnode **INT_M;
+extern leafnode **LEAF_M;
+extern mindex root_freelist;
+extern mindex int_freelist;
+extern mindex leaf_freelist;
+
+void init_mem();
+void allocate_mem_blocks();
+int reallocate_ptr_array(void ***arrptr,int oldsize,int newsize);
+
+mindex new_treeinfo(features type);
+void free_treeinfo(mindex f);
+mindex new_int();
+void free_int(mindex f);
+mindex new_leaf(valtype val);
+void free_leaf(mindex f);
+
+extern unsigned char ROOT_BLOCK_BITS;
+extern unsigned char INT_BLOCK_BITS;
+extern unsigned char LEAF_BLOCK_BITS;
+extern unsigned int MAX_ROOT_BLOCKS;
+extern unsigned int MAX_INT_BLOCKS;
+extern unsigned int MAX_LEAF_BLOCKS;
+
+#endif // SPADE_PROB_TABLE_TYPES_H
+
+/* Id: spade_prob_table_types.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+
+/// function type to make a copy of a spade_event's "native" field
+typedef void *(*event_native_copier_t)(void *native);
+/// function type to free a copy of a spade_event's "native" field
+typedef void (*event_native_freer_t)(void *native);
+
+/// the representation of an event that is being given to libspade
+typedef struct {
+    /// the features, indexed by feature number (libspade-user assigned)
+    valtype fldval[MAX_NUM_FEATURES];
+    /// the time the event occurred
+    double time;
+    /// the origin of the event, in user defined terms
+    u32 origin;
+
+    /// a field the user may use to maintain a reference to its own representation of the event
+    void *native;
+    /// used internally, at times this field may be set to point to a routine to free the native copy
+    event_native_freer_t native_freer;
+} spade_event;
+
+spade_event *new_spade_event(void);
+spade_event *spade_event_clone(spade_event *e, event_native_copier_t native_copier, event_native_freer_t native_freer);
+void free_spade_event(spade_event *e);
+
+/*@}*/
+
+#endif // SPADE_EVENT_H
+
+
+
+
+#define ADVISING_OFF     0 ///< threshold advising status indicating the threshold advising was never on
+#define ADVISING_RUNNING 1 ///< threshold advising status indicating the threshold advising is on and running
+#define ADVISING_DONE    2 ///< threshold advising status indicating the threshold advising was on but has now completed
+
+/// function type for a function to call when a score exceeds the reporting threshold
+typedef void (*spade_thresh_exceeded_fn_t)(void *context,void *targetref,spade_event *event,score_info *score);
+/// function type for a function to call when a reporting threshold changes
+typedef void (*spade_thresh_changed_fn_t)(void *context,void *targetref);
+
+// storage for an instance of a score manager
+typedef struct {
+    void *mgrref; ///< some sort of identifier of this score manager
+    spade_enviro *enviro; ///< environment shared with target user
+    
+    int adapt_active; ///< 0 is there is no adapting; otherwise the adapt method #
+    int advise_status; ///< ADVISING_OFF, ADVISING_RUNNING, or ADVISING_DONE
+    int survey_active; ///< true if survey mode is active
+    
+    thresh_adapter adapter; ///< our threshold adapter module, if threshold adapting is in use
+    thresh_adviser adviser; ///< our threshold advising module, if threshold advising is in use
+    anomscore_surveyer surveyer; ///< our anomaly score surveyer module, if this is on
+        
+    /// function to call when we see a score that exceeds the threshold, or NULL if none
+    spade_thresh_exceeded_fn_t threshexceeded_callback;
+    /// function to call when the reporting threshold changes, or NULL if none
+    spade_thresh_changed_fn_t threshchanged_callback;
+    void *callback_context; ///< user-provided pointer that is returned as first arg in callback
+
+    spade_msg_fn msg_callback; ///< function to call when there is a message for the user
+} score_mgr;
+
+score_mgr *new_score_mgr(void *mgrref, spade_enviro *enviro, void *callback_context, spade_thresh_exceeded_fn_t threshexceeded_callback, spade_thresh_changed_fn_t threshchanged_callback,spade_msg_fn msg_callback);
+void init_score_mgr(score_mgr *self, void *mgrref, spade_enviro *enviro, void *callback_context, spade_thresh_exceeded_fn_t threshexceeded_callback, spade_thresh_changed_fn_t threshchanged_callback,spade_msg_fn msg_callback);
+
+void score_mgr_setup_adapt_from_str(score_mgr *self, int adaptmode, char *str);
+void score_mgr_setup_adapt1(score_mgr *self, int target, time_t period, float new_obs_weight, int by_count);
+void score_mgr_setup_adapt2(score_mgr *self, double targetspec, double obsper, int NS, int NM, int NL);
+void score_mgr_setup_adapt3(score_mgr *self, double targetspec, double obsper, int NO);
+void score_mgr_setup_adapt4(score_mgr *self, double thresh, double obsper);
+void score_mgr_setup_advise(score_mgr *self, int obs_size, int obs_secs);
+void score_mgr_setup_advise_from_str(score_mgr *self, char *str);
+void score_mgr_setup_survey(score_mgr *self, char *filename, float interval);
+void score_mgr_setup_survey_from_str(score_mgr *self, char *str);
+
+int score_mgr_new_time(score_mgr *self, time_t time);
+void score_mgr_new_event(score_mgr *self, score_info *score, spade_event *event);
+
+void score_mgr_dump(score_mgr *self);
+void score_mgr_cleanup(score_mgr *self);
+void score_mgr_file_print_log(score_mgr *self, FILE *file);
+
+void score_mgr_print_config_details(score_mgr *self, FILE *file, char *indent);
+
+/*@}*/
+#endif // SCORE_MGR_H
+
+
+/*********************************************************************
+spade_report.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+spade_report.h contains the type declaration for the spade_report struct 
+  and the interface to the associated functions
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: spade_report.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SPADE_REPORT_H
+#define SPADE_REPORT_H
+
+/*! \file spade_report.h
+ * \ingroup netspade_layer
+ * \brief 
+ *  spade_report.h contains the type declaration for the spade_report struct 
+ *  and the interface to the associated functions
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+
+
+
+#include <stdio.h>
+
+/// a mask for the bits of a port_status_t that represent belief strength
+#define PORT_STRENGTH_MASK 0x003
+/// a mask for the bits of a port_status_t that represent the port status
+#define PORT_BASE_MASK (0xFFF & ~PORT_STRENGTH_MASK)
+
+/// mask off the port status part of a port_status_t
+#define PORT_BASE(status) ((status) & PORT_BASE_MASK)
+/// mask off the belief strength part of a port_status_t
+#define PORT_STRENGTH(status) ((status) & PORT_STRENGTH_MASK)
+
+/// representation of a definate strength belief in port status
+#define PORT_STRENGTH_DEFINATE 0x002
+/// representation of a "likely" strength belief in port status
+#define PORT_STRENGTH_LIKELY 0x001
+/// representation of a "probably" strength belief in port status
+#define PORT_STRENGTH_PROBABLY 0x000
+
+/// port status part of a port_status_t when it is open
+#define PORT_OPEN_BASE (1<<2)
+/// port status part of a port_status_t when it is closed
+#define PORT_CLOSED_BASE (2<<2)
+
+/// an enum of value that represents our preception of a port's status
+/** the integer value is based on a combination of port status and strength of belief */
+typedef enum {
+    /// we don't know the port's status
+    PORT_UNKNOWN=0,
+    /// we think the port is probably open
+    PORT_PROBOPEN       =PORT_OPEN_BASE  |PORT_STRENGTH_PROBABLY,
+    /// we think the port is likely open
+    PORT_LIKELYOPEN     =PORT_OPEN_BASE  |PORT_STRENGTH_LIKELY,
+    /// we think the port is definately open
+    PORT_OPEN           =PORT_OPEN_BASE  |PORT_STRENGTH_DEFINATE,
+    /// we think the port is probably closed
+    PORT_PROBCLOSED     =PORT_CLOSED_BASE|PORT_STRENGTH_PROBABLY,
+    /// we think the port is likely closed
+    PORT_LIKELYCLOSED   =PORT_CLOSED_BASE|PORT_STRENGTH_LIKELY,
+    /// we think the port is definately closed
+    PORT_CLOSED         =PORT_CLOSED_BASE|PORT_STRENGTH_DEFINATE
+} port_status_t;
+
+#define PORT_STATUS_AS_STR(status) (status == PORT_UNKNOWN ? "PORT_UNKNOWN" \
+    : (status == PORT_PROBOPEN) ? "PORT_PROBOPEN" \
+    : (status == PORT_LIKELYOPEN) ? "PORT_LIKELYOPEN" \
+    : (status == PORT_OPEN) ? "PORT_OPEN" \
+    : (status == PORT_PROBCLOSED) ? "PORT_PROBCLOSED" \
+    : (status == PORT_LIKELYCLOSED) ? "PORT_LIKELYCLOSED" \
+    : (status == PORT_PROBOPEN) ? "PORT_PROBOPEN" \
+    : (status == PORT_CLOSED) ? "PORT_CLOSED" \
+    : "UNDEFINED" \
+    )
+
+/// data type for representing a set of port statuses
+/** the value is based on a bit mask, where the bit position is determined by the value of the port_status_t */
+typedef u16 port_status_set_t;
+/// port_status_set_t value when the set is empty
+#define PS_EMPTY_SET (port_status_set_t)0
+/// port_status_set_t value when the set consists of just the given port_status_t value
+#define PS_STATUS_MASK(status) (1 << (status))
+/// port_status_set_t value when the set consists of the given port_status_t value and stronger beliefs
+#define PS_STATUS_MASK_WITH_STRONGER(status) ((status) == PORT_UNKNOWN ? 0xFFF \
+    : PS_STATUS_MASK(status) \
+        | (PORT_STRENGTH(status) < PORT_STRENGTH_LIKELY \
+            ? (PS_STATUS_MASK(PORT_BASE(status)|PORT_STRENGTH_LIKELY)) \
+            : 0 ) \
+        | (PORT_STRENGTH(status) < PORT_STRENGTH_DEFINATE \
+            ? (PS_STATUS_MASK(PORT_BASE(status)|PORT_STRENGTH_DEFINATE)) \
+            : 0 ) \
+    )
+/// initialize a port_status_set_t variable to contatin just the given port_status_t value
+#define PS_INIT_SET(set,status) (set= PS_STATUS_MASK(status))
+/// initialize a port_status_set_t variable to contatin of the given port_status_t value and stronger beliefs
+#define PS_INIT_SET_WITH_STRONGER(set,status) (set= PS_STATUS_MASK_WITH_STRONGER(status))
+/// add the given port_status_t to a port_status_set_t stored in the given variable
+#define PS_ADD_TO_SET(set,status) (set|= PS_STATUS_MASK(status))
+/// add the given port_status_t and stronger beliefs to a port_status_set_t stored in the given variable
+#define PS_ADD_TO_SET_WITH_STRONGER(set,status) (set|= PS_STATUS_MASK_WITH_STRONGER(status))
+/// test if the given port_status_t in the given port_status_set_t
+#define PS_IN_SET(set,status) (set & PS_STATUS_MASK(status))
+
+void port_status_set_file_print(port_status_set_t set,FILE *f);
+
+/// the representation of a Spade report internally and to the libnetspade user
+typedef struct _spade_report {
+    /// the detector type triggering this spade report (from spade_detection_types.h)
+    int detect_type;
+    /// the detector id of the spade detector that is sending this report
+    char *detectorid;
+    /// pointer to the packet (originally provided by the libspade user) this report is about
+    spade_event *pkt;
+    /// pointer to the calculated packet anomaly score(s)
+    score_info *score;
+    /// current port status
+    port_status_t port_status;
+    /// string representing the detection type employed
+    const char *detect_type_str;
+    /// string representing the detectors scope
+    char scope_str[200];
+    /// pointer to stream statistics
+    spade_pkt_stats *stream_stats;
+    /// the next spade report in a list of them
+    struct _spade_report *next;
+} spade_report;
+
+spade_report *new_spade_report(spade_event *pkt,score_info *score, int detect_type, char *detectorid,const char *detect_type_str,char *scope_str,spade_pkt_stats *stream_stats,port_status_t port_status);
+void free_spade_report(spade_report *rpt);
+void free_spade_reports(spade_report *rpt);
+
+#define spade_report_mainscore(rpt) (rpt != NULL ? score_info_mainscore(rpt->score) : NO_SCORE)
+#define spade_report_relscore(rpt) (rpt != NULL ? score_info_relscore(rpt->score) : NO_SCORE)
+#define spade_report_rawscore(rpt) (rpt != NULL ? score_info_rawscore(rpt->score) : NO_SCORE)
+#define spade_report_raw_is_corrscore(rpt) (score_info_raw_is_corrscore(rpt->score))
+#define spade_report_main_pref(rpt) (score_info_main_pref(rpt->score))
+
+/*@}*/
+
+#endif // SPADE_REPORT_H
+
+/*********************************************************************
+score_calculator.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: score_calculator.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef SCORE_CALCULATOR_H
+#define SCORE_CALCULATOR_H
+
+/*! \file score_calculator.h
+ * \brief 
+ *  score_calculator.h is the header file for score_calculator.c
+ * \ingroup scoreprod
+ */
+
+/*! \addtogroup scoreprod
+    @{
+*/
+
+#include <stdio.h>
+
+/*********************************************************************
+event_recorder.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+/* Internal version control: Id: event_recorder.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+#ifndef EVENT_RECORDER_H
+#define EVENT_RECORDER_H
+
+/*! \file event_recorder.h
+ * \brief 
+ *  event_recorder.h is the header file for event_recorder.c
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+
+/*********************************************************************
+spade_prob_table.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef SPADE_PROB_TABLE_H
+#define SPADE_PROB_TABLE_H
+
+/*! \file spade_prob_table.h
+ * \brief 
+ *  spade_prob_table.h is the header file for spade_prob_table.c.
+ * \ingroup staterec
+ */
+
+/*! \addtogroup staterec
+    @{
+*/
+
+
+
+
+
+#include <stdio.h>
+
+/// a spade probability table, represented by some number of nested trees
+typedef struct {
+    mindex root[MAX_NUM_FEATURES]; ///< top level tree roots in an array indexed by the feature type of the top level tree
+    const char **featurenames;     ///< user provided pointer to array of the string names of the features, used for output
+} spade_prob_table;
+
+/// an element in a data structure representing a set of doubles indexed by a list of features
+typedef struct _featcomb {
+    struct _featcomb *next[MAX_NUM_FEATURES]; ///< pointers to the next level of structure, indexed by feature
+    double val[MAX_NUM_FEATURES];  ///< the values stored; indexed by the final feature in the list
+} *featcomb;
+
+#define STATS_NONE          0x00  ///< no statistics
+#define STATS_ENTROPY       0x01  ///< entropy statistics
+#define STATS_UNCONDPROB    0x02  ///< unconditional probabilities
+#define STATS_CONDPROB      0x04  ///< conditional probabilities
+
+#define PROBRESULT_NO_RECORD (double)-1.0 ///< a special probability value denoting the probability denominator was 0
+
+
+void init_spade_prob_table(spade_prob_table *self,const char **featurenames,int recovering);
+spade_prob_table *new_spade_prob_table(const char **featurenames);
+
+int spade_prob_table_is_empty(spade_prob_table *self);
+
+void increment_simple_count(spade_prob_table *self, features type1, valtype val1);
+void increment_2joint_count(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2, int skip);
+void increment_3joint_count(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2, features type3, valtype val3, int skip);
+void increment_4joint_count(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2, features type3, valtype val3, features type4, valtype val4, int skip);
+void increment_Njoint_count(spade_prob_table *self,int size,features type[],valtype val[],int skip);
+
+double prob_simple(spade_prob_table *self, features type1, valtype val1);
+double prob_2joint(spade_prob_table *self, features type1, valtype val1, features type2, valtype val2);
+double prob_Njoint(spade_prob_table *self, int size, features type[], valtype val[]);
+double prob_Njoint_Ncond(spade_prob_table *self, int size, features type[], valtype val[], int condoffset);
+double prob_Njoint_Ncond_plus_one(spade_prob_table *self, int size, features type[], valtype val[], int condoffset);
+double prob_cond1(spade_prob_table *self, features type, valtype val, features ctype, valtype cval);
+double prob_cond2(spade_prob_table *self, features type, valtype val, features ctype1, valtype cval1, features ctype2, valtype cval2);
+double prob_cond3(spade_prob_table *self, features type, valtype val, features ctype1, valtype cval1, features ctype2, valtype cval2, features ctype3, valtype cval3);
+double one_prob_simple(spade_prob_table *self,features type1);
+
+double jointN_count(spade_prob_table *self,int size,features type[], valtype val[]);
+
+double spade_prob_table_entropy(spade_prob_table *self, int size, features type[], valtype val[]);
+
+void scale_and_prune_table(spade_prob_table *self, double factor, double threshold);
+
+float feature_trees_stats(spade_prob_table *self, features f, float *amind, float *amaxd, float *aaved, float *awaved);
+
+void spade_prob_table_write_stats(spade_prob_table *self,FILE *file,u8 stats_to_print);
+void write_feat_val_list(spade_prob_table *self,FILE *f, int depth, features feats[], valtype vals[]);
+void write_all_uncond_probs(spade_prob_table *self, FILE *f);
+void write_all_cond_probs(spade_prob_table *self, FILE *f);
+featcomb calc_all_entropies(spade_prob_table *self);
+void write_all_entropies(spade_prob_table *self,FILE *f, featcomb c);
+
+void print_spade_prob_table(spade_prob_table *self);
+int sanity_check_spade_prob_table(spade_prob_table *self);
+
+
+int spade_prob_table_checkpoint(statefile_ref *s,spade_prob_table *self);
+int spade_prob_table_recover(statefile_ref *s,spade_prob_table *self);
+
+
+#endif // SPADE_PROB_TABLE_H
+
+/* Id: spade_prob_table.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+
+
+
+
+#include <stdio.h>
+
+/// a set of event conditions
+/** An event condition is a boolean condition on a spade_event; it is true
+    if the condition is satisfied and false otherwise.  All regular event
+    conditions are defined by the libspade user.  event_condition_set
+    represents a set of conditions which are simulatneously true for an
+    event.  This is presently represented as a u32 bit-mask, which is
+    operationally very efficient but which has its limits including only
+    being able to represent 32 conditions and permitting only boolean
+    conditions */
+typedef u32 event_condition_set;
+/// macro to get at event condition #n
+#define EVENT_CONDITION_NUM(n) (1 << (n-1))
+/// the special true event condition
+#define EVENT_CONDITION_TRUE 0
+/// the special false event condition
+#define EVENT_CONDITION_FALSE EVENT_CONDITION_NUM(32)
+
+/// are all conditions in the event_condition_set ref met in the testcase event_condition_set
+#define ALL_CONDS_MET(testcase,ref) (((testcase) & (ref)) == (ref))
+/// is at least one of the conditions in ref met in the testcase
+#define SOME_CONDS_MET(testcase,ref) ((testcase) & (ref))
+/// add newconds to event_condition_set var
+#define ADD_TO_CONDS(var,newconds) ((var) |= (newconds))
+/// remove remconds from the event_condition_set var
+#define REMOVE_FROM_CONDS(var,remconds) ((var) &= ~remconds)
+/// compose a condition set (returned) from N event conditions
+#define CONDS_PLUS_CONDS(cond1,cond2) (cond1 | cond2)
+#define CONDS_PLUS_2CONDS(cond1,cond2,cond3) (cond1 | cond2 | cond3)
+#define CONDS_PLUS_3CONDS(cond1,cond2,cond3,cond4) (cond1 | cond2 | cond3 | cond4)
+#define CONDS_PLUS_4CONDS(cond1,cond2,cond3,cond4,cond5) (cond1 | cond2 | cond3 | cond4 | cond5)
+#define CONDS_PLUS_5CONDS(cond1,cond2,cond3,cond4,cond5,cond6) (cond1 | cond2 | cond3 | cond4 | cond5 | cond6)
+#define CONDS_PLUS_6CONDS(cond1,cond2,cond3,cond4,cond5,cond6,cond7) (cond1 | cond2 | cond3 | cond4 | cond5 | cond6 | cond7)
+/// return the event_condition_set formed by removing cond2 from cond1
+#define CONDS_MINUS_CONDS(cond1,cond2) (cond1 & ~cond2)
+/// test if the condition set indicates false
+#define CONDS_NOT_FALSE(conds) (((conds) & EVENT_CONDITION_FALSE) == 0)
+/// return the event_condition_set formed by restricting cond1 to only those conditions in cond2
+#define ONLY_CONDS(origconds,onlyconds) ((origconds) & onlyconds)
+
+
+/// structure containing the elements of a table manager
+typedef struct _table_mgr {
+    spade_prob_table table; ///< the probability table we use
+    struct _table_mgr *next; ///< the next table manager in a linked list of them
+    time_t last_scale; ///< the last time this table was scaled/pruned
+    u32 store_count; ///< the number of events we have stored
+    
+    feature_list feats; ///< the features we store, in order
+    const char **featurenames; ///< direct-index lookup array to map features to their names
+    
+    event_condition_set conds; ///< the event conditions under which this table is used for storage
+    time_t start_time; ///< the time we started recording events
+    int scale_freq; ///< how often we scale/prune, in secs
+    double scale_factor; ///< when we scale, how much do we do so?; this is the multiplier
+    double prune_threshold;  ///< if an observation gets below this size, it gets discarded
+    int use_count; ///< how many event files are using this table manager
+} table_mgr;
+
+/// structure containing the elements on an event file
+typedef struct _evfile {
+    /// the table manager that does the storge for this event file
+    table_mgr *mgr;
+    /// this how many features deep we care about; table manager may store more for other reasons
+    int feat_depth;
+    /// the features we need stored, in order
+    feature_list calc_feats; /*!< \note maybe eventually we should maintain a user-addressable set of these */
+
+    /// the next event file in a linked list of them
+    struct _evfile *next;
+} evfile;
+
+/// the way a event_recorder user refers to a particular event file
+typedef evfile *evfile_ref;
+
+/// the representation for an instance of an event_recorder
+typedef struct {
+    /// linked list of the table managers that are defined
+    table_mgr *tables;
+    /// linked list of the event files that are defined
+    evfile *files;
+    /// the current time
+    time_t curtime;
+} event_recorder;
+
+/// function type that can be called to print the string version of a set of event conditions to a FILE *
+typedef void (*condition_printer_t)(FILE *file,event_condition_set conds);
+
+
+event_recorder *new_event_recorder(void);
+void init_event_recorder(event_recorder *self);
+
+int event_recorder_recover(event_recorder **self, statefile_ref *ref);
+int event_recorder_merge_recover(event_recorder *self, statefile_ref *ref);
+int event_recorder_checkpoint(event_recorder *self, statefile_ref *ref);
+
+evfile_ref event_recorder_new_event_file(event_recorder *self, feature_list *feats, const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold, int fresh_only, feature_list *calc_feats);
+evfile_ref *event_recorder_new_event_files(event_recorder *self, int howmany, feature_list feats[], const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold, int fresh_only);
+
+void event_recorder_new_time(event_recorder *self, time_t time);
+event_condition_set event_recorder_needed_conds(event_recorder *self);
+int event_recorder_new_event(event_recorder *self, spade_event *event, event_condition_set matching_conds);
+void event_recorder_prune_unused(event_recorder *self);
+
+double event_recorder_get_prob(event_recorder *self, evfile_ref eventfile, spade_event *event,int one_more);
+double event_recorder_get_condprob(event_recorder *self, evfile_ref eventfile, spade_event *event, int condcutoff,int one_more);
+double event_recorder_get_count(event_recorder *self, evfile_ref eventfile, spade_event *event, int featdepth);
+double event_recorder_get_entropy(event_recorder *self,evfile_ref eventfile,spade_event *event,int entropy_prefix_len);
+
+int event_recorder_get_store_count(event_recorder *self, evfile_ref eventfile);
+double event_recorder_get_obs_count(event_recorder *self, evfile_ref eventfile);
+
+void event_recorder_write_stats(event_recorder *self, FILE *file, u8 stats_to_print,condition_printer_t condprinter);
+
+void evfile_print_config_details(evfile_ref eventfile,FILE *f,char *indent);
+#endif // EVENT_RECORDER_H
+
+
+
+/// a structure containing the various components describing how a probability table is going to be used
+typedef struct {
+    int prodcount; ///< the number of conditional probabilities to multiply
+    feature_list *feats; ///< if prodcount > 1, the array of feature lists to use; space is dynamically allocated 
+    feature_list calc_feats; ///< if prodcount=1, the list of features for the table
+    const char **featurenames; ///< direct-index lookup array to map features to their names
+    event_condition_set conds; ///< the event conditions under which the table will be used for storage
+    int scale_freq; ///< how often the table will be scaled/pruned, in secs
+    double scale_factor; ///< when we scale, how much do we do so by
+    double prune_threshold; ///< if an observation gets below this size, it will be discarded
+} table_use_specs;
+
+/// an instance of a score calculator
+typedef struct {
+    int prodcount; ///< the number of conditional probabilities to multiply
+    evfile_ref *evfiles; ///< if prodcount > 1, array of evfile's in the event recorder storing the tables needed for each probability
+    evfile_ref evfile; ///< if we only have one prob, we store store the evfile here
+    int calc_rawscore; ///< should the raw anonamaly score be calculated
+    int calc_relscore; ///< should the relative anonamaly score be calculated
+    scorepref mainpref; ///< the preferred score type to store
+    int use_corrscore; ///< correctly compute the raw anomaly score?
+    int cond_prefix_len; ///< how far into feats should we use as the denominator for calculating the probability
+    int min_obs_prefix_len; ///< if > 0, we require a min observation, this is how far into feats the spec is for
+    double min_obs_count; ///< the minimum observation count
+    double max_entropy; ///< if >= 0, we are using a selection critea based on maximum entropy under the values of a certain feature
+    int entropy_prefix_len; ///< the depth of the run-up to the value field when using max entropy selection criterea
+    table_use_specs *evfiles_data; ///< parameters to evfiles while being set up
+    event_recorder *recorder; ///< a pointer to the event recorder where the events are stored 
+} score_calculator;
+
+score_calculator *new_score_calculator(int prodcount, feature_list prod_cond[], const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold, event_recorder *recorder, feature_list *calc_feats);
+void init_score_calculator(score_calculator *self, int prodcount, feature_list prod_cond[], const char **featurenames, event_condition_set conds, int scale_freq, double scale_factor, double prune_threshold, event_recorder *recorder, feature_list *calc_feats);
+score_calculator *new_score_calculator_clear(event_recorder *recorder);
+void init_score_calculator_clear(score_calculator *self, event_recorder *recorder);
+
+void score_calculator_set_features(score_calculator *self, int prodcount, feature_list prod_cond[], feature_list *calc_feats, const char **featurenames);
+void score_calculator_set_storage_conditions(score_calculator *self, event_condition_set conds);
+void score_calculator_set_scaling(score_calculator *self, int scale_freq, double scale_factor, double prune_threshold);
+void score_calculator_init_complete(score_calculator *self);
+
+void score_calculator_set_condcutoff(score_calculator *self, int cond_prefix_len);
+void score_calculator_set_relscore(score_calculator *self, int calc_relscore, int rel_is_main);
+void score_calculator_set_rawscore(score_calculator *self, int calc_rawscore, int raw_is_main);
+void score_calculator_set_corrscore(score_calculator *self, int use_corrscore);
+void score_calculator_set_min_obs(score_calculator *self, int featlist_prefix_len, int min_obs_count);
+void score_calculator_set_low_entropy_domain(score_calculator *self, int val_prefix_len, double max_entropy);
+void score_calculator_cleanup(score_calculator *self);
+
+int score_calculator_using_corrscore(score_calculator *self);
+int score_calculator_using_relscore(score_calculator *self);
+
+score_info *score_calculator_calc_event_score(score_calculator *self, spade_event *event, score_info *storage,int *enoughobs);
+
+int score_calculator_get_store_count(score_calculator *self);
+double score_calculator_get_obs_count(score_calculator *self);
+
+void score_calculator_print_config_details(score_calculator *self,FILE *f,char *indent);
+
+/*@}*/
+#endif // SCORE_CALCULATOR_H
+
+/*********************************************************************
+packet_resp_canceller.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef PACKET_RESP_CANCELLER_H
+#define PACKET_RESP_CANCELLER_H
+
+/*! \file packet_resp_canceller.h
+ * \ingroup netspade_layer
+ * \brief 
+ *  packet_resp_canceller.h is the header file for packet_resp_canceller.c.
+ */
+
+/*! \addtogroup netspade_layer
+    @{
+*/
+
+
+#include <time.h>
+
+/// function type for a callback for a packet response canceller to report the status of a report
+typedef void (*prc_report_status_fn)(void *context,spade_report *rpt,port_status_t status);
+
+/// a two-way link used to store reports in the packet response canceller
+typedef struct _prc_link {
+    spade_report *rpt; /*!< the report being stored */
+    struct _prc_link *ltl_next; /*!< next link in a lookup table list */
+    struct _prc_link *ttl_next; /*!< next link in a time table list */
+} prc_link;
+
+/// a list of prc_link's
+typedef struct {
+    prc_link *head;  ///< the head
+    prc_link *tail;  ///< the tail
+} prc_list;
+
+/// the packet response canceller time-based table
+typedef struct {
+    prc_list *arr; ///< an array of buckets, each holding the reports for a given second
+    int num_buckets; ///< how many buckets are there
+    time_t last_timeout; ///< when was the last time a timeout was checked for
+} prc_time_table;
+
+#define LOOKUP_TABLE1_BITS 12 ///< how many bits are in the key to the first level lookup table
+#define LOOKUP_TABLE2_BITS 8 ///< how many bits are in the key to the second level lookup tables
+#define LOOKUP_TABLE1_SIZE (1 << LOOKUP_TABLE1_BITS) ///< the number of elements in the first level lookup hash table
+#define LOOKUP_TABLE2_SIZE (1 << LOOKUP_TABLE2_BITS) ///< the number of elements in the second level lookup hash tables
+#define LOOKUP_TABLE1_MASK (LOOKUP_TABLE1_SIZE -1) ///< mask used in the hash function for the first level lookup table
+#define LOOKUP_TABLE2_MASK (LOOKUP_TABLE2_SIZE -1) ///< mask used in the hash function for the second level lookup tables
+
+/// a second level lookup table
+/** this table maps a report to a unsorted linked list of stored reports */
+typedef struct {
+    prc_link *arr[LOOKUP_TABLE2_SIZE]; ///< a second level hash table, each bucket hold a set reports
+    int num_used; ///< the number of slots in the hash table that are presently used
+} prc_lookup_table2;
+
+/// the first level lookup table
+/** this table maps a report to a second level hash table */
+typedef struct {
+    prc_lookup_table2 *arr[LOOKUP_TABLE1_SIZE]; ///< a second level hash table, each bucket holds a second level lookup table
+} prc_lookup_table;
+
+/// an instance of a packet response canceller, which implements a packet response buffer
+typedef struct {
+    prc_lookup_table lt; ///< the lookup table, used for quick access to a given report
+    prc_time_table tt;  ///< the time-based table, used for quick access to the reports from a given second
+    port_status_t timeout_implication;  ///< the implication for when a report times out
+    prc_report_status_fn status_callback;  ///< the function to call with report status
+    void *callback_context; ///< context to provide with the callback on report status
+} packet_resp_canceller;
+
+
+void init_packet_resp_canceller(packet_resp_canceller *self,int wait_secs,prc_report_status_fn status_callback,void *callback_context,port_status_t timeout_implication);
+packet_resp_canceller *new_packet_resp_canceller(int wait_secs,prc_report_status_fn status_callback,void *callback_context,port_status_t timeout_implication);
+void free_packet_resp_canceller(packet_resp_canceller *self);
+
+void packet_resp_canceller_new_time(packet_resp_canceller *self,time_t time);
+
+void packet_resp_canceller_add_report(packet_resp_canceller *self,spade_report *rpt);
+void packet_resp_canceller_note_response(packet_resp_canceller *self,port_status_t implied_status,u32 sip,u16 sport,u32 dip,u16 dport,int portless);
+
+void packet_resp_canceller_print_config_details(packet_resp_canceller *self,FILE *f,char *indent);
+
+/*@}*/
+
+#endif  /* ! PACKET_RESP_CANCELLER_H */
+
+
+/* Id: packet_resp_canceller.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
+
+
+
+
+
+typedef void (*netspade_exc_callback_t)(void *context,spade_report *rpt);
+typedef void (*netspade_adj_callback_t)(void *context,char *id,char *mess,int using_corrrscore);
+
+/// the type of xarg_type_t node value; either unsigned int or CIDR
+typedef enum {XARG_TYPE_UINT,XARG_TYPE_CIDR} xarg_type_t;
+
+/// an administatively excluded field value; this results from Xdips, Xsports, etc
+typedef struct _xfeatval_link {
+    features feat; ///< the field the restriction is on
+    xarg_type_t type;  /// the type of the value for this restriction
+    union {
+        int i; /// the value to exclude, if type=XARG_TYPE_UINT
+        struct {
+            u32 netip; /// the network IP address in the CIDR
+            u32 netmask;  /// the netmask in the CIDR
+        } cidr; /// the network to exclude, if type=XARG_TYPE_CIDR
+    } val;
+    struct _xfeatval_link *next; /// the next element in a linked list of this type
+} xfeatval_link;
+
+struct _netspade;
+
+/// encapsulates the state specific to a netspade detector
+typedef struct _netspade_detector {
+    /// the next netspade_detector in a linked list of them
+    struct _netspade_detector *next;
+    struct _netspade* parent;
+    /// the id for this detector
+    char *id;
+
+    /// the type of detector this is; value is from spade_detect_types.h
+    int detect_type;
+    /// the packet conditions under which this detector will calculate the score and assess anomalousness
+    event_condition_set scorecalc_conds;
+    /// should this detector ignore packets with destination IPs that are broadcast IP addresses
+    int exclude_broadcast_dip;
+    /// if the detector is doing response waiting, this is the implication of a timeout
+    port_status_t thresh_exc_port_impl;
+
+    /// the packet conditions under which this detector will store an event in the probability table
+    event_condition_set store_conds;
+    /// the packet conditions for which this detector will check for a response in the open direction
+    event_condition_set cancel_open_conds;
+    /// the packet conditions for which this detector will check for a response in the closed direction
+    event_condition_set cancel_closed_conds;
+    /// the criterea required for a anomalous event to be reported (versus dropped)
+    port_status_set_t port_report_criterea;
+    
+    /// the libspade entity which calculates anomaly scores
+    score_calculator calculator;
+    /// the libspade score manager
+    score_mgr mgr;
+    /// if non-NULL, the packet response canceller in use
+    packet_resp_canceller *canceller;
+
+    /// the shared state with the score manager
+    spade_enviro enviro;
+    /// the packet stats as of the last time the anomaly score was adjusted
+    spade_pkt_stats last_adj_stats;
+    
+    /// a linked list of reports to exclude in this detector; suppliments netspade's global list
+    xfeatval_link *rpt_exclude_list;
+
+    /// \brief the detection type we report for this detector
+    /// \note eventually, there may be more than one detection type possible from a given detector, so this will need to be generalized
+    int report_detection_type;
+    /// the string encoding the scope of this detector; used in building reports
+    char *report_scope_str; 
+} netspade_detector;
+
+/// a link in a linked list of networks
+typedef struct _ll_net {
+    u32 netaddr; ///< the network address
+    u32 netmask; ///< the network mask
+    struct _ll_net *next;  ///< the next link in a linked list of networks
+} ll_net;
+
+/// a instance of netspade
+typedef struct _netspade {
+    /// the head of a linked list of detectors contained in this netspade
+    netspade_detector *detectors;
+    /// the tail of the linked list of detectors
+    netspade_detector *detectors_tail;
+    /// the packet conditions under which we need to pass an event to our event_recorder
+    event_condition_set recorder_needed_conds;
+    /// the packet conditions under which we need to do something besides storing a packet
+    event_condition_set nonstore_conds;
+    /// the the packet conditions that we actually need to calculate for any given packet
+    event_condition_set conds_to_calc;
+
+    ll_net *homelist_head; ///< the head a linked list of home networks
+    ll_net *homelist_tail; ///< the tail in a linked list of home networks 
+
+    char *checkpoint_file; ///< the name of the file to checkpoint to
+    int checkpoint_freq; ///< the frequency (in recorded packet counts) with which to checkpoint
+
+    /// records how many things have been recorded since the last checkpoint
+    int records_since_checkpoint;
+    /// the last packet time that we passed along to the enties that need it
+    time_t last_time_forwarded;
+    
+    /// the callback to invoke when there is an anomalous event
+    netspade_exc_callback_t exc_callback;
+    /// the callback to invoke when the threshold has been adjusted in a detector, or NULL if none should be called
+    netspade_adj_callback_t adj_callback;
+    /// the netspade-user-defined context to provide with the callback
+    void *callback_context;
+    
+    /// a pointer to a routine to call to make a copy of the "native" field of a spade_event, or NULL if none is needed
+    /** this is used when a spade_event is being copied for storage in the response buffer (packet reponse canceller) */
+    event_native_copier_t pkt_native_copier_callback;
+    /// a pointer to a routine to call free a copy of the "native" field of a spade_event, or NULL if none is needed
+    /** this is used when a copied spade_event is being freed when it is being removed from the packet reponse canceller */
+    event_native_freer_t pkt_native_freer_callback;
+    
+    xfeatval_link *rpt_exclude_list; ///< a linked list of reports to exclude globally
+
+    event_recorder recorder; ///< our event recorder
+
+    u8 stats_to_print; ///< the statistics to print to the output log file
+    char *outfile; ///< the name of the output log file
+
+    int debug_level;  ///< the debug level we are at (bigger is higher/more verbose)
+    spade_msg_fn msg_callback; ///< the function to call when we have a text message for the user
+    
+    int detector_id_nonce;  ///< the default detector id for the last detector that was set up
+    unsigned long total_pkts; ///< the total number of packets passed to us
+} netspade;
+
+
+void init_netspade(netspade *self, spade_msg_fn msg_callback, int debug_level);
+int init_netspade_from_statefile(netspade *self, char *statefile, spade_msg_fn msg_callback, int debug_level);
+netspade *new_netspade(spade_msg_fn msg_callback, int debug_level);
+netspade *new_netspade_from_statefile(char *statefile, spade_msg_fn msg_callback, int debug_level,int *succ);
+
+void netspade_set_callbacks(netspade *self, void *context, netspade_exc_callback_t exc_callback, netspade_adj_callback_t adj_callback, event_native_copier_t pkt_native_copier_callback, event_native_freer_t pkt_native_freer_callback);
+void netspade_set_checkpointing(netspade *self, char *checkpoint_file, int checkpoint_freq);
+void netspade_set_homenet_from_str(netspade *self, char *homenet_str);
+void netspade_set_output_stats(netspade *self, int stats_to_print);
+void netspade_set_output_stats_from_str(netspade *self, char *str);
+int netspade_set_output(netspade *self, char *file, int stats_to_print);
+int netspade_set_output_file(netspade *self, char *file);
+void netspade_add_rpt_excludes(netspade *self,char *xsips,char *xdips,char *xsports,char *xdports);
+
+char *netspade_new_detector(netspade *self, char *str);
+
+int netspade_set_detector_scaling(netspade *self, char *detectorid, int scale_freq, double scale_factor, double prune_threshold);
+char *netspade_setup_detector_adapt_from_str(netspade *self, int adaptmode, char *str);
+int netspade_setup_detector_adapt1(netspade *self, char *detectorid, int adapttarget, time_t period, float new_obs_weight, int by_count);
+int netspade_setup_detector_adapt2(netspade *self, char *detectorid, double targetspec, double obsper, int NS, int NM, int NL);
+int netspade_setup_detector_adapt3(netspade *self, char *detectorid, double targetspec, double obsper, int NO);
+int netspade_setup_detector_advise(netspade *self, char *detectorid, int obs_size, int obs_secs);
+char *netspade_setup_detector_advise_from_str(netspade *self, char *str);
+int netspade_setup_detector_survey(netspade *self, char *detectorid, char *filename, float interval);
+char *netspade_setup_detector_survey_from_str(netspade *self, char *str);
+
+void netspade_new_pkt(netspade *self, spade_event *pkt);
+
+void netspade_dump(netspade *self);
+void netspade_cleanup(netspade *self);
+void netspade_write_log(netspade *self);
+
+char *netspade_detector_scope_str(netspade *self,char *id);
+
+int netspade_print_detector_config_details(netspade *self,FILE *f,char *id);
+
+void print_conds(event_condition_set conds);
+void print_conds_line(event_condition_set conds);
+
+/*@}*/
+
+#endif // NETSPADE_H
+/*********************************************************************
+strtok.h, distributed as part of Spade v030125.1
+Author: James Hoagland, Silicon Defense (hoagland@SiliconDefense.com)
+copyright (c) 2002 by Silicon Defense (http://www.silicondefense.com/)
+Released under GNU General Public License, see the COPYING file included
+with the distribution or http://www.silicondefense.com/spice/ for details.
+
+Please send complaints, kudos, and especially improvements and bugfixes to
+hoagland@SiliconDefense.com.  As described in GNU General Public License, no
+warranty is expressed for this program.
+*********************************************************************/
+
+#ifndef STRTOK_H
+#define STRTOK_H
+
+/*! \file strtok.h
+ * \brief
+ *  strtok.h is the header file for strtok.c.
+ * \ingroup libspade_util
+ */
+
+/*! \addtogroup libspade_util
+    @{
+*/
+
+
+
+int fill_args_space_sep(char *str,char *format,void *args[],spade_msg_fn msg_callback);
+char *extract_str_arg_space_sep(char *str,char *argname);
+int terminate_first_tok(char *str,char *sepchars,char **head,char *oldchar);
+
+/*@}*/
+#endif // STRTOK_H
+
+/* Id: strtok.h,v 1.1 2004/10/11 14:35:54 jonkman Exp $ */
