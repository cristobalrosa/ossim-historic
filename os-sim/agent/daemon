#!/usr/bin/env python
# Found daemon mode within a post from Ulrich Berning
#============================================================================#
# Import the necessary modules                                               #
#----------------------------------------------------------------------------#
from optparse import OptionParser
from Agent import Agent
import util
import sys, os, string, time, signal, errno

LOG_DIR  = '/var/log/ossim_agent'
RUN_DIR  = '/var/run/'

def parse_options():
    
    """ parse command line options """

    parser = OptionParser(usage = "usage: %prog [-v] [-q] [-c config_file] [stop|status]", 
                          version = util.VERSION)
    parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                      help="make lots of noise [default]")
    parser.add_option("-q", "--quiet", dest="quiet", action="store_true",
                      help="don't show debug messages")
    parser.add_option("-c", "--config", dest="config_file", action="store",
                      help = "read config from FILE", metavar="FILE")
    (options, args) = parser.parse_args()

    if len(args) > 1:
        parser.error("incorrect number of arguments")
    if options.quiet:
        util.VERBOSE = False
    if options.verbose:
        util.VERBOSE = True
    if len(sys.argv) == 2:
        if sys.argv[1] == 'stop':
            if os.path.isfile(os.path.join(RUN_DIR, 'ossim_agent.pid')):
                f = open(os.path.join(RUN_DIR, 'ossim_agent.pid'), 'r')
                pid = string.atoi(string.strip(f.readline()))
                f.close()
                print pid
                try:
                    os.kill(pid, 0)
                except os.error, args:
                    if args[0] != errno.ESRCH: # NO SUCH PROCESS
                        raise os.error, args
                else:
                    print pid
                    os.kill(pid, signal.SIGKILL)
                    sys.exit(0)
            sys.stdout.write("%s: daemon is not running\n" % call_name)
            sys.exit(1)
        elif sys.argv[1] == 'status':
            if os.path.isfile(os.path.join(RUN_DIR, 'ossim_agent.pid')):
                f = open(os.path.join(RUN_DIR, 'ossim_agent.pid'), 'r')
                pid = string.atoi(string.strip(f.readline()))
                f.close()
                try:
                    os.kill(pid, 0)
                except os.error, args:
                    if args[0] != errno.ESRCH: # NO SUCH PROCESS
                        raise os.error, args
                else:
                    sys.stdout.write("%s: daemon [%d] is running\n" % (call_name, pid))
                    sys.exit(0)
            sys.stdout.write("%s: daemon is not running\n" % call_name)
            sys.exit(0)

    return options

def waitforever():
    """Wait for a Control-C and kill all threads"""

    while 1:
        try:
            time.sleep(1)
        except KeyboardInterrupt:
            pid = os.getpid()
            os.kill(pid, signal.SIGTERM)
    if options.verbose:
        util.VERBOSE = True

    return options



#============================================================================#
# ----- Signal Handlers ---------------------------------------------------- #
#----------------------------------------------------------------------------#
#============================================================================#
# terminate() - Signal handler that is called on SIGTERM                     #
#----------------------------------------------------------------------------#
def terminate(signal, param):
    try:
        # Do necessary cleanup handling
        #...
        #...
        #...

        # Remove the pid file
        os.remove(os.path.join(RUN_DIR, 'ossim_agent.pid'))
    except:
        pass                            # Ignore any errors
    sys.stdout.write("........terminating\n")
    pid = os.getpid()
    os.kill(pid, signal.SIGKILL)
    #sys.exit(0)

#============================================================================#
# ----- Main Routine ------------------------------------------------------- #
#----------------------------------------------------------------------------#
# Store the name of the programm
call_name = os.path.split(sys.argv[0])[1]

# Get the call arguments (stop, status)
options = parse_options()

if len(sys.argv) > 2:
    sys.stderr.write("Usage: %s [stop|status]\n" % call_name)
    sys.exit(1)
# Check, if the log directory is already there. If not, create it
if not os.path.isdir(LOG_DIR):
    os.mkdir(LOG_DIR, 0755)

# Check, if there is already a running instance
if os.path.isfile(os.path.join(RUN_DIR, 'ossim_agent.pid')):
    f = open(os.path.join(RUN_DIR, 'ossim_agent.pid'), 'r')
    pid = string.atoi(string.strip(f.readline()))
    f.close()
    try:
        os.kill(pid, 0)
    except os.error, args:
        if args[0] != errno.ESRCH: # NO SUCH PROCESS
            raise os.error, args
    else:
        sys.stderr.write("%s: there is already a running instance\n" % call_name)
        sys.exit(1)

# Initialize error logging
f_stderr = open(os.path.join(LOG_DIR, 'error.log'), 'w')

# Initialize message logging
f_stdout = open(os.path.join(LOG_DIR, 'message.log'), 'w')

# Print a startup message
sys.stdout.write("%s: started at %s\n" % (call_name, time.strftime("%d.%m.%Y / %H:%M:%S", time.localtime(time.time()))))
sys.stdout.write("%s: log directory is is '%s'\n" % (call_name, LOG_DIR))
sys.stdout.write("%s: going into background........\n" % call_name)

#============================================================================#
# Initialize a daemon process                                                #
#----------------------------------------------------------------------------#
# Change to the log directory, this permits an umount on this directory
os.chdir(LOG_DIR)

# Do the following only, if we were not started by the init process
if os.getppid() != 1:
    # Ignore a terminal output signal
    signal.signal(signal.SIGTTOU, signal.SIG_IGN)
    # Ignore a terminal input signal
    signal.signal(signal.SIGTTIN, signal.SIG_IGN)
    # Ignore a terminal stop signal
    signal.signal(signal.SIGTSTP, signal.SIG_IGN)
    # Fork the first child
    pid = os.fork()
    # The parent ends here
    if pid > 0:
        sys.exit(0)
    # Make ourself a leader of the process group
    os.setpgrp()
    # Ignore a hangup signal
    signal.signal(signal.SIGHUP, signal.SIG_IGN)
    # Fork the second child
    pid = os.fork()
    # The parent ends here
    if pid > 0:
        sys.exit(0)

# Close sys.stdin
sys.stdin.close()
# Close sys.stdout and redirect the message log to sys.stdout
sys.stdout.close()
sys.stdout = f_stdout
# Close sys.stderr and redirect the error log to sys.stderr
sys.stderr.close()
sys.stderr = f_stderr
# Reset the umask
os.umask(000)
# Ignore a dead of child signal
#signal.signal(signal.SIGCLD, signal.SIG_IGN)
# Install a hander for ther terminate signal
signal.signal(signal.SIGTERM, terminate)
# Install a handler for the interrupt signal
signal.signal(signal.SIGINT, terminate)
# Install a handler for the quit signal
signal.signal(signal.SIGQUIT, terminate)

# Write our process id into the pid file
f = open(os.path.join(RUN_DIR, 'ossim_agent.pid'), 'w')
f.write("%d" % os.getpid())
f.close()

# Print a startup message
sys.stdout.write("%s: started at %s\n" % (call_name, time.strftime("%d.%m.%Y / %H:%M:%S", time.localtime(time.time()))))
sys.stdout.write("%s: log directory is is '%s'\n" % (call_name, LOG_DIR))
sys.stdout.write("%s: going into background........\n" % call_name)
sys.stdout.flush()

    
if options.config_file is None:
    options.config_file = util.CONFIG

# Init agent and read config
agent = Agent()
agent.parseConfig(options.config_file)

# connect to server
if agent.connect():
    agent.monitor()
    agent.append_plugins()
    agent.parser()

waitforever()




